本章介绍以下内容：

- 关键字：`return`
- 运算符：`*`（一元）、`&`（一元）
- **函数**及其定义方式
- 如何使用**参数**和**返回值**
- **如何把指针变量用作函数参数**
- 函数类型
- ANSI C 原型
- **递归**

如何组织程序？C 的设计思想是，**把函数用作构件块**。我们已经用过 C 标准库的函数，如 `printf()`、`scanf()`、`getchar()`、`putchar()` 和 `strlen()`。现在要进一步学习如何创建自己的函数。前面章节中已大致介绍了相关过程，本章将巩固以前学过的知识并做进一步的拓展。

## 9.1 复习函数

首先，什么是函数？**函数（function）是完成特定任务的独立程序代码单元**。语法规则定义了函数的结构和使用方式。虽然 C 中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如 `printf()` 把数据打印到屏幕上；一些函数找出一个值供程序使用，如 `strlen()` 把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。

为什么要使用函数？**首先，使用函数可以省去编写重复代码的苦差**。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用 `putchar()` 一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为**函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善**。例如，假设要编写一个程序完成以下任务：

- 读入一系列数字；
- 分类这些数字；
- 找出这些数字的平均值；
- 打印一份柱状图。

可以使用下面的程序：

```c
#include <stdio.h>
#define SIZE 50
int main(void)
{
    float list[SIZE];

    readlist(list, SIZE);
    sort(list, SIZE);
    average(list, SIZE);
    bargraph(list, SIZE);

    return 0;
}
```

当然，还要编写 4 个函数 `readlist()`、`sort()`、`average()` 和 `bargraph()` 的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。

许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用 `printf()` 时，只需知道给该函数传入格式字符串或一些参数以及 `printf()` 生成的输出，无需了解 `printf()` 的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。

如何了解函数？首先要知道如何正确地定义函数、如何调用函数和如何建立函数间的通信。我们从一个简单的程序示例开始，帮助读者理清这些内容，然后再详细讲解。

### 9.1.1 创建并使用简单函数

我们的第 1 个目标是创建一个在一行打印 40 个星号的函数，并在一个打印表头的程序中使用该函数。如程序清单 9.1 所示，该程序由 `main()` 和 `starbar()` 组成。

```c
// 程序清单9.1 lethead1.c程序
/* lethead1.c */
#include <stdio.h>
#define NAME "GIGATHINK, INC."
#define ADDRESS "101 Megabuck Plaza"
#define PLACE "Megapolis, CA 94904"
#define WIDTH 40

void starbar(void);  /* prototype the function */

int main(void)
{
    starbar();
    printf("%s\n", NAME);
    printf("%s\n", ADDRESS);
    printf("%s\n", PLACE);
    starbar();       /* use the function       */

    return 0;
}

void starbar(void)   /* define the function    */
{
    int count;

    for (count = 1; count <= WIDTH; count++)
        putchar('*');
    putchar('\n');
}
```

运行：

```c
****************************************
GIGATHINK, INC.
101 Megabuck Plaza
Megapolis, CA 94904
****************************************
```

### 9.1.2 分析程序

该程序要注意以下几点。

- 程序在 3 处使用了 `starbar` 标识符：**函数原型**（function prototype）告诉编译器函数 `starbar()` 的类型；**函数调用**（function call）表明在此处执行函数；**函数定义**（function definition）明确地指定了函数要做什么。
- 函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。因此，在 `main()` 函数定义的前面出现了下面的 ANSI C 风格的函数原型：
  ```c
  void starbar(void);
  ```
  圆括号表明 `starbar` 是一个函数名。第 1 个 `void` 是函数类型，`void` 类型表明函数没有返回值。第 2 个 `void`（在圆括号中）表明该函数不带参数。分号表明这是在声明函数，不是定义函数。也就是说，这行声明了程序将使用一个名为 `starbar()`、没有返回值、没有参数的函数，并告诉编译器在别处查找该函数的定义。对于不识别 ANSI C 风格原型的编译器，只需声明函数的类型，如下所示：
  ```c
  void starbar();
  ```
  注意，一些老版本的编译器甚至连 `void` 都识别不了。如果使用这种编译器，就要把没有返回值的函数声明为 `int` 类型。当然，最好还是换一个新的编译器。
- 一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的**签名**（signature）。对于 `starbar()` 函数而言，其签名是该函数没有返回值，没有参数。
- 程序把 `starbar()` 原型置于 `main()` 的前面。当然，也可以放在 `main()` 里面的声明变量处。放在哪个位置都可以。
- 在 `main()` 中，执行到下面的语句时调用了 `starbar()` 函数：
  ```c
  starbar();
  ```
  这是调用 `void` 类型函数的一种形式。当计算机执行到 `starbar();` 语句时，会找到该函数的定义并执行其中的内容。执行完 `starbar()` 中的代码后，计算机返回**主调函数**（calling function）继续执行下一行（本例中，主调函数是 `main()`，更确切地说，编译器把 C 程序翻译成执行以上操作的机器语言代码）。
- 程序中 `strarbar()` 和 `main()` 的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束。注意，函数头中的 `starbar()` 后面没有分号，告诉编译器这是定义 `starbar()`，而不是调用函数或声明函数原型。
- 程序把 `starbar()` 和 `main()` 放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把 `#define` 和 `#include` 指令也放入该文件。我们稍后会讨论使用多个文件的情况。现在，先把所有的函数都放在一个文件中。`main()` 的右花括号告诉编译器该函数结束的位置，后面的 `starbar()` 函数头告诉编译器 `starbar()` 是一个函数。

<div align=center>
<img width="60%" src="\programme\C_C++\C_primer_plus\image\简单函数的结构.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;">  图 9.2 简单函数的结构
</div>
</div>

- `starbar()` 函数中的变量 `count` 是**局部变量**（local variable），意思是该变量只属于 `starbar()` 函数。可以在程序中的其他地方（包括 `main()` 中）使用 `count`，这不会引起名称冲突，它们是同名的不同变量。

如果把 `starbar()` 看作是一个黑盒，那么它的行为是打印一行星号。不用给该函数提供任何输入，因为调用它不需要其他信息。而且，它没有返回值，所以也不给 `main()` 提供（或返回）任何信息。简而言之，`starbar()` 不需要与主调函数通信。

接下来介绍一个函数间需要通信的例子。

### 9.1.3 函数参数

在程序清单 9.1 的输出中，如果文字能居中，信头会更加美观。可以通过在打印文字之前打印一定数量的空格来实现，这和打印一定数量的星号（`starbar()` 函数）类似，只不过现在要打印的是一定数量的空格。虽然这是两个任务，但是任务非常相似，与其分别为它们编写一个函数，不如写一个更通用的函数，可以在两种情况下使用。我们设计一个新的函数 `show_n_char()`（显示一个字符 `n` 次）。唯一要改变的是使用内置的值来显示字符和重复的次数，`show_n_char()` 将使用函数参数来传递这些值。

```c
// 程序清单9.2 lethead2.c程序
/* lethead2.c */
#include <stdio.h>
#include <string.h>            /* for strlen() */
#define NAME "GIGATHINK, INC."
#define ADDRESS "101 Megabuck Plaza"
#define PLACE "Megapolis, CA 94904"
#define WIDTH 40
#define SPACE ' '

void show_n_char(char ch, int num);

int main(void)
{
    int spaces;

    show_n_char('*', WIDTH);   /* using constants as arguments */
    putchar('\n');
    show_n_char(SPACE, 12);    /* using constants as arguments */
    printf("%s\n", NAME);
    spaces = (WIDTH - strlen(ADDRESS)) / 2;
    /* Let the program calculate    */
    /* how many spaces to skip      */
    show_n_char(SPACE, spaces);/* use a variable as argument   */
    printf("%s\n", ADDRESS);
    show_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2);
    /* an expression as argument    */
    printf("%s\n", PLACE);
    show_n_char('*', WIDTH);
    putchar('\n');

    return 0;
}

/* show_n_char() definition */
void show_n_char(char ch, int num)
{
    int count;

    for (count = 1; count <= num; count++)
        putchar(ch);
}

```

### 9.1.4 定义带形式参数的函数

函数定义从下面的 ANSI C 风格的函数头开始：

```c
void show_n_char(char ch, int num)
```

该行告知编译器 `show_n_char()` 使用两个参数 `ch` 和 `num`，`ch` 是 `char` 类型，`num` 是 `int` 类型。这两个变量被称为形式参数（formal argument，但是最近的标准推荐使用 formal parameter），简称**形参**。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。这意味着在其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。

注意，ANSI C 要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：

```c
void dibs(int x, y, z) /* 无效的函数头 */
void dubs(int x, int y, int z) /* 有效的函数头 */
```

虽然 `show_n_char()` 接受来自 `main()` 的值，但是它没有返回值。因此，`show_n_char()` 的类型是 `void`。

下面，我们来学习如何使用函数。

### 9.1.5 声明带形式参数函数的原型

在使用函数之前，要用 ANSI C 形式声明函数原型：

```c
void show_n_char(char ch, int num);
```

当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：

```c
void show_n_char(char, int);
```

在原型中使用变量名并没有实际创建变量，`char` 仅代表了一个 `char` 类型的变量，以此类推。

在函数调用中，**实际参数**（actual argument，简称**实参**）提供了 `ch` 和 `num` 的值。考虑程序清单 9.2 中第 1 次调用 `show_n_char()`：

```c
show_n_char(SPACE, 12);
```

实际参数是空格字符和 12。这两个值被赋给 `show_n_char()` 中相应的形式参数：变量 `ch` 和 `num`。简而言之，形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。如上例所示，实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。以程序清单 9.2 中最后一次调用 `show_n_char()` 为例：

```c
show_n_char(SPACE, (WIDTH - strlen(PLACE)) / 2);
```

构成该函数第 2 个实际参数的是一个很长的表达式，对该表达式求值为 10。然后，10 被赋给变量 `num`。被调函数不知道也不关心传入的数值是来自常量、变量还是一般表达式。再次强调，实际参数是具体的值，该值要被赋给作为形式参数的变量。<mark>因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据</mark>。

##### 注意：实际参数和形式参数

实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果。程序清单 9.2 中，`'*'` 和 `WIDTH` 都是第 1 次调用 `show_n_char()` 时的实际参数，而 `SPACE` 和 `11` 是第 2 次调用 `show_n_char()` 时的实际参数。在函数定义中，`ch` 和 `num` 都是该函数的形式参数。

### 9.1.7 黑盒视角

从黑盒的视角看 `show_n_char()`，待显示的字符和显示的次数是输入。执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这些信息清楚地表明了如何在 `main()` 中使用该函数。而且，这也可以作为编写该函数的设计说明。

黑盒方法的核心部分是：`ch`、`num` 和 `count` 都是 `show_n_char()` 私有的局部变量。如果在 `main()` 中使用同名变量，那么它们相互独立，互不影响。也就是说，如果` main()` 有一个 `count` 变量，那么改变它的值不会改变 `show_n_char()` 中的 `count`，反之亦然。黑盒里发生了什么对主调函数是不可见的。

### 9.1.8 使用 return 从函数中返回值

前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返回值可以把信息从被调函数传回主调函数。为进一步说明，我们将创建一个返回两个参数中较小值的函数。由于函数被设计用来处理 `int` 类型的值，所以被命名为 `imin()`。另外，还要创建一个简单的 `main()`，用于检查 `imin()` 是否正常工作。这种被设计用于测试函数的程序有时被称为**驱动程序**（driver），该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。程序清单 9.3 演示了这个驱动程序和返回最小值的函数。

```c
// 程序清单9.3 lesser.c程序
/* lesser.c -- finds the lesser of two evils */
#include <stdio.h>
int imin(int, int);

int main(void)
{
    int evil1, evil2;

    printf("Enter a pair of integers (q to quit):\n");
    while (scanf("%d %d", &evil1, &evil2) == 2)
    {
        printf("The lesser of %d and %d is %d.\n",
               evil1, evil2, imin(evil1,evil2));
        printf("Enter a pair of integers (q to quit):\n");
    }
    printf("Bye.\n");

    return 0;
}

int imin(int n,int m)
{
    int min;

    if (n < m)
        min = n;
    else
        min = m;

    return min;
}
```

运行：

```c
Enter a pair of integers (q to quit):
509 333
The lesser of 509 and 333 is 333.
Enter a pair of integers (q to quit):
578
-9393 6
The lesser of -9393 and 6 is -9393.
Enter a pair of integers (q to quit):
q
Bye.
```

- `scanf()` 返回成功读数据的个数，所以如果输入不是两个整数会导致循环终止。

关键字 `return` 后面的表达式的值就是函数的返回值。在该例中，该函数返回的值就是变量 `min` 的值。因为 `min` 是 `int` 类型的变量，所以 `imin()` 函数的类型也是 `int`。

变量 `min` 属于 `imin()` 函数私有，但是 `return` 语句把 `min` 的值传回了主调函数。下面这条语句的作用是把 `min` 的值赋给 `lesser`:

```c
lesser = imin(n,m);
```

是否能像写成下面这样：

```c
imin(n,m);
lesser = min;
```

不能。因为主调函数甚至不知道 `min` 的存在。记住，`imin()` 中的变量是 `imin()` 的局部变量。函数调用 `imin(evil1, evil2)` 只是把两个变量的值拷贝了一份。

<mark>返回值不仅可以赋给变量，也可以被用作表达式的一部分</mark>。例如，可以这样：

```c
answer = 2 * imin(z, zstar) + 25;
printf("%d\n", imin(-32 + answer, LIMIT));
```

返回值不一定是变量的值，也可以是任意表达式的值。例如，可以用以下的代码简化程序示例：

```c
/* 返回最小值的函数，第2个版本 */
imin(int n,int m)
{
    return (n < m) ? n : m;
}
```

条件表达式的值是 `n` 和 `m` 中的较小者，该值要被返回给主调函数。虽然这里不要求用圆括号把返回值括起来，但是如果想让程序条理更清楚或统一风格，可以把返回值放在圆括号内。

如果函数返回值的类型与函数声明的类型不匹配会怎样？

```c
int what_if(int n)
{
    double z = 100.0 / (double) n;
    return z; // 会发生什么？
}
```

<mark>实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值</mark>。因此在本例中，相当于把 `z` 的值赋给 `int` 类型的变量，然后返回 `int` 类型变量的值。例如，假设有下面的函数调用：

```c
result = what_if(64);
```

虽然在 `what_if()` 函数中赋给 `z` 的值是 `1.5625`，但是 `return` 语句返回确实 `int` 类型的值 `1`。

使用 `return` 语句的另一个作用是，**终止函数并把控制返回给主调函数的下一条语句**。因此，可以这样编写 `imin()`：

```c
/*返回最小值的函数，第3个版本*/
imin(int n,int m)
{
    if (n < m)
        return n;
    else
        return m;
}
```

许多 C 程序员都认为只在函数末尾使用一次 `return` 语句比较好，因为这样做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个 `return` 语句也没有错。无论如何，对用户而言，这 3 个版本的函数用起来都一样，因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的版本也没问题：

```c
/*返回最小值的函数，第4个版本*/
imin(int n, int m)
{
    if (n < m)
        return n;
    else
        return m;
    printf("Professor Fleppard is like totally a fopdoodle.\n");
}
```

`return` 语句导致 `printf()` 语句永远不会被执行。

另外，还可以这样使用 `return`：

```c
return;
```

这条语句会导致终止函数，并把控制返回给主调函数。因为 `return` 后面没有任何表达式，所以没有返回值，只有在 `void` 函数中才会用到这种形式。

### 9.1.9 函数类型

声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为 `void` 类型。如果没有声明函数的类型，旧版本的 C 编译器会假定函数的类型是 `int`。这一惯例源于 C 的早期，那时的函数绝大多数都是 `int` 类型。然而，C99 标准不再支持 `int` 类型函数的这种假定设置。

类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。例如，下面的函数头定义了一个带两个 `int` 类型参数的函数，但是其返回值是 `double` 类型。

```c
double klink(int a, int b)
```

要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第 1 次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在 C 库或其他文件中。

因此，通常的做法是提前声明函数，把函数的信息告知编译器。例如，程序清单 9.3 中的 `main()` 函数包含以下几行代码：

```c
#include <stdio.h>
int imin(int, int);
int main(void)
{
    int evil1, evil2, lesser;
```

第 2 行代码说明 `imin` 是一个函数名，有两个 `int` 类型的形参，且返回 `int` 类型的值。现在，编译器在程序中调用 `imin()` 函数时就知道应该如何处理。

在程序清单 9.3 中，我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。例如，重写 `lesser.c`（程序清单 9.3）的开头部分：

```c
#include <stdio.h>
int main(void)
{
    int imin(int, int); /* 声明imin()函数的原型*/
    int evil1, evil2, lesser;
```

注意在这两种情况中，函数原型都声明在使用函数之前。

ANSI C 标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如，`stdio.h` 头文件包含了标准 I/O 库函数（如，`printf()` 和 `scanf()`）的声明。`math.h` 头文件包含了各种数学函数的声明。例如，下面的声明：

```c
double sqrt(double);
```

告知编译器 `sqrt()` 函数有一个 `double` 类型的形参，而且返回 `double` 类型的值。不要混淆函数的声明和定义。<mark>函数声明告知编译器函数的类型，而函数定义则提供实际的代码</mark>。在程序中包含 `math.h` 头文件告知编译器：`sqrt()` 返回 `double` 类型，但是 `sqrt()` 函数的代码在另一个库函数的文件中。

## 9.2 ANSI C 函数原型

在 ANSI C 标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么问题。

下面是 ANSI 之前的函数声明，告知编译器 `imin()` 返回 `int` 类型的值：

```c
int imin();
```

然而，以上函数声明并未给出 `imin()` 函数的参数个数和类型。因此，如果调用 `imin()` 时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来。

### 9.2.2 ANSI 的解决方案

针对参数不匹配的问题，ANSI C 标准要求在函数声明时还要声明变量的类型，即使用**函数原型**（function prototype）来声明函数的返回类型、参数的数量和每个参数的类型。未标明 `imax()` 函数有两个 `int` 类型的参数，可以使用下面两种函数原型来声明：

```c
int imax(int, int);
int imax(int a, int b);
```

第 1 种形式使用以逗号分隔的类型列表，第 2 种形式在类型后面添加了变量名。注意，这里的变量名是假名，不必与函数定义的形式参数名一致。

有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的数量是否正确？参数的类型是否匹配？以 `imax()` 为例，如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。例如，`imax(3.0, 5.0)` 会被转换成 `imax(3, 5)`。

虽然没有错误消息，但是的编译器还是给出了警告：`double` 转换成 `int` 可能会导致丢失数据。例如，下面的函数调用：

```c
imax(3.9, 5.4)
```

相当于:

```c
imax(3, 5)
```

错误和警告的区别是：**错误导致无法编译，而警告仍然允许编译**。一些编译器在进行类似的类型转换时不会通知用户，因为 C 标准中对此未作要求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述警告时的详细程度。

### 9.2.3 无参数和未指定参数

假设有下面的函数原型：

```c
void print_name();
```

一个支持 ANSI C 的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用 `void` 关键字：

```c
void print_name(void);
```

支持 ANSI C 的编译器解释为 `print_name()` 不接受任何参数。然后在调用该函数时，编译器会检查以确保没有使用参数。一些函数接受（如，`printf()` 和 `scanf()`）许多参数。例如对于 `printf()`，第 1 个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C 允许使用**部分原型**。例如，对于 `printf()` 可以使用下面的原型：

```c
int printf(const char *, ...);
```

这种原型表明，第 1 个参数是一个字符串（第 11 章中将详细介绍），可能还有其他未指定的参数。

C 库通过 `stdarg.h` 头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。第 16 章中详细介绍相关内容。

### 9.2.4 函数原型的优点

函数原型是 C 语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。如果编译器没有发现这些问题，就很难觉察出来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明（即不用声明任何形参），但是这样做的弊大于利。

有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之所以使用函数原型，是为了让编译器在第 1 次执行到该函数之前就知道如何使用它。因此，把整个函数定义放在第 1 次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普遍：

```c
// 下面这行代码既是函数定义，也是函数原型
int imax(int a, int b) { return a > b ? a : b; }
int main()
{
    int x, z;
    ...
    z = imax(x, 50);
    ...
}
```

## 9.3 递归

C 允许函数调用它自己，这种调用过程称为**递归**（recursion）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，**一个调用自己的函数会无限递归**。可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。

我们通过一个程序示例，来学习什么是递归。程序清单 9.6 中的 `main()` 函数调用 `up_and_down()` 函数，这次调用称为“第 1 级递归”。然后 `up_and_down()` 调用自己，这次调用称为“第 2 级递归”。接着第 2 级递归调用第 3 级递归，以此类推。该程序示例共有 4 级递归。为了进一步深入研究递归时发生了什么，程序不仅显示了变量 `n` 的值，还显示了储存 `n` 的内存地址 `&n`（。本章稍后会详细讨论 `&` 运算符，`printf()` 函数使用 `%p` 转换说明打印地址，如果你的系统不支持这种格式，请使用 `%u` 或 `%lu` 代替 `%p`）。

```c
// 程序清单9.6 recur.c程序
/* recur.c -- recursion illustration */
#include <stdio.h>
void up_and_down(int);

int main(void)
{
    up_and_down(1);
    return 0;
}

void up_and_down(int n)
{
    printf("Level %d: n location %p\n", n, &n); // 1
    if (n < 4)
        up_and_down(n+1);
    printf("LEVEL %d: n location %p\n", n, &n); // 2

}
```

运行：

```c
Level 1: n location 0x0012ff48
Level 2: n location 0x0012ff3c
Level 3: n location 0x0012ff30
Level 4: n location 0x0012ff24
LEVEL 4: n location 0x0012ff24
LEVEL 3: n location 0x0012ff30
LEVEL 2: n location 0x0012ff3c
LEVEL 1: n location 0x0012ff48
```

注意，每级递归的变量 `n` 都属于本级递归私有。这从程序输出的地址值可以看出（当然，不同的系统表示的地址格式不同，这里关键要注意，`Level 1` 和 `LEVEL1` 的地址相同，`Level 2` 和 `LEVEL2` 的地址相同，等等）。

如果觉得不好理解，可以假设有一条函数调用链——`fun1()` 调用 `fun2()`、`fun2()` 调用 `fun3()`、`fun3()` 调用 `fun4()`。当 `fun4()` 结束时，控制传回 `fun3()`；当 `fun3()` 结束时，控制传回 `fun2()`；当 `fun2()` 结束时，控制传回 `fun1()`。递归的情况与此类似，只不过 `fun1()`、`fun2()`、`fun3()` 和 `fun4()` 都是相同的函数。

### 9.3.2 递归的基本原理

初次接触递归会觉得较难理解。为了帮助读者理解递归过程，下面以程序清单 9.6 为例讲解几个要点。

**第 1，每级函数调用都有自己的变量**。也就是说，第 1 级的 `n` 和第 2 级的 `n` 不同，所以程序创建了 4 个单独的变量，每个变量名都是 `n`，但是它们的值各不相同。当程序最终返回 `up_and_down()` 的第 1 级调用时，最初的 `n` 仍然是它的初值 1（见图 9.4）。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\递归中的变量.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;">  图 9.4 递归中的变量
</div>
</div>

**第 2，每次函数调用都会返回一次**。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级 `up_and_down()` 返回上一级的 `up_and_down()`，不能跳级回到 `main()` 中的第 1 级调用。

**第 3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行**。例如，程序清单 9.6 中的打印语句 `#1` 位于递归调用之前，它按照递归的顺序：第 1 级、第 2 级、第 3 级和第 4 级，被执行了 4 次。

**第 4，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行**。例如，打印语句 `#2` 位于递归调用之后，其执行的顺序是第 4 级、第 3 级、第 2 级、第 1 级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。

**第 5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码**。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。

**最后，递归函数必须包含能让递归调用停止的语句**。通常，递归函数都使用 `if` 或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。例如，程序清单 9.6 中的 `up_and_down(n)` 调用 `up_and_down(n+1)`。最终，实际参数等于 4 时，`if` 的测试条件 `(n < 4)` 为假。

### 9.3.3 尾递归

**最简单的递归形式是把递归调用置于函数的末尾**，即正好在 `return` 语句之前。这种形式的递归被称为**尾递归**（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。

下面要介绍的程序示例中，分别用**循环**和**尾递归**计算**阶乘**。一个正整数的阶乘（factorial）是从 1 到该整数的所有整数的乘积。例如，3 的阶乘（写作 3！）是 1×2×3。另外，0！等于 1，负数没有阶乘。程序清单 9.7 中，第 1 个函数使用 `for` 循环计算阶乘，第 2 个函数使用递归计算阶乘。

```c
// 程序清单9.7 factor.c程序
// factor.c -- uses loops and recursion to calculate factorials
#include <stdio.h>
long fact(int n);
long rfact(int n);
int main(void)
{
    int num;

    printf("This program calculates factorials.\n");
    printf("Enter a value in the range 0-12 (q to quit):\n");
    while (scanf("%d", &num) == 1)
    {
        if (num < 0)
            printf("No negative numbers, please.\n");
        else if (num > 12)
            printf("Keep input under 13.\n");
        else
        {
            printf("loop: %d factorial = %ld\n",
                   num, fact(num));
            printf("recursion: %d factorial = %ld\n",
                   num, rfact(num));
        }
        printf("Enter a value in the range 0-12 (q to quit):\n");
    }
    printf("Bye.\n");

    return 0;
}

long fact(int n)     // loop-based function
{
    long ans;

    for (ans = 1; n > 1; n--)
        ans *= n;

    return ans;
}

long rfact(int n)    // recursive version
{
    long ans;

    if (n > 0)
        ans= n * rfact(n-1);
    else
        ans = 1;

    return ans;
}
```

运行：

```c
This program calculates factorials.
Enter a value in the range 0-12 (q to quit):
5
loop: 5 factorial = 120
recursion: 5 factorial = 120
Enter a value in the range 0-12 (q to quit):
10
loop: 10 factorial = 3628800
recursion: 10 factorial = 3628800
Enter a value in the range 0-12 (q to quit):
q
Bye.
```

测试驱动程序把输入限制在 0~12。因为 12! 已快接近 5 亿，而 13! 比 62 亿还大，已超过我们系统中 `long` 类型能表示的范围。要计算超过 12 的阶乘，必须使用能表示更大范围的类型，如 `double` 或 `long long`。

使用循环的函数把 `ans` 初始化为 1，然后把 `ans` 与从 `n~2` 的所有递减整数相乘。根据阶乘的公式，还应该乘以 1，但是这并不会改变结果。

现在考虑使用递归的函数。该函数的关键是 `n! = n×(n-1)!`。可以这样做是因为 `(n-1)!` 是 `n-1~1` 的所有正整数的乘积。因此，`n` 乘以 `n-1` 就得到 `n` 的阶乘。阶乘的这一特性很适合使用递归。如果调用函数 `rfact()`，`rfact(n)` 是 `n*rfact(n-1)`。因此，通过调用 `rfact(n-1)` 来计算 `rfact(n)`，如程序清单 9.7 中所示。当然，必须要在满足某条件时结束递归，可以在 `n` 等于 0 时把返回值设为 1。

程序清单 9.7 中使用递归的输出和使用循环的输出相同。注意，虽然 `rfact()` 的递归调用不是函数的最后一行，但是当 `n>0` 时，它是该函数执行的最后一条语句，因此它也是尾递归。

既然用递归和循环来计算都没问题，那么到底应该使用哪一个？**一般而言，选择循环比较好**。首先，每次递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。那么，演示这个程序示例的目的是什么？因为尾递归是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环代替递归，因此读者还是要好好理解递归。

### 9.3.4 递归和倒序计算

**递归在处理倒序时非常方便**（在解决这类问题中，递归比循环简单）。我们要解决的问题是：编写一个函数，打印一个整数的二进制数。二进制表示法根据 2 的幂来表示数字。例如，十进制数 234 实际上是 $2\times 10^2+3\times 10^1+ 4\times10^0$，所以二进制数 101 实际上是 $1\times 2^2+0\times 2^1+1 \times2^0$。二进制数由 0 和 1 表示。

我们要设计一个以二进制形式表示整数的方法或**算法**（algorithm）。例如，如何用二进制表示十进制数 5？在二进制中，奇数的末尾一定是 1，偶数的末尾一定是 0，所以通过 5%2 即可确定 5 的二进制数的最后一位是 1 还是 0。一般而言，对于数字 n，其二进制的最后一位是 n%2。因此，计算的第一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归函数的递归调用之前计算 n%2，在递归调用之后打印计算结果。这样，**计算的第 1 个值正好是最后一个打印的值**。

要获得下一位数字，必须把原数除以 2。这种计算方法相当于在十进制下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是 0；如果是奇数，就是 1。例如，5/2 得 2（整数除法），2 是偶数（2%2 得 0），所以下一位二进制数是 0。到目前为止，我们已经获得 10。继续重复这个过程。2/2 得 1，1%2 得 1，所以下一位二进制数是 1。因此，我们得到 5 的等价二进制数是 101。那么，程序应该何时停止计算？当与 2 相除的结果小于 2 时停止计算，因为只要结果大于或等于 2，就说明还有二进制位。每次除以 2 就相当于去掉一位二进制，直到计算出最后一位为止（如果不好理解，可以拿十进制数来做类比：628%10 得 8，因此 8 就是该数最后一位；而 628/10 得 62，而 62%10 得 2，所以该数的下一位是 2，以此类推）。程序清单 9.8 演示了上述算法。

```c
// 程序清单9.8 binary.c程序
/* binary.c -- prints integer in binary form */
#include <stdio.h>
void to_binary(unsigned long n);

int main(void)
{
    unsigned long number;
    printf("Enter an integer (q to quit):\n");
    while (scanf("%lu", &number) == 1)
    {
        printf("Binary equivalent: ");
        to_binary(number);
        putchar('\n');
        printf("Enter an integer (q to quit):\n");
    }
    printf("Done.\n");

    return 0;
}

void to_binary(unsigned long n)   /* recursive function */
{
    int r;

    r = n % 2;
    if (n >= 2)
        to_binary(n / 2);
     putchar(r == 0 ? '0' : '1');

    return;
}
```

运行：

```c
Enter an integer (q to quit):
9
Binary equivalent: 1001
Enter an integer (q to quit):
255
Binary equivalent: 11111111
602
Enter an integer (q to quit):
1024
Binary equivalent: 10000000000
Enter an integer (q to quit):
q
done.
```

在该程序中，如果 `r` 的值是 0，`to_binary()` 函数就显示字符 `'0'`；如果 `r` 的值是 1，`to_binary()` 函数则显示字符 `'1'`。条件表达式 `r == 0 ? '0' : '1'` 用于把数值转换成字符。

不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，**数组**）。第 15 章中会介绍一个不用递归实现该算法的例子。

### 9.3.5 递归的优缺点

递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。<mark>缺点是一些递归算法会快速消耗计算机的内存资源</mark>。另外，递归不方便阅读和维护。我们用一个例子来说明递归的优缺点。

**斐波那契数列**的定义如下：第 1 个和第 2 个数字都是 1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。斐波那契数列在数学界深受喜爱，甚至有专门研究它的刊物。不过，这不在本书的讨论范围之内。下面，我们要创建一个函数，接受正整数 `n`，返回相应的斐波那契数值。

首先，来看递归。递归提供一个简单的定义。如果把函数命名为 `Fibonacci()`，那么如果 `n` 是 1 或 2， `Fibonacci(n)` 应返回 1；对于其他数值，则应返回 `Fibonacci(n-1)+Fibonacci(n-2)`：

```c
unsigned long Fibonacci(unsigned n)
{
    if (n > 2)
        return Fibonacci(n-1) + Fibonacci(n-2);
    else
        return 1;
}
```

这个递归函数只是重述了数学定义的递归。该函数使用了**双递归**（double recursion），即函数每一级递归都要调用本身两次。这暴露了一个问题。

为了说明这个问题，假设调用 `Fibonacci(40)`。这是第 1 级递归调用，将创建一个变量 `n`。然后在该函数中要调用 `Fibonacci()` 两次，在第 2 级递归中要分别创建两个变量 `n`。这两次调用中的每次调用又会进行两次调用，因而在第 3 级递归中要创建 4 个名为 `n` 的变量。此时总共创建了 7 个变量。由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！在第 5 章中介绍过一个计算小麦粒数的例子，按指数增长很快就会产生非常大的值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。

虽然这是个极端的例子，但是该例说明：在程序中使用递归要特别注意，尤其是效率优先的程序。

##### 所有的 C 函数皆平等

程序中的每个 C 函数与其他函数都是平等的。**每个函数都可以调用其他函数，或被其他函数调用**。这点与 Pascal 和 Modula-2 中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。

`main()` 函数是否与其他函数不同？是的，`main()` 的确有点特殊。当 `main()` 与程序中的其他函数放在一起时，最开始执行的是 `main()` 函数中的第 1 条语句，但是这也是局限之处。`main()` 也可以被自己或其他函数递归调用——尽管很少这样做。

## 9.4 编译多源代码文件的程序

使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明。

### 9.4.1 UNIX

假定在 UNIX 系统中安装了 UNIX C 编译器 cc（最初的 cc 已经停用，但是许多 UNIX 系统都给 cc 命令起了一个别名用作其他编译器命令，典型的是 gcc 或 clang）。假设 `file1.c` 和 `file2.c` 是两个内含 C 函数的文件，下面的命令将编译两个文件并生成一个名为 `a.out` 的可执行文件：

```c
cc file1.c file2.c
```

另外，还生成两个名为 `file1.o` 和 `file2.o` 的目标文件。如果后来改动了 `file1.c`，而 `file2.c` 不变，可以使用以下命令编译第 1 个文件，并与第 2 个文件的目标代码合并：

```c
cc file1.c file2.o
```

UNIX 系统的 `make` 命令可自动管理多文件程序，但是这超出了本书的讨论范围。

注意，OS X 的 Terminal 工具可以打开 UNIX 命令行环境，但是必须先下载命令行编译器（GCC 和 Clang）。

### 9.4.2 Linux

假定 Linux 系统安装了 GNU C 编译器 GCC。假设 `file1.c` 和 `file2.c` 是两个内含 C 函数的文件，下面的命令将编译两个文件并生成名为 `a.out` 的可执行文件：

```c
gcc file1.c file2.c
```

另外，还生成两个名为 `file1.o` 和 `file2.o` 的目标文件。如果后来改动了 `file1.c`，而 `file2.c` 不变，可以使用以下命令编译第 1 个文件，并与第 2 个文件的目标代码合并：

```c
gcc file1.c file2.o
```

### 9.4.3 DOS 命令行编译器

绝大多数 DOS 命令行编译器的工作原理和 UNIX 的 cc 命令类似，只不过使用不同的名称而已。其中一个区别是，对象文件的扩展名是 `.obj`，而不是 `.o`。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。

### 9.4.4 Windows 和苹果的 IDE 编译器

Windows 和 Macintosh 系统使用的集成开发环境中的编译器是面向项目的。项目（project）描述的是特定程序使用的资源。资源包括源代码文件。这种 IDE 中的编译器要创建项目来运行单文件程序。对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表中列出。许多 IDE 都不用在项目列表中列出头文件（即扩展名为 `.h` 的文件），因为项目只管理使用的源代码文件，源代码文件中的 `#include` 指令管理该文件中使用的头文件。但是，Xcode 要在项目中添加头文件。

### 9.4.5 使用头文件

如果把 `main()` 放在第 1 个文件中，把函数定义放在第 2 个文件中，那么第 1 个文件仍然要使用函数原型。**把函数原型放在头文件中**，就不用在每次使用函数文件时都写出函数的原型。C 标准库就是这样做的，例如，把 I/O 函数原型放在 `stdio.h` 中，把数学函数原型放在 `math.h` 中。你也可以这样用自定义的函数文件。

另外，程序中经常用 C 预处理器定义**符号常量**。这种定义只储存了那些包含 `#define` 指令的文件。如果把程序的一个函数放进一个独立的文件中，你也可以使用 `#define` 指令访问每个文件。最直接的方法是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改了 `#define` 定义的值，就必须在每个文件中修改。更好的做法是，把 `#define` 指令放进头文件，然后在每个源文件中使用 `#include` 指令包含该文件即可。

**总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯**。我们考虑一个例子：假设要管理 4 家酒店的客房服务，每家酒店的房价不同，但是每家酒店所有房间的房价相同。对于预订住宿多天的客户，第 2 天的房费是第 1 天的 95%，第 3 天是第 2 天的 95%，以此类推（暂不考虑这种策略的经济效益）。设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出。

程序清单 9.9、程序清单 9.10 和程序清单 9.11 演示了如何编写这样的程序。第 1 个程序清单包含 `main()` 函数，提供整个程序的组织结构。第 2 个程序清单包含支持的函数，我们假设这些函数在独立的文件中。最后，程序清单 9.11 列出了一个头文件，包含了该程序所有源文件中使用的**自定义符号常量和函数原型**。前面介绍过，在 UNIX 和 DOS 环境中，`#include "hotels.h"` 指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）。如果使用 IDE，需要知道如何把头文件合并成一个项目。

```c
// 程序清单9.9 usehotel.c控制模块
/* usehotel.c -- room rate program */
/* compile with  Listing 9.10      */
#include <stdio.h>
#include "hotel.h" /* defines constants, declares functions */

int main(void)
{
    int nights;
    double hotel_rate;
    int code;

    while ((code = menu()) != QUIT)
    {
        switch(code)
        {
            case 1 : hotel_rate = HOTEL1;
                break;
            case 2 : hotel_rate = HOTEL2;
                break;
            case 3 : hotel_rate = HOTEL3;
                break;
            case 4 : hotel_rate = HOTEL4;
                break;
            default: hotel_rate = 0.0;
                printf("Oops!\n");
                break;
        }
        nights = getnights();
        showprice(hotel_rate, nights);
    }
    printf("Thank you and goodbye.\n");

    return 0;
}
```

```c
// 程序清单9.10 hotel.c函数支持模块
/* hotel.c -- hotel management functions */
#include <stdio.h>
#include "hotel.h"
int menu(void)
{
    int code, status;

    printf("\n%s%s\n", STARS, STARS);
    printf("Enter the number of the desired hotel:\n");
    printf("1) Fairfield Arms           2) Hotel Olympic\n");
    printf("3) Chertworthy Plaza        4) The Stockton\n");
    printf("5) quit\n");
    printf("%s%s\n", STARS, STARS);
    while ((status = scanf("%d", &code)) != 1  ||
           (code < 1 || code > 5))
    {
        if (status != 1)
            scanf("%*s");   // dispose of non-integer input
        printf("Enter an integer from 1 to 5, please.\n");
    }

    return code;
}

int getnights(void)
{
    int nights;

    printf("How many nights are needed? ");
    while (scanf("%d", &nights) != 1)
    {
        scanf("%*s");       // dispose of non-integer input
        printf("Please enter an integer, such as 2.\n");
    }

    return nights;
}

void showprice(double rate, int nights)
{
    int n;
    double total = 0.0;
    double factor = 1.0;

    for (n = 1; n <= nights; n++, factor *= DISCOUNT)
        total += rate * factor;
    printf("The total cost will be $%0.2f.\n", total);
}
```

```c
// 程序清单9.11 hotel.h头文件
/* hotel.h -- constants and declarations for hotel.c */
#define QUIT       5
#define HOTEL1   180.00
#define HOTEL2   225.00
#define HOTEL3   255.00
#define HOTEL4   355.00
#define DISCOUNT   0.95
#define STARS "**********************************"

// shows list of choices
int menu(void);

// returns number of nights desired
int getnights(void);

// calculates price from rate, nights
// and displays result
void showprice(double rate, int nights);
```

运行：

```c
********************************************************************
Enter the number of the desired hotel:
1) Fairfield Arms 2) Hotel Olympic
3) Chertworthy Plaza 4) The Stockton
5) quit
********************************************************************
3
How many nights are needed? 1
The total cost will be $255.00.
613
********************************************************************
Enter the number of the desired hotel:
1) Fairfield Arms 2) Hotel Olympic
3) Chertworthy Plaza 4) The Stockton
5) quit
********************************************************************
4
How many nights are needed? 3
The total cost will be $1012.64.
********************************************************************
Enter the number of the desired hotel:
1) Fairfield Arms 2) Hotel Olympic
3) Chertworthy Plaza 4) The Stockton
5) quit
********************************************************************
5
Thank you and goodbye.
```

顺带一提，该程序中有几处编写得很巧妙。尤其是，`menu()` 和 `getnights()` 函数通过测试 `scanf()` 的返回值来跳过非数值数据，而且调用 `scanf("%*s")` 跳至下一个空白字符。注意，`menu()` 函数中是如何检查非数值输入和超出范围的数据：

```c
while ((status = scanf("%d", &code)) != 1 ||(code < 1 || code > 5))
```

以上代码段利用了 C 语言的两个规则：从左往右对逻辑表达式求值；一旦求值结果为假，立即停止求值。在该例中，只有在 `scanf()` 成功读入一个整数值后，才会检查 `code` 的值。

用不同的函数处理不同的任务时应检查数据的有效性。当然，首次编写 `menu()` 或 `getnights()` 函数时可以暂不添加这一功能，只写一个简单的 `scanf()` 即可。待基本版本运行正常后，再逐步改善各模块。

## 9.5 查找地址：& 运算符

**指针**（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的 `scanf()` 函数中就使用地址作为参数。概括地说，如果主调函数不使用 `return` 返回的值，则必须通过地址才能修改主调函数中的值。接下来，我们将介绍带地址参数的函数。首先介绍一元 `&` 运算符的用法。

一元 `&` 运算符给出变量的存储地址。如果 `pooh` 是变量名，那么 `&pooh` 是变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句：

```c
pooh = 24;
```

假设 `pooh` 的存储地址是 `0B76`（PC 地址通常用十六进制形式表示）。那么，下面的语句：

```c
printf("%d %p\n", pooh, &pooh);
```

将输出如下内容（`%p` 是输出地址的转换说明）：

```c
24 0B76
```

程序清单 9.12 中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。

```c
// 程序清单9.12 loccheck.c程序
/* loccheck.c  -- checks to see where variables are stored  */
#include <stdio.h>
void mikado(int);                      /* declare function  */
int main(void)
{
    int pooh = 2, bah = 5;             /* local to main()   */

    printf("In main(), pooh = %d and &pooh = %p\n",
           pooh, &pooh);
    printf("In main(), bah = %d and &bah = %p\n",
           bah, &bah);
    mikado(pooh);

    return 0;
}

void mikado(int bah)                   /* define function   */
{
    int pooh = 10;                     /* local to mikado() */

    printf("In mikado(), pooh = %d and &pooh = %p\n",
           pooh, &pooh);
    printf("In mikado(), bah = %d and &bah = %p\n",
           bah, &bah);
}
```

程序清单 9.12 中使用 ANSI C 的 `%p` 格式打印地址。我们的系统输出如下：

```c
In main(), pooh = 2 and &pooh = 0x7fff5fbff8e8
In main(), bah = 5 and &bah = 0x7fff5fbff8e4
In mikado(), pooh = 10 and &pooh = 0x7fff5fbff8b8
In mikado(), bah = 2 and &bah = 0x7fff5fbff8bc
```

实现不同，`%p` 表示地址的方式也不同。然而，许多实现都如本例所示，以十六进制显示地址。顺带一提，每个十六进制数对应 4 位，该例显示 12 个十六进制数，对应 48 位地址。

该例的输出说明了什么？首先，两个 `pooh` 的地址不同，两个 `bah` 的地址也不同。因此，和前面介绍的一样，计算机把它们看成 4 个独立的变量。其次，函数调用 `mikado(pooh)` 把实际参数（`main()` 中的 `pooh`）的值（2）传递给形式参数（`mikado()` 中的 `bah`）。注意，这种传递只传递了值。涉及的两个变量（`main()` 中的 `pooh` 和 `mikado()` 中的 `bah`）并未改变。

我们强调第 2 点，是因为这并不是在所有语言中都成立。例如，在 FORTRAN 中，子例程会影响主调例程的原始变量。子例程的变量名可能与原始变量不同，但是它们的地址相同。但是，在 C 语言中不是这样。每个 C 函数都有自己的变量。这样做更可取，因为这样做可以防止原始变量被被调函数中的副作用意外修改。然而，正如下节所述，这也带来了一些麻烦。

## 9.6 更改主调函数中的变量

有时需要在一个函数中更改其他函数的变量。例如，普通的排序任务中交换两个变量的值。假设要交换两个变量 `x` 和 `y` 的值。简单的思路是：

```c
x = y;
y = x;
```

这完全不起作用，因为执行到第 2 行时，`x` 的原始值已经被 `y` 的原始值替换了。因此，要多写一行代码，储存 `x` 的原始值：

```c
temp = x;
x = y;
y = temp;
```

上面这 3 行代码便可实现交换值的功能，可以编写成一个函数并构造一个驱动程序来测试。在程序清单 9.13 中，为清楚地表明变量属于哪个函数，在 `main()` 中使用变量 `x` 和 `y`，在 `intercharge()` 中使用 `u` 和 `v`。

```c
// 程序清单9.13 swap1.c程序
/* swap1.c -- first attempt at a swapping function */
#include <stdio.h>
void interchange(int u, int v); /* declare function */

int main(void)
{
    int x = 5, y = 10;

    printf("Originally x = %d and y = %d.\n", x , y);
    interchange(x, y);
    printf("Now x = %d and y = %d.\n", x, y);

    return 0;
}

void interchange(int u, int v)  /* define function  */
{
    int temp;

    temp = u;
    u = v;
    v = temp;
}
```

运行：

```c
Originally x = 5 and y = 10.
Now x = 5 and y = 10.
```

两个变量的值并未交换！我们在 `interchange()` 中添加一些打印语句来检查错误（见程序清单 9.14）。

```c
// 程序清单9.14 swap2.c程序
/* swap2.c -- researching swap1.c */
#include <stdio.h>
void interchange(int u, int v);

int main(void)
{
    int x = 5, y = 10;

    printf("Originally x = %d and y = %d.\n", x , y);
    interchange(x, y);
    printf("Now x = %d and y = %d.\n", x, y);

    return 0;
}

void interchange(int u, int v)
{
    int temp;

    printf("Originally u = %d and v = %d.\n", u , v);
    temp = u;
    u = v;
    v = temp;
    printf("Now u = %d and v = %d.\n", u, v);
}
```

运行：

```c
Originally x = 5 and y = 10.
Originally u = 5 and v = 10.
Now u = 10 and v = 5.
Now x = 5 and y = 10.
```

看来，`interchange()` 没有问题，它交换了 `u` 和 `v` 的值。问题出在把结果传回 `main()` 时。`interchange()` 使用的变量并不是 `main()` 中的变量。因此，交换 `u` 和 `v` 的值对 `x` 和 `y` 的值没有影响！是否能用 `return` 语句把值传回 `main()`？当然可以，在 `interchange()` 的末尾加上下面一行语句：

```c
return(u);
```

然后修改 `main()` 中的调用：

```c
x = interchange(x,y);
```

这只能改变 `x` 的值，而 `y` 的值依旧没变。用 `return` 语句只能把被调函数中的一个值传回主调函数，但是现在要传回两个值。这没问题！不过，要使用指针。

## 9.7 指针简介

指针？什么是指针？从根本上看，**指针**（pointer）是一个值为内存地址的变量（或数据对象）。正如 `char` 类型变量的值是字符，`int` 类型变量的值是整数，指针变量的值是地址。在 C 语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。

假设一个指针变量名是 `ptr`，可以编写如下语句：

```c
ptr = &pooh; // 把pooh的地址赋给ptr
```

对于这条语句，我们说 `ptr` “指向” `pooh`。`ptr` 和 `&pooh` 的区别是 `ptr` 是变量，而 `&pooh` 是常量。或者，`ptr` 是可修改的左值，而 `&pooh` 是右值。还可以把 `ptr` 指向别处：

```c
ptr = &bah; // 把ptr指向bah，而不是pooh
```

现在 `ptr` 的值是 `bah` 的地址。

要创建指针变量，先要声明指针变量的类型。假设想把 `ptr` 声明为储存 `int` 类型变量地址的指针，就要使用下面介绍的新运算符。

### 9.7.1 简介运算符：\*

假设已知 `ptr` 指向 `bah`，如下所示：

```c
ptr = &bah;
```

然后使用**间接运算符** `*`（indirection operator）找出储存在 `bah` 中的值，该运算符有时也称为**解引用运算符**（dereferencing operator）。不要把间接运算符和二元乘法运算符（`*`）混淆，虽然它们使用的符号相同，但语法功能不同。

```c
val = *ptr; // 找出ptr指向的值
```

由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。

示例：

```c
nurse = 22;
ptr = &nurse; // 指向nurse的指针
val = *ptr; // 把ptr指向的地址上的值赋给val
```

执行以上 3 条语句的最终结果是把 `22` 赋给 `val`。

### 9.7.2 声明指针

相信读者已经很熟悉如何声明 `int` 类型和其他基本类型的变量，那么如何**声明指针变量**？你也许认为是这样声明：

```c
pointer ptr; // 不能这样声明指针
```

为什么不能这样声明？因为**声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小**。另外，程序必须知道储存在指定地址上的数据类型。`long` 和 `float` 可能占用相同的存储空间，但是它们储存数字却大相径庭。下面是一些指针的声明示例：

```c
int * pi; // pi是指向int类型变量的指针
char * pc; // pc是指向char类型变量的指针
float * pf, * pg; // pf、pg都是指向float类型变量的指针
```

类型说明符表明了指针所指向对象的类型，星号（`*`）表明声明的变量是一个指针。`int * pi;` 声明的意思是 `pi` 是一个指针，`*pi` 是 `int` 类型（见图 9.5）。

<div align=center>
<img width="80%" src="\programme\C_C++\C_primer_plus\image\图9.5_声明并使用指针.png"/> <br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 图9.5 声明并使用指针。</div>
</div>

`*` 和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。

`pc` 指向的值（`*pc`）是 `char` 类型。`pc` 本身是什么类型？我们描述它的类型是“指向 `char` 类型的指针”。`pc` 的值是一个**地址**，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C 专门为指针提供了 `%p` 格式的转换说明。

### 9.7.3 使用指针在函数间通信