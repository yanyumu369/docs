本章介绍以下内容：

- 关键字：`int` 、`short`、`long`、`unsigned`、`char`、`float`、`double`、`_Bool`、`_Complex`、`_Imaginary`
- 运算符：`sizeof()`
- 函数：`scanf()`
- 整数类型和浮点数类型的区别
- 如何书写整型和浮点型常数，如何声明这些类型的变量
- 如何使用 `printf()` 和 `scanf()` 函数读写不同类型的值

本章详细介绍两大数据类型：**整数类型**和**浮点数类型**，讲解这些数据类型是什么、如何声明它们、如何以及何时使用它们。

## 3.1 示例程序

```c
// 程序清单3.1 platinum.c程序
/* platinum.c -- your weight in platinum */
#include <stdio.h>
int main(void)
{
    float weight; // 你的体重
    float value;  // 相等重量的白金价值

    printf("Are you worth your weight in platinum?\n");
    printf("Let's check it out.\n");
    printf("Please enter you weight in pounds: ");

    // 获取用户的输入
    scanf("%f", &weight);
    // 假设白金的加个是每盎司$1700
    // 14.583 用于把英镑常衡盎司转换为金衡盎司
    value = 1700.0 * weight * 14.5833;
    printf("Your weight in platinum is worth $%.2f\n", value);
    printf("You are easily worth that! If platinum prices drop,\n");
    printf("eat more to maintain your value.\n");

    return 0;
}
```

运行：

```c
Are you worth your weight in platinum?
Let's check it out.
Please enter you weight in pounds: 156
Your weight in platinum is worth $3867491.25
You are easily worth that! If platinum prices drop,
eat more to maintain your value.
```

- 金衡盎司用于衡量贵金属，而英镑常衡盎司用于衡量人的体重。
- 注意，“enter your weight” 的意思是输入你的体重，然后按下 Enter 或 Return 键（不要键入体重后就一直等着）。按下 Enter 键是告知计算机，你已完成输入数据。该程序需要你输入一个**数字**（如，155），而不是单词（如，too much）。如果输入字母而不是数字，会导致程序出问题。

##### 提示：错误与警告

如果输入程序时打错（如，漏了一个分号），编译器会报告**语法错误**消息。然而，即使输入正确无误，编译器也可能给出一些警告，如“警告：从 double 类型转换成 float 类型可能会丢失数据”。<mark>错误消息表明程序中有错，不能进行编译。而警告则表明，尽管编写的代码有效，但可能不是程序员想要的。警告并不终止编译</mark>。特殊的警告与 C 如何处理 1700.0 这样的值有关。

### 3.1.1 程序中的新元素

程序清单 3.1 中包含 C 语言的一些新元素：

- 本例使用了**浮点数类型**（`float`）的变量，以便处理更大范围的数据。`float`类型可以储存带小数的数字。
- 为了打印新类型的变量，在 `printf()`中使用`%f`来处理浮点值。`%.2f`中的`.2`用于精确控制输出，指定输出的浮点数只显示小数点后面两位。
- `scanf()`函数用于读取键盘的输入。`%f`说明`scanf()`要读取用户从键盘输入的浮点数，`&weight`告诉`scanf()`把输入的值赋给名为`weight`的变量。`scanf()`函数使用`&`符号表明找到`weight`变量的地点。
- 本程序最突出的新特点是它的**交互性**，交互式使得程序更加灵活。计算机向用户询问信息，然后用户输入数字。`scanf()`和`printf()`函数用于实现这种交互。`scanf()`函数读取用户从键盘输入的数据，并把数据传递给程序；`printf()`函数读取程序中的数据，并把数据显示在屏幕上。把两个函数结合起来，就可以建立**人机双向通信**。

## 3.2 变量与常量数据

程序完成任务需要使用**数据**，即**承载信息的数字和字符**。有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为**常量**（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为**变量**（variable）。

## 3.3 数据：数据类型关键字

不仅变量和常量不同，不同的数据类型之间也有差异。一些数据类型表示**数字**，一些数据类型表示**字母**（更普遍地说是字符）。C 通过识别一些基本的数据类型来区分和使用这些不同的数据类型。如果数据是**常量**，编译器一般通过用户书写的形式来识别类型（如，42 是整数，42.100 是浮点数）。但是，**对变量而言，要在声明时指定其类型**。

C 语言的基本类型关键字：K&C 给出了 7 个与类型相关的关键字。C90 标准添加了 2 个关键字，C99 标准又添加了 3 个关键字。

| 最初 K&R 给出的关键字 | C90 标准添加的关键字 | C90 标准添加的关键字 |
| --------------------- | -------------------- | -------------------- |
| int                   | signed               | \_Bool               |
| long                  | void                 | \_Complex            |
| short                 |                      | \_Imaginary          |
| unsigned              |                      |                      |
| char                  |                      |                      |
| float                 |                      |                      |
| double                |                      |                      |

在 C 语言中，用 `int` 关键字来表示基本的整数类型。后 3 个关键字（`long`、`short` 和 `unsigned`）和 C90 新增的 signed 用于提供基本整数类型的变式，例如 `unsigned short int` 和 `long long int`。char 关键字用于指定字母和其他字符（如，`#`、`$`、`%` 和 `*`）。另外，`char` 类型也可以表示较小的整数。`float`、`double` 和 `long double` 表示带小数点的数。`_Bool` 类型表示布尔值（`true` 或 `false`），`_complex` 和 `_Imaginary` 分别表示复数和虚数。

通过这些关键字创建的类型，按计算机的储存方式可分为两大基本类型：**整数类型**和**浮点数**类型。对我们而言，整数和浮点数的区别是它们的书写方式不同。对计算机而言，它们的区别是存储方式不同。

##### 位、字节和字

**位**、**字节**和**字**是描述**计算机数据单元或存储单元**的术语。这里主要指**存储单元**。

最小的存储单元是**位**（bit），可以储存 0 或 1（或者说，位用于设置“开”或“关”）。虽然 1 位储存的信息有限，但是计算机中位的数量十分庞大。**位是计算机内存的基本构建块**。

**字节**（byte）是常用的计算机存储单位。**对于几乎所有的机器，1 字节均为 8 位**。这是字节的标准定义，至少在衡量存储单位时是这样（但是，C 语言对此有不同的定义）。既然 1 位可以表示 0 或 1，那么 8 位字节就有 256（2 的 8 次方）种可能的 0、1 的组合。通过二进制编码（仅用 0 和 1 便可表示数字），便可表示 0 ~ 255 的整数或一组字符。

**字**（word）是设计计算机时给定的自然存储单位。对于 8 位的微型计算机（如，最初的苹果机）， 1 个字长只有 8 位。从那以后，个人计算机字长增至 16 位、32 位，直到目前的 64 位。**计算机的字长越大，其数据转移越快，允许的内存访问也更多**。

### 3.3.1 整数和浮点数

对我们而言，整数和浮点数的区别是它们的书写方式不同。对计算机而言，它们的区别是储存方式不同。

#### 3.3.2 整数

和数学的概念一样，在 C 语言中，整数是没有小数部分的数。

#### 3.3.3 浮点数

浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮点数。注意，**在一个值后面加上一个小数点，该值就成为一个浮点值**。所以，7 是整数，7.00 是浮点数。显然，书写浮点数有多种形式。e 记数法：3.16E7 表示 $3.16 \times 10^7$（3.16 乘以 10 的 7 次方）。

- 这里关键要理解浮点数和整数的储存方案不同。**计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分**。因此，虽然 7.00 和 7 在数值上相同，但是它们的储存方式不同。
- 整数没有小数部分，浮点数有小数部分。
- 浮点数可以表示的范围比整数大。
- <mark>对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多</mark>。
- <mark>因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值</mark>。浮点数通常只是实际值的近似值。例如，7.0 可能被储存为浮点值 6.99999。
- 过去，浮点运算比整数运算慢。不过，现在许多 CPU 都包含浮点处理器，缩小了速度上的差距。

## 3.4 C 语言基本数据类型

本节将详细节介绍 C 语言的基本数据类型，包括**如何声明变量**、**如何表示字面值常量**（如，5 或 2.78），以及**典型的用法**。一些老式的 C 语言编译器无法支持这里提到的所有类型，请查阅你使用的编译器文档，了解可以使用哪些类型。

### 3.4.1 int 类型

C 语言提供了许多整数类型，为什么一种类型不够用？因为 **C 语言让程序员针对不同情况选择不同的类型**。特别是，**C 语言中的整数类型可表示不同的取值范围和正负值**。一般情况使用 `int` 类型即可，但是为满足特定任务和机器的要求，还可以选择其他类型。

`int` 类型是有符号整型，即 `int` 类型的值必须是整数，可以是**正整数**、**负整数**或**零**。其取值范围依计算机系统而异。一般而言，储存一个 `int` 要占用一个机器字长。ISO C 规定 `int` 的取值范围最小为 -32768~32767（16 位）。一般而言，系统用一个特殊位的值表示有符号整数的正负号。

#### 1. 声明 int 变量

- 可以分别在 4 条声明中声明各变量，也可以在一条声明中声明 4 个变量。两种方法的效果相同，都为 4 个 int 大小的变量**赋予名称并分配内存空间**。
- 变量如何获得值？第 1 种途径是**赋值**：`cows = 112;`。第 2 种途径是**通过函数获得值**，如 `scanf()`。第 3 种途径是**初始化变量**。

#### 2. 初始化变量

**初始化（initialize）变量就是为变量赋一个初始值**。在 C 语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符（`=`）和待赋给变量的值即可。如下所示：

```c
int hogs = 21;
int cows = 32, goats = 14;
int dogs, cats = 94; /* 有效，但是这种格式很糟糕 */
```

以上示例的最后一行，只初始化了 `cats`，并未初始化 `dogs`。这种写法很容易让人误认为 `dogs` 也被初始化为 `94`，所以<mark>最好不要把初始化的变量和未初始化的变量放在同一条声明中</mark>。

**简而言之，声明为变量创建和标记存储空间，并为其指定初始值**。

#### 3. int 类型常量

上面示例中出现的整数（21、32、14 和 94）都是**整型常量**或**整型字面量**。C 语言把不含小数点和指数的数作为整数。因此，22 和 -44 都是整型常量，但是 22.0 和 2.2E1 则不是。C 语言把大多数整型常量视为 int 类型，但是非常大的整数除外。

#### 4. 打印 int 值

可以使用 `printf()` 函数打印 `int` 类型的值。第 2 章中介绍过，`%d` 指明了在一行中打印整数的位置。`%d` 称为**转换说明**，它指定了 `printf()` 应使用什么格式来显示一个值。**格式化字符串中的每个 %d 都与待打印变量列表中相应的 int 值匹配**。这个值可以是 `int` 类型的**变量**、`int` 类型的**常量**或其他任何值为 `int` 类型的**表达式**。<mark>作为程序员，要确保转换说明的数量与待打印值的数量相同，编译器不会捕获这类型的错误</mark>。如果没有给**转换说明**提供任何值，所以打印出的值是内存中的任意值。

你可能会抱怨编译器为何不能捕获这种明显的错误，但实际上问题出在 `printf()` 不寻常的设计。大部分函数都需要指定数目的参数，编译器会检查参数的数目是否正确。但是，**printf() 函数的参数数目不定，可以有 1 个、2 个、3 个或更多**，编译器也爱莫能助。记住，使用 `printf()` 函数时，要确保转换说明的数量与待打印值的数量相等。

#### 5. 八进制和十六进制

在 C 语言中，用特定的前缀表示使用哪种进制。0x 或 0X 前缀表示十六进制值，所以十进制数 16 表示成十六进制是 0x10 或 0X10。与此类似，0 前缀表示八进制。例如，十进制数 16 表示成八进制是 020。

要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式。也就是说，无论把数字写成 16、020 或 0x10，储存该数的方式都相同，因为计算机内部都以二进制进行编码。

#### 6. 显示八进制和十六进制

在 C 程序中，既可以使用和显示不同进制的数。**不同的进制要使用不同的转换说明**。以十进制显示数字，使用 `%d`；以八进制显示数字，使用 `%o`；以十六进制显示数字，使用 `%x`。另外，要显示各进制数的前缀 0、0x 和 0X，必须分别使用 `%#o`、`%#x`、`%#X`，即分别在转换说明中加入 `#`。

### 3.4.2 其它整数类型

C 语言提供 3 个**附属关键字**修饰基本整数类型：`short`、`long` 和 `unsigned`。

`unsigned int` 或 `unsigned` 只用于非负值的场合。这种类型与有符号类型表示的范围不同。例如，16 位 `unsigned int` 允许的取值范围是 0\~65535，而不是 -32768\~32767。用于表示正负号的位现在用于表示另一个二进制位，所以**无符号整型可以表示更大的数**。

在 C90 标准中，添加了 `unsigned long int` 或 `unsigned long` 和 `unsigned int` 或 `unsigned short` 类型。C99 标准又添加了 `unsigned long long int` 或 `unsigned long long`。

在任何有符号类型前面添加关键字 `signed`，可强调使用有符号类型的意图。例如，`short`、`short int`、`signed short`、`signed short int` 都表示同一种类型。

#### 2. 使用多种整数类型的原因

为什么说 `short` 类型“可能”比 `int` 类型占用的空间少，`long` 类型“可能”比 `int` 类型占用的空间多？因为 C 语言只规定了 `short` 占用的存储空间不能多于 `int`，`long` 占用的存储空间不能少于 `int`。这样规定是为了适应不同的机器。例如，过去的一台运行 Windows 3 的机器上，`int` 类型和 `short` 类型都占 16 位，`long` 类型占 32 位。后来，Windows 和苹果系统都使用 16 位储存 `short` 类型，32 位储存 `int` 类型和 `long` 类型（使用 32 位可以表示的整数数值超过 20 亿）。现在，计算机普遍使用 64 位处理器，为了储存 64 位的整数，才引入了 `long long` 类型。

现在，个人计算机上最常见的设置是，`long long` 占 64 位，`long` 占 32 位，`short` 占 16 位，`int` 占 16 位或 32 位（依计算机的自然字长而定）。<mark>原则上，这 4 种类型代表 4 种不同的大小，但是在实际使用中，有些类型之间通常有重叠</mark>。

<mark>标准对基本数据类型只规定了允许的最小大小</mark>。对于 16 位机，`short` 和 `int` 的最小取值范围是 [−32768, 32767]；对于 32 位机，`long` 的最小取值范围是 [−2147483648, 2147483647]。对于 `unsigned short` 和 `unsigned int`，最小取值范围是 [0, 65535]；对于 `unsigned long`，最小取值范围是 [0, 4294967295]。

`int` 类型那么多，应该如何选择？首先，考虑 `unsigned` 类型。这种类型的数常用于计数，因为计数不用负数。而且，`unsigned` 类型可以表示更大的正数。

如果一个数超出了 `int` 类型的取值范围，且在 `long` 类型的取值范围内时，使用 `long` 类型。<mark>然而，对于那些 long 占用的空间比 int 大的系统，使用 long 类型会减慢运算速度。因此，如非必要，请不要使用 long 类型</mark>。另外要注意一点：如果在 `long` 类型和 `int` 类型占用空间相同的机器上编写代码，当确实需要 32 位的整数时，应使用 `long` 类型而不是 `int` 类型，以便把程序移植到 16 位机后仍然可以正常工作。类似地，如果确实需要 64 位的整数，应使用 `long long` 类型。

如果在 `int` 设置为 32 位的系统中要使用 16 位的值，应使用 `short` 类型以节省存储空间。通常，<mark>只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题</mark>。使用 `short` 类型的另一个原因是，计算机中某些组件使用的硬件寄存器是 16 位。

#### 3. long 常量和 long long 常量

通常，程序代码中使用的数字（如，2345）都被储存为 `int` 类型。如果使用 1000000 这样的大数字，超出了 `int` 类型能表示的范围，编译器会将其视为 `long int` 类型（假设这种类型可以表示该数字）。如果数字超出 `long` 可表示的最大值，编译器则将其视为 `unsigned long` 类型。如果还不够大，编译器则将其视为 `long long` 或 `unsigned long long` 类型（前提是编译器能识别这些类型）。八进制和十六进制常量被视为 `int` 类型。如果值太大，编译器会尝试使用 `unsigned int`。如果还不够大，编译器会依次使用 `long`、`unsigned long`、`long long` 和 `unsigned long long` 类型。

有些情况下，需要编译器以 `long` 类型储存一个小数字。例如，编程时要显式使用 IBM PC 上的内存地址时。另外，一些 C 标准函数也要求使用 `long` 类型的值。要把一个较小的常量作为 `long` 类型对待，可以在值的末尾加上 `l`（小写的 `L`）或 `L` 后缀。使用 `L` 后缀更好，因为 `l` 看上去和数字 1 很像。因此，在 `int` 为 16 位、`long` 为 32 位的系统中，会把 `7` 作为 16 位储存，把 `7L` 作为 32 位储存。`l` 或 `L` 后缀也可用于八进制和十六进制整数，如 `020L` 和 `0x10L`。类似地，在支持 `long long` 类型的系统中，也可以使用 `ll` 或 `LL` 后缀来表示 `long long` 类型的值，如 `3LL`。另外，`u` 或 `U` 后缀表示 `unsigned long long`，如 `5ull`、`10LLU`、`6LLU` 或 `9Ull`。

##### 整数溢出

如果整数超出了相应类型的取值范围会怎样？在超过最大值时，`unsigned int` 类型的变量从 0 开始；而 `int` 类型的变量则从 −2147483648 开始。<mark>注意，当变量超出（溢出）其相应类型所能表示的最大值时，系统并未通知用户</mark>。因此，在编程时必须自己注意这类问题。

<mark>溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则</mark>。以上描述的溢出行为比较有代表性，但是也可能会出现其他情况〔取决于机器内部二进制表示形式是原码、补码还是反码之类的〕。

#### 4. 打印 short、long、long long 和 unsigned 类型

- 打印 `unsigned int` 类型的值，使用 `%u` 转换说明；
- 打印 `long` 类型的值，使用 `%ld` 转换说明；
- 如果系统中 `int` 和 `long` 的大小相同，使用 `%d` 就行。但是，这样的程序被移植到其他系统（`int` 和 `long` 类型的大小不同）中会无法正常工作。
- 在 `x` 和 `o` 前面可以使用 `l` 前缀，`%lx` 表示以十六进制格式打印 `long` 类型整数，`%lo` 表示以八进制格式打印 `long` 类型整数。

<mark>注意，虽然 C 允许使用大写或小写的常量后缀，但是在转换说明中只能用小写</mark>。

C 语言有多种 `printf()` 格式。

- 对于 `short` 类型，可以使用 `h` 前缀；
- `%hd` 表示以十进制显示 `short` 类型的整数；
- `%ho` 表示以八进制显示 `short` 类型的整数。
- `h` 和 `l` 前缀都可以和 `u` 一起使用，用于表示无符号类型。例如，`%lu` 表示打印 `unsigned long` 类型的值。
- 对于支持 `long long` 类型的系统，`%lld` 和 `%llu` 分别表示有符号和无符号类型。

使用错误的转换说明会得到意想不到的结果（溢出）。在待打印的值大于有符号值的最大值时，如果告诉 `printf()` 该数是无符号数，它打印一个值；如果告诉它该数是有符号数，它将打印另一个值。对于较小的正数（如 96），有符号和无符号类型的存储、显示都相同。

对于 `short` 类型的变量 `end`，在 `printf()` 中无论指定以 `short` 类型（`%hd`）还是 `int` 类型（`%d`）打印，打印出来的值都相同。这是因为在给函数传递参数时，C 编译器把 `short` 类型的值自动转换成 `int` 类型的值。你可能会提出疑问：为什么要进行转换？<mark> int 类型被认为是计算机处理整数类型时最高效的类型</mark>。因此，在 `short` 和 `int` 类型的大小不同的计算机中，用 `int` 类型的参数传递速度更快。`h` 修饰符有什么用？使用 `h` 修饰符可以显示较大整数被截断成 `short` 类型值的情况。例如，把 65537 以二进制格式写成一个 32 位数是 00000000000000010000000000000001。使用`%hd`，`printf()` 只会查看后 16 位，所以显示的值是 1。

<mark>在使用 `printf()` 函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配</mark>。

### 3.4.3 使用字符：char 类型

`char` 类型用于**储存字符**（如，**字母**或**标点符号**），但是从技术层面看，`char` 是整数类型。因为 **char 类型实际上储存的是整数而不是字符**。计算机使用**数字编码**来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是 `ASCII 编码`，本书也使用此编码。例如，在 ASCII 码中，整数 65 代表大写字母 A。因此，储存字母 A 实际上储存的是整数 65（许多 IBM 的大型主机使用另一种编码——EBCDIC，其原理相同。另外，其他国家的计算机系统可能使用完全不同的编码）。

**标准 ASCII 码的范围是 0~127，只需 7 位二进制数即可表示**。**通常，char 类型被定义为 8 位的存储单元**，因此容纳标准 ASCII 码绰绰有余。许多其他系统（如 IMB PC 和苹果 Macs）还提供**扩展 ASCII 码**，也在 8 位的表示范围之内。一般而言，C 语言会保证 `char` 类型足够大，以储存系统（实现 C 语言的系统）的基本字符集。

许多字符集都超过了 127，甚至多于 255。例如，日本汉字（kanji）字符集。**商用的统一码**（**Unicode**）创建了一个能表示世界范围内多种字符集的系统，目前包含的字符已超过 110000 个。国际标准化组织（ISO）和国际电工技术委员会（IEC）为字符集开发了 ISO/IEC 10646 标准。统一码标准也与 ISO/IEC 10646 标准兼容。

**C 语言把 1 字节定义为 char 类型占用的位（bit）数**，因此无论是 16 位还是 32 位系统，都可以使用 `char` 类型。

#### 2. 字符常量和初始化

如果要把一个字符常量初始化为字母 `A`，不必背下 ASCII 码，用计算机语言很容易做到。通过以下初始化把字母 `A` 赋给 `grade` 即可：

```c
char grade = 'A';
```

在 C 语言中，用单引号括起来的单个字符被称为**字符常量**（character constant）。编译器一发现 `'A'`，就会将其转换成相应的代码值。单引号必不可少。

实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值：

```c
char grade = 65; // 对于 ASCII，这样做没问题。但这是一种不好的变成风格
```

在本例中，虽然 `65` 是 `int` 类型，但是它在 `char` 类型能表示的范围内，所以将其赋值给 `grade` 没问题。由于 `65` 是字母 `A` 对应的 ASCII 码，因此本例是把 `A` 赋给 `grade`。注意，能这样做的前提是系统使用 ASCII 码。其实，用 `'A'`代替 `65` 才是较为妥当的做法，这样在任何系统中都不会出问题。<mark>因此，最好使用字符常量，而不是数字代码值</mark>。

<mark>奇怪的是，C 语言将字符常量视为 int 类型而非 char 类型</mark>。例如，在 `int` 为 32 位、`char` 为 8 位的 ASCII 系统中，有下面的代码：

```c
char grade = 'B';
```

本来 `'B'` 对应的数值 `66` 储存在 32 位的存储单元中，现在却可以储存在 8 位的存储单元中（`grade`）。利用字符常量的这种特性，可以定义一个字符常量 `'FATE'`，即把 4 个独立的 8 位 ASCII 码储存在一个 32 位存储单元中。如果把这样的字符常量赋给 `char` 类型变量 `grade`，只有最后 8 位有效。因此，`grade` 的值是 `'E'`。

#### 3. 非打印字符

**单引号只适用于字符、数字和标点符号**，浏览 ASCII 表会发现，有些 ASCII 字符打印不出来。例如，一些代表行为的字符（如，**退格**、**换行**、**终端响铃**或**蜂鸣**）。C 语言提供了 3 种方法表示这些字符。

第 1 种方法前面介绍过——使用 ASCII 码。例如，蜂鸣字符的 ASCII 值是 `7`，因此可以这样写：

```c
char beep = 7;
```

第 2 种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作**转义序列**（escape sequence）。表 3.2 列出了转义序列及其含义。<mark>把转义序列赋给字符变量时，必须用单引号把转义序列括起来</mark>。例如：

```c
char nerf = '\n';
```

<div align=center>
<img width="80%" src="\programme\C_C++\C_primer_plus\image\转义序列.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 3.2 转义序列</div>
</div>

现在，我们来仔细分析一下转义序列。使用 C90 新增的警报字符（`\a`）是否能产生听到或看到的警报，取决于计算机的硬件，**蜂鸣**是最常见的警报（在一些系统中，警报字符不起作用）。**C 标准规定警报字符不得改变活跃位置**。标准中的**活跃位置**（active position）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，**平时常说的屏幕光标位置就是活跃位置**。在程序中把警报字符输出在屏幕上的效果是，发出一声蜂鸣，但不会移动屏幕光标。

接下来的转义字符 `\b`、`\f`、`\n`、`\r`、`\t` 和 `\v` 是常用的输出设备控制字符。了解它们最好的方式是查看它们对活跃位置的影响。

- 换页符（`\f`）把活跃位置移至下一页的开始处；
- 换行符（`\n`）把活跃位置移至下一行的开始处；
- 回车符（`\r`）把活跃位置移动到当前行的开始处；
- 水平制表符（`\t`）将活跃位置移至下一个水平制表点（通常是第 1 个、第 9 个、第 17 个、第 25 个等字符位置）；
- 垂直制表符（`\v`）把活跃位置移至下一个垂直制表点。
- 退格符(`\b`)通常不会擦除退回所经过的字符。

<mark>这些转义序列字符不一定在所有的显示设备上都起作用</mark>。例如，换页符和垂直制表符在 PC 屏幕上会生成奇怪的符号，光标并不会移动。只有将其输出到打印机上时才会产生前面描述的效果。

接下来的 3 个转义序列（`\\`、`\'`、`\"`）用于打印 `\`、`'`、`"` 字符（由于这些字符用于定义字符常量，是 `printf()` 函数的一部分，若直接使用它们会造成混乱）。例如：

```c
printf("Gramps sez, \"a \\ ia a backslash.\"\n")
```

运行：

```c
Gramps sez, "a \ is a backslash."
```

表 3.2 中的最后两个转义序列（`\0oo` 和 `\xhh`）是 ASCII 码的特殊表示。如果要用**八进制** ASCII 码表示一个字符，可以在编码值前面加一个反斜杠（`\`）并用单引号括起来。例如，如果编译器不识别警报字符（`\a`），可以使用 ASCII 码来代替：

```c
beep = '\007';
```

可以省略前面的 0，`'\07'` 甚至 `'\7'` 都可以。即使没有前缀 0，编译器在处理这种写法时，仍会解释为八进制。

从 C90 开始，不仅可以用十进制、八进制形式表示字符常量，C 语言还提供了第 3 种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个 `x` 或 `X`，再加上 1~3 位十六进制数字。例如，**Ctrl+P** 字符的 ASCII 十六进制码是 10（相当于十进制的 16），可表示为 `'\x10'` 或`'\x010'`。图 3.5 列出了一些整数类型的不同进制形式。

<div align=center>
<img width="50%" src="\programme\C_C++\C_primer_plus\image\int类型的常量写法示例.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 图 3.5 int 类型的常量写法示例</div>
</div>

<mark>使用 ASCII 码时，注意数字和数字字符的区别</mark>。例如，字符 4 对应的 ASCII 码是 52。`'4'` 表示字符 4，而不是数值 4。

关于转义序列，读者可能有下面 3 个问题。

- 上面最后一个例子（`printf("Gramps sez, \"a \\ is a backslash\"\"n"`），为何没有用单引号把转义序列括起来？<mark>无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来</mark>。双引号中的字符集合叫作**字符串**（详见第 4 章）。注意，该例中的其他字符（`G`、`r`、`a`、`m`、`p`、`s` 等）都没有用单引号括起来。与此类似，`printf("Hello!\007\n");` 将打印 `Hello!` 并发出一声蜂鸣，而` printf("Hello!7\n");` 则打印 `Hello!7`。<mark>不是转义序列中的数字将作为普通字符被打印出来</mark>。
- 何时使用 ASCII 码？何时使用转义序列？如果要在转义序列（假设使用 `'\f'`）和 ASCII 码（`'\014'`）之间选择，请选择前者（即 `'\f'`）。这样的写法不仅更好记，而且可移植性更高。`'\f'` 在不使用 ASCII 码的系统中，仍然有效。
- 如果要使用 ASCII 码，为何要写成 `'\032'` 而不是 `032`？首先，`'\032'` 能更清晰地表达程序员使用字符编码的意图。其次，类似 `\032` 这样的转义序列可以嵌入 C 的字符串中，如 `printf("Hello!\007\n");` 中就嵌入了 `\007`。

#### 4. 打印字符

`printf()` 函数用 `%c` 指明待打印的字符。前面介绍过，一个字符变量实际上被储存为 1 字节的整数值。因此，如果用 `%d` 转换说明打印 `char` 类型变量的值，打印的是一个整数。而 `%c` 转换说明告诉 `printf()` 打印该整数值对应的字符。

```c
char ch;
scanf("%c", &ch);
```

运行该程序时，在输入字母后不要忘记按下 Enter 或 Return 键。随后，`scanf()` 函数会读取用户输入的字符，`&` 符号表示把输入的字符赋给变量 `ch`。

<div align=center>
<img width="60%" src="\programme\C_C++\C_primer_plus\image\数据显示和数据存储.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 图 3.6 数据显示和数据存储</div>
</div>

#### 5. 有符号还是无符号

有些 C 编译器把 `char` 实现为有符号类型，这意味着 `char` 可表示的范围是 -128~127。而有些 C 编译器把 `char` 实现为无符号类型，那么 `char` 可表示的范围是 0~255。请查阅相应的编译器手册，确定正在使用的编译器如何实现 `char` 类型。或者，可以查阅 `limits.h` 头文件。

根据 C90 标准，C 语言允许在关键字 `char` 前面使用 `signed` 或 `unsigned`。这样，无论编译器默认 `char` 是什么类型，`signed char` 表示有符号类型，而 `unsigned char` 表示无符号类型。这在用 `char` 类型处理**小整数**时很有用。如果只用 `char` 处理字符，那么 `char` 前面无需使用任何修饰符。

### 3.4.4 \_Bool 类型

C99 标准添加了 `_Bool` 类型，用于表示布尔值，即逻辑值 `true` 和 `false`。因为 C 语言用值 1 表示 `true`，值 0 表示 `false`，所以 **\_Bool 类型实际上也是一种整数类型**。但原则上它仅占用 1 位存储空间，因为对 0 和 1 而言，1 位的存储空间足够了。程序通过布尔值可选择执行哪部分代码。

### 3.4.5 可移植类型：stdint.h 和 inttypes.h

C 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个头文件 `stdint.h` 和 `inttypes.h`，以确保 C 语言的类型在各系统中的功能相同。

C 语言为现有类型创建了更多类型名。这些新的类型名定义在 `stdint.h` 头文件中。例如，`int32_t` 表示 32 位的有符号整数类型。在使用 32 位 `int` 的系统中，头文件会把 `int32_t` 作为 `int` 的别名。不同的系统也可以定义相同的类型名。例如，`int` 为 16 位、`long` 为 32 位的系统会把 `int32_t` 作为 `long` 的别名。然后，使用 `int32_t` 类型编写程序，并包含 `stdint.h` 头文件时，编译器会把 `int` 或 `long` 替换成与当前系统匹配的类型。

上面讨论的类型别名是**精确宽度整数类型**（exact-width integer type）的示例。`int32_t` 表示整数类型的宽度正好是 32 位。但是，计算机的底层系统可能不支持。因此，<mark>精确宽度整数类型是可选项</mark>。

如果系统不支持精确宽度整数类型怎么办？C99 和 C11 提供了第 2 类别名集合。**一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型**。这组类型集合被称为**最小宽度类型**（minimum width type）。例如，`int_least8_t` 是可容纳 8 位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是 16 位，可能不会定义 `int8_t` 类型。尽管如此，该系统仍可使用 `int_least8_t` 类型，但可能把该类型实现为 16 位的整数类型。

当然，一些程序员更关心速度而非空间。为此，C99 和 C11 定义了一组可使计算达到最快的类型集合。这组类型集合被称为**最快最小宽度类型**（fastst minimum width type）。例如，`int_fast8_t` 被定义为系统中对 8 位有符号值而言运算最快的整数类型的别名。

另外，有些程序员需要系统的最大整数类型。为此，C99 定义了最大的有符号整数类型 `intmax_t`，可储存任何有效的有符号整数值。类似地 `unitmax_t` 表示最大的无符号整数类型。顺带一提，这些类型有可能比 `long long` 和 `unsigned long` 类型更大，因为 C 编译器除了实现标准规定的类型以外，还可利用 C 语言实现其他类型。例如，一些编译器在标准引入 `long long` 类型之前，已提前实现了该类型。

C99 和 C11 不仅提供可移植的类型名，还提供相应的输入和输出。例如，`printf()` 打印特定类型时要求与相应的转换说明匹配。如果要打印 `int32_t` 类型的值，有些定义使用 `%d`，而有些定义使用 `%ld`，怎么办？C 标准针对这一情况，提供了一些**字符串宏**（第 4 章中详细介绍）来显示可移植类型。例如， `inttypes.h` 头文件中定义了 `PRId32` 字符串宏，代表打印 32 位有符号值的合适转换说明（如 `d` 或 `l`）。例如：

```c
#include <inttypes.h>

int32_t me32;
me32 = 45933945;
printf("me32 = %" PRId32 "\n", me32);
```

该程序最后一个 `printf()` 中，参数 `PRId32` 被定义在 `inttypes.h` 中的 `"d"` 替换，因而这条语句等价于：

```c
printf("me16 = %" "d" "\n", me16);
```

**在 C 语言中，可以把多个连续的字符串组合成一个字符串**，所以这条语句又等价于：

```c
printf("me16 = %d\n", me16);
```

附录 B 中的参考资料 VI“扩展的整数类型”介绍了完整的 `inttypes.h` 和 `stdint.h` 头文件。

> 注意 对 C99/C11 的支持</br>
> C 语言发展至今，虽然 ISO 已发布了 C11 标准，但是编译器供应商对 C99 的实现程度却各不相同。在本书第 6 版的编写过程中，一些编译器仍未实现 inttypes.h 头文件及其相关功能。

### 3.4.6 float、double 和 long double

各种整数类型对大多数软件开发项目而言够用了。然而，面向金融和数学的程序经常使用**浮点数**。C 语言中的浮点类型有 `float`、`double` 和 `long double` 类型。前面提到过，浮点类型能表示包括小数在内更大范围的数。浮点数的表示类似于科学记数法（即用小数乘以 10 的幂来表示数字）。该记数系统常用于表示非常大或非常小的数。指数记数法（或称为 e 记数法），这是科学记数法在计算机中的写法，e 后面的数字代表 10 的指数。

C 标准规定，`float` 类型必须至少能表示 6 位有效数字，且取值范围至少是 $10^{-37}\sim 10^{+37}$。前一项规定指 `float` 类型**必须至少精确表示小数点后的 6 位有效数字**，如 33.333333。后一项规定用于方便地表示诸如太阳质量（2.0e30 千克）、一个质子的电荷量（1.6e-19 库仑）或国家债务之类的数字。**通常，系统储存一个浮点数要占用 32 位。其中 8 位用于表示指数的值和符号，剩下 24 位用于表示非指数部分（也叫作尾数或有效数）及其符号**。

语言提供的另一种浮点类型是 `double`（意为双精度）。`double` 类型和 `float` 类型的最小取值范围相同，但**至少必须能表示 10 位有效数字**。一般情况下，`double` 占用 64 位而不是 32 位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，<mark>double 类型的值至少有 13 位有效数字</mark>，超过了标准的最低位数规定。

C 语言的第 3 种浮点类型是 `long double`，以满足比 `double` 类型更高的精度要求。不过，<mark>C 只保证 long double 类型至少与 double 类型的精度相同</mark>。

#### 2. 浮点型常量

在代码中，可以用多种形式书写浮点型常量。**浮点型常量**的基本形式是：有符号的数字（包括小数点），后面紧跟 e 或 E，最后是一个有符号数表示 10 的指数。下面是两个有效的浮点型常量：-1.56E+12，2.87e-3。

正号可以省略。可以没有小数点（如，`2E5`）或指数部分（如，`19.28`），但是不能同时省略两者。可以省略小数部分（如，`3.E16`）或整数部分（如，`.45E-6`），但是不能同时省略两者。下面是更多的有效浮点型常量示例：`3.14159`，`.2`，`4e16`，`.8E-5`，`100.`。

<mark>不要在浮点型常量中间加空格</mark>：`1.56 E+12`（错误！）

<mark>默认情况下，编译器假定浮点型常量是 double 类型的精度</mark>。例如，假设 `some` 是 `float` 类型的变量，编写下面的语句：

```c
some = 4.0 * 2.0;
```

通常，4.0 和 2.0 被储存为 64 位的 `double` 类型，使用双精度进行乘法运算，然后将乘积截断成 `float` 类型的宽度。<mark>这样做虽然计算精度更高，但是会减慢程序的运行速度</mark>。

在浮点数后面加上 `f` 或 `F` 后缀可覆盖默认设置，编译器会将浮点型常量看作 `float` 类型，如 `2.3f` 和 `9.11E9F`。使用 `l` 或 `L` 后缀使得数字成为 `long double` 类型，如 `54.3l` 和 `4.32L`。注意，建议使用 `L` 后缀，因为字母 `l` 和数字 1 很容易混淆。没有后缀的浮点型常量是 `double` 类型。

C99 标准添加了一种新的浮点型常量格式——**用十六进制表示浮点型常量**，即在十六进制数前加上十六进制前缀（`0x` 或 `0X`），用 `p` 和 `P` 分别代替 `e` 和 `E`，用 2 的幂代替 10 的幂（即，`p` 计数法）。如下所示：

```c
0xa.1fp10
```

十六进制 `a` 等于十进制 10，`.1f` 是 1/16 加上 15/256（十六进制 `f` 等于十进制 15），`p10` 是 $2^{10}$ 或 1024。`0xa.1fp10` 表示的值是 (10 + 1/16 +15/256)×1024（即，十进制 10364.0）。

注意，并非所有的编译器都支持 C99 的这一特性。

#### 3. 打印浮点值

`printf()` 函数使用 `%f` 转换说明打印十进制记数法的 `float` 和 `double` 类型浮点数，用 `%e` 打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用 `a` 和 `A` 分别代替 `e` 和 `E`。打印 `long double` 类型要使用 `%Lf`、`%Le` 或 `%La` 转换说明。给那些未在函数原型中显式说明参数类型的函数（如，`printf()`）传递参数时，C 编译器会把 `float` 类型的值自动转换成 `double` 类型。下一章将介绍如何通过**设置字段宽度**和**小数位数**来控制输出格式。

#### 4. 浮点值的上溢和下溢

假设系统的最大 `float` 类型值是 `3.4E38`，编写如下代码：

```c
float toobig = 3.4E38 * 100.0f;
printf("%e\n", toobig);
```

会发生什么？这是一个**上溢**（overflow）的示例。当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定义的，不过现在 C 语言规定，在这种情况下会给 `toobig` 赋一个表示无穷大的特定值，而且 `printf()` 显示该值为 `inf` 或 `infinity`（或者具有无穷含义的其他内容）。

当对一个很小的数做除法时，情况更为复杂。以十进制为例，把一个有 4 位有效数字的数（如，0.1234E-10）除以 10，得到的结果是 0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作**下溢**（underflow）。C 语言把损失了类型全精度的浮点值称为**低于正常的**（subnormal）浮点值。回忆一下，`float` 类型的数以指数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是 `float` 类型能用全部精度表示的最小数字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。因此，把最小的正浮点数除以 2 将得到一个**低于正常的值**。如果除以一个非常大的值，会导致所有的位都为 0。现在，C 库已提供了用于检查计算是否会产生低于正常值的函数。

还有另一个特殊的浮点值 `NaN`（not a number 的缩写）。例如，给 `asin()` 函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的值。但是正弦值不能大于 1，因此，如果传入的参数大于 1，该函数的行为是未定义的。在这种情况下，该函数将返回 `NaN` 值，`printf()` 函数可将其显示为 `nan`、`NaN` 或其他类似的内容。

##### 浮点数舍入错误

给定一个数，加上 1，再减去原来给定的数，结果是多少？你一定认为是 1。但是，下面的浮点运算给出了不同的答案：

```c
/* floaterr.c--演示舍入错误 */
#include <stdio.h>
int main(void)
{
    float a, b;
    b = 2.0e20 + 1.0;
    a = b - 2.0e20;
    printf("%f \n", a);
    return 0;
}
```

运行：

```c
4008175468544.000000
```

得出这种奇怪答案的原因是，**计算机缺少足够的小数位来完成正确的运算**。2.0e20 是 2 后面有 20 个 0。如果把该数加 1，那么发生变化的是第 21 位。要正确运算，程序至少要储存 21 位数字。<mark>而 float 类型的数字通常只能储存按指数比例缩小或放大的〔对应十进制的〕 6 或 7 位有效数字</mark>。在这种情况下，计算结果一定是错误的。另一方面，如果把 2.0e20 改成 2.0e4，计算结果就没问题。因为 2.0e4 加 1 只需改变第 5 位上的数字，`float` 类型的精度足够进行这样的计算。

##### 浮点数的表示法

上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示法开发了一套标准。现在，许多硬件浮点单元都采用该标准。2011 年，该标准被 ISO/IEC/IEEE 60559:2011 标准收录。该标准作为 C99 和 C11 的可选项，符合硬件要求的平台可开启。floaterr.c 程序的输出示例即是支持该浮点标准的系统显示的结果。支持 C 标准的编译器还包含捕获异常问题的工具。详见附录 B.5，参考资料 V。

### 3.4.7 复数和虚数类型

许多科学和工程计算都要用到复数和虚数。C99 标准支持复数类型和虚数类型，但是有所保留。一些独立实现，如嵌入式处理器的实现，就不需要使用复数和虚数（VCR 芯片就不需要复数）。<mark>一般而言，虚数类型都是可选项。C11 标准把整个复数软件包都作为可选项</mark>。

简而言之，C 语言有 3 种复数类型：`float_Complex`、`double_Complex` 和 `long double _Complex`。例如，`float _Complex` 类型的变量应包含两个 `float` 类型的值，分别表示复数的实部和虚部。类似地， C 语言的 3 种虚数类型是 `float _Imaginary`、`double _Imaginary` 和 `long double _Imaginary`。

如果包含 `complex.h` 头文件，便可用 `complex` 代替 `_Complex`，用 `imaginary` 代替 `_Imaginary`，还可以用 `I` 代替 -1 的平方根。

为何 C 标准不直接用 `complex` 作为关键字来代替 `_Complex`，而要添加一个头文件（该头文件中把 `complex` 定义为 `_Complex`）？因为标准委员会考虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部失效。例如，之前的 C99，许多程序员已经使用 `struct complex` 定义一个结构来表示复数或者心理学程序中的心理状况（关键字 `struct` 用于定义能储存多个值的结构，详见第 14 章）。让 `complex` 成为关键字会导致之前的这些代码出现语法错误。但是，使用 `struct _Complex` 的人很少，特别是标准使用首字母是下划线的标识符作为预留字以后。因此，标准委员会选定 `_Complex` 作为关键字，在不用考虑名称冲突的情况下可选择使用 `complex`。

### 3.4.8 其他类型

现在已经介绍完 C 语言的所有基本数据类型。有些人认为这些类型实在太多了，但有些人觉得还不够用。注意，虽然 C 语言没有字符串类型，但也能很好地处理字符串。第 4 章将详细介绍相关内容。

C 语言还有一些从基本类型衍生的其他类型，包括**数组**、**指针**、**结构**和**联合**。尽管后面章节中会详细介绍这些类型，但是本章的程序示例中已经用到了指针〔**指针**（pointer）指向变量或其他数据对象位置〕。例如，在 `scanf()` 函数中用到的前缀 `&`，便创建了一个指针，告诉 `scanf()` 把数据放在何处。

#### 小结：基本数据类型

##### 关键字

基本数据类型由 11 个关键字组成：`int`、`long`、`short`、`unsigned`、`char`、`float`、`double`、`signed`、`_Bool`、`_Complex` 和 `_Imaginary`。

##### 有符号整型

有符号整型可用于表示正整数和负整数。

- `int`：系统给定的基本整数类型。C 语言规定 `int` 类型不小于 16 位。
- `short` 或 `short int`：最大的 `short` 类型整数小于或等于最大的 `int` 类型整数。C 语言规定 `short` 类型至少占 16 位。
- `long` 或 `long int`：该类型可表示的整数大于或等于最大的 `int` 类型整数。C 语言规定 `long` 类型至少占 32 位。
- `long long` 或 `long long int`：该类型可表示的整数大于或等于最大的 `long` 类型整数。`long long` 类型至少占 64 位。

一般而言，`long` 类型占用的内存比 `short` 类型大，`int` 类型的宽度要么和 long 类型相同，要么和 `short` 类型相同。例如，旧 DOS 系统的 PC 提供 16 位的 `short` 和 `int`，以及 32 位的 `long`；Windows 95 系统提供 16 位的 `short` 以及 32 位的 `int` 和 `long`。

##### 无符号整型

无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。在整型类型前加上关键字 `unsigned` 表明该类型是无符号整型：`unsigned int`、`unsigned long`、`unsigned short`。单独的 `unsigned` 相当于 `unsigned int`。

##### 字符类型

可打印出来的符号（如 `A`、`&` 和 `+`）都是字符。根据定义，`char` 类型表示一个字符要占用 1 字节内存。出于历史原因，1 字节通常是 8 位，但是如果要表示基本字符集，也可以是 16 位或更大。

- `char`：字符类型的关键字。有些编译器使用有符号的 `char`，而有些则使用无符号的 `char`。在需要时，可在 `char` 前面加上关键字 `signed` 或 `unsigned` 来指明具体使用哪一种类型。

##### 布尔类型

布尔值表示 `true` 和 `false`。C 语言用 1 表示 `true`，0 表示 `false`。

- `_Bool`：布尔类型的关键字。布尔类型是无符号 `int` 类型，所占用的空间只要能储存 0 或 1 即可。

##### 实浮点类型

实浮点类型可表示正浮点数和负浮点数。

- `float`：系统的基本浮点类型，可精确表示至少 6 位有效数字。
- `double`：储存浮点数的范围（可能）更大，能表示比 `float` 类型更多的有效数字（至少 10 位，通常会更多）和更大的指数。
- `long double`：储存浮点数的范围（可能）比 `double` 更大，能表示比 `double` 更多的有效数字和更大的指数。

##### 复数和虚数浮点数

虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构成：

- `float _Complex`
- `double _Complex`
- `long double _Complex`
- `float _Imaginary`
- `double _Imaginary`
- `long long _Imaginary`

### 3.4.9 类型大小

如何知道当前系统的指定类型的大小是多少？

```c
//* typesize.c -- 打印类型大小 */
#include <stdio.h>
int main(void)
{
    /* C99为类型大小提供%zd转换说明 */
    printf("Type char has a size of %zd bytes.\n", sizeof(char));
    printf("Type int has a size of %zd bytes.\n", sizeof(int));
    printf("Type long has a size of %zd bytes.\n", sizeof(long));
    printf("Type long long has a size of %zd bytes.\n",
        sizeof(long long));
    printf("Type double has a size of %zd bytes.\n",
        sizeof(double));
    printf("Type long double has a size of %zd bytes.\n",
        sizeof(long double));
    return 0;
}
```

运行：

```c
Type char has a size of 1 bytes.
Type int has a size of 4 bytes.
Type long has a size of 4 bytes.
Type long long has a size of 8 bytes.
Type double has a size of 8 bytes.
Type long double has a size of 16 bytes.
```

`sizeof` 是 C 语言的内置运算符，以字节为单位给出指定类型的大小。C99 和 C11 提供 `%zd` 转换说明匹配 `sizeof` 的返回类型（即，`size_t` 类型）。一些不支持 C99 和 C11 的编译器可用 `%u` 或 `%lu` 代替 `%zd`。

注意，因为 C 语言定义了 `char` 类型是 1 字节，所以 `char` 类型的大小一定是 1 字节。而在 `char` 类型为 16 位、`double` 类型为 64 位的系统中，`sizeof` 给出的 `double` 是 4 字节。在 `limits.h` 和 `float.h` 头文件中有类型限制的相关信息（下一章将详细介绍这两个头文件）。

顺带一提，注意该程序最后几行 `printf()` 语句都被分为两行，**只要不在引号内部或一个单词中间断行**，就可以这样写。

## 3.5 使用数据类型

编写程序时，应注意合理选择所需的变量及其类型。通常，用 `int` 或 `float` 类型表示数字，`char` 类型表示字符。在使用变量之前必须先声明，并选择有意义的变量名。初始化变量应使用与变量类型匹配的常数类型。例如：

```c
int apples = 3; /* 正确 */
int oranges = 3.0; /* 不好的形式 */
```

与 Pascal 相比，C 在检查类型匹配方面不太严格。C 编译器甚至允许二次初始化，但在激活了较高级别警告时，会给出警告。最好不要养成这样的习惯。

<mark>把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失</mark>。例如，下面的初始化：

```c
int cost = 12.99; /* 用double类型的值初始化int类型的变量 */
float pi = 3.1415926536; /* 用double类型的值初始化float类型的变量 */
```

第 1 个声明，`cost` 的值是 12。C 编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。第 2 个声明会损失一些精度，因为 C 只保证了 `float` 类型前 6 位的精度。编译器对这样的初始化可能给出警告。

许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用 `i_` 前缀表示 `int` 类型，`us_` 前缀表示 `unsigned short` 类型。这样，一眼就能看出来 `i_smart` 是 `int` 类型的变量， `us_versmart` 是 `unsigned short` 类型的变量。

## 3.6 参数和陷阱

传递给函数的信息被称为**参数**。例如，`printf("Hello, pal.")` 函数调用有一个参数：`"Hello,pal."`。双引号中的字符序列（如，`"Hello,pal."`）被称为**字符串**（string）。现在，关键是要理解<mark>无论双引号中包含多少个字符和标点符号，一个字符串就是一个参数</mark>。

与此类似，`scanf("%d", &weight)` 函数调用有两个参数：`"%d"` 和 `&weight`。C 语言用逗号分隔函数中的参数。`printf()` 和 `scanf()` 函数与一般函数不同，它们的参数个数是可变的。程序要知道函数的参数个数才能正常工作。`printf()` 和 `scanf()` 函数用第 1 个参数表明后续有多少个参数，即**第 1 个字符串中的转换说明与后面的参数一一对应**。例如，下面的语句有两个 `%d` 转换说明，说明后面还有两个参数：

```c
printf("%d cats ate %d cans of tuna\n", cats, cans);
```

程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配。现在，C 语言通过**函数原型机制**检查函数调用时参数的个数和类型是否正确。但是，该机制对 `printf()` 和 `scanf()` 不起作用，因为这两个函数的参数个数可变。如果参数在匹配上有问题，会出现什么情况？注意，<mark>用 %d 显示 float 类型的值，其值不会被转换成 int 类型</mark>。在不同的平台下，缺少参数或参数类型不匹配导致的结果不同。

所有编译器都能顺利编译并运行该程序，但其中大部分会给出警告。的确，有些编译器会捕获到这类问题，然而 C 标准对此未作要求。因此，计算机在运行时可能不会捕获这类错误。如果程序正常运行，很难觉察出来。如果程序没有打印出期望值或打印出意想不到的值，你才会检查 `printf()` 函数中的参数个数和类型是否得当。

## 3.7 转义序列示例

### 3.7.2 刷新输出

`printf()` 何时把输出发送到屏幕上？最初，`printf()` 语句把输出发送到一个叫作**缓冲区**（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。C 标准明确规定了何时把缓冲区中的内容发送到屏幕：**当缓冲区满**、**遇到换行字符**或**需要输入的时候**（**从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区**）。例如，前两个 `printf()` 语句既没有填满缓冲区，也没有换行符，但是下一条 `scanf()` 语句要求用户输入，这迫使 `printf()` 的输出被发送到屏幕上。

旧式编译器遇到 `scanf()` 也不会强行刷新缓冲区，程序会停在那里不显示任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新缓冲区。代码应改为：

```c
printf("Enter your desired monthly salary:\n");
scanf("%f", &salary);
```

无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新缓冲区的方法是使用 `fflush()` 函数，详见第 13 章。

## 3.8 关键概念

C 语言提供了大量的数值类型，目的是为程序员提供方便。以整数类型为例，C 认为一种整型不够，提供了**有符号**、**无符号**，以及大小不同的整型，以满足不同程序的需求。

计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别。即使两个 32 位存储单元储存的位组合完全相同，但是一个解释为 `float` 类型，另一个解释为 `long` 类型，这两个相同的位组合表示的值也完全不同。例如，在 PC 中，假设一个位组合表示 `float` 类型的数 256.0，如果将其解释为 `long` 类型，得到的值是 113246208。C 语言允许编写混合数据类型的表达式，但是会进行自动类型转换，以便在实际运算时统一使用一种类型。

计算机在内存中用数值编码来表示字符。美国最常用的是 ASCII 码，除此之外 C 也支持其他编码。字符常量是计算机系统使用的数值编码的符号表示，它表示为单引号括起来的字符，如 `'A'`。

## 3.9 本章小结

C 有多种的数据类型。基本数据类型分为两大类：**整数类型**和**浮点数类型**。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是 `char`，因实现不同，可以是有符号的 `char` 或无符号的 `char`，即 `unsigned char` 或 `signed char`。但是，通常用 `char` 类型表示小整数时才这样显示说明。其他整数类型有 `short`、`int`、`long` 和 `long long` 类型。C 规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用 `unsigned` 关键字创建相应的无符号类型：`unsigned short`、`unsigned int`、`unsigned long` 和 `unsigned long long`。或者，在类型名前加上 `signed` 修饰符显式表明该类型是有符号类型。最后，`_Bool` 类型是一种无符号类型，可储存 0 或 1，分别代表 `false` 和 `true`。

浮点类型有 3 种：`float`、`double` 和 C90 新增的 `long double`。后面的类型应大于或等于前面的类型。有些实现可选择支持复数类型和虚数类型，通过关键字 `_Complex` 和 `_Imaginary` 与浮点类型的关键字组合（如，`double _Complex` 类型和 `float _Imaginary` 类型）来表示这些类型。整数可以表示为十进制、八进制或十六进制。0 前缀表示八进制数，`0x` 或 `0X` 前缀表示十六进制数。例如，32、040、0x20 分别以十进制、八进制、十六进制表示同一个值。`l` 或 `L` 前缀表明该值是 `long` 类型， `ll` 或 `LL` 前缀表明该值是 `long long` 类型。

在 C 语言中，直接表示一个字符常量的方法是：把该字符用单引号括起来，如 `'Q'`、`'8'` 和 `'$'`。C 语言的转义序列（如，`'\n'`）表示某些非打印字符。另外，还可以在八进制或十六进制数前加上一个反斜杠（如，`'\007'`），表示 ASCII 码中的一个字符。

浮点数可写成固定小数点的形式（如，9393.912）或指数形式（如，7.38E10）。C99 和 C11 提供了第 3 种指数表示法，即用十六进制数和 2 的幂来表示（如，`0xa.1fp10`）。

`printf()` 函数根据转换说明打印各种类型的值。转换说明最简单的形式由一个百分号（`%`）和一个转换字符组成，如 `%d` 或 `%f`。
