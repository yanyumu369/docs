本章介绍以下内容：

- 关键字：`while`、`typedef`
- 运算符：`=`、`-`、`*`、`/`、`%`、`++`、`--`、(类型名)
- C 语言的各种运算符，包括用于普通数学运算的运算符
- **运算符优先级**以及**语句**、**表达式**的含义
- `while` 循环
- **复合语句**、**自动类型转换**和**强制类型转换**
- 如何编写带有参数的函数

现在，读者已经熟悉了**如何表示数据**，接下来我们学习**如何处理数据**。C 语言为处理数据提供了大量的操作，可以在程序中进行**算术运算**、**比较值的大小**、**修改变量**、**逻辑地组合关系**等。我们先从基本的**算术运算**（加、减、乘、除）开始。

**组织程序**是处理数据的另一个方面，让程序按正确的顺序执行各个步骤。C 有许多语言特性，帮助你完成组织程序的任务。**循环**就是其中一个特性，本章中你将窥其大概。循环能重复执行行为，让程序更有趣、更强大。

## 5.1 循环简介

C 提供多种方法做重复计算，我们在这里简单介绍一种—`while` 循环。程序清单 5.2 演示了用循环改进后的程序。

```c
// 程序清单5.2 shoes2.c程序
/* shoes2.c -- 计算多个不同鞋码对应的脚长 */
#include <stdio.h>
#define ADJUST 7.31 // 字符常量
int main(void)
{
    const double SCALE = 0.333;// const变量
    double shoe, foot;

    printf("Shoe size (men's) foot length\n");
    shoe = 3.0;
    while (shoe < 18.5) /* while循环开始 */
    { /* 块开始 */
        foot = SCALE * shoe + ADJUST;
        printf("%10.1f %15.2f inches\n", shoe, foot);
        shoe = shoe + 1.0;
    } /* 块结束 */
    printf("If the shoe fits, wear it.\n");

    return 0;
}
```

运行：

```c
Shoe size (men's) foot length
       3.0            8.31 inches
       4.0            8.64 inches
       5.0            8.97 inches
       6.0            9.31 inches
       7.0            9.64 inches
       8.0            9.97 inches
       9.0           10.31 inches
      10.0           10.64 inches
      11.0           10.97 inches
      12.0           11.31 inches
      13.0           11.64 inches
      14.0           11.97 inches
      15.0           12.30 inches
      16.0           12.64 inches
      17.0           12.97 inches
      18.0           13.30 inches
If the shoe fits, wear it.
```

- 该程序演示了用 `#define` 指令创建符号常量和用 `const` 限定符创建在程序运行过程中不可更改的变量。
- 如果读者对此颇有研究，应该知道该程序不符合实际情况。程序中假定了一个统一的鞋码系统。
- 当程序第 1 次到达 `while` 循环时，会检查圆括号中的条件是否为真。
- 程序返回 `while` 入口部分检查条件。为何要返回 `while` 的入口部分？因为上面这条语句的下面是右花括号（`}`），代码使用一对花括号（`{}`）来标出 `while` 循环的范围。**花括号**之间的内容就是要被重复执行的内容。花括号以及被花括号括起来的部分被称为**块**（block）。
- 可以很方便地修改该程序用于其他转换。例如，把 `SCALE` 设置成 `1.8`、`ADJUST` 设置成 `32.0`，该程序便可把摄氏温度转换成华氏温度；把 `SCALE` 设置成 `0.6214`、`ADJUST` 设置成 `0`，该程序便可把公里转换成英里。注意，修改了设置后，还要更改打印的消息，以免前后表述不一。

## 5.2 基本运算符

C 用运算符（operator）表示**算术运算**。例如，`+` 运算符使在它两侧的值加在一起。现在，我们介绍一下用于基本算术运算的运算符：`=`、`+`、`-`、`*` 和 `/`（C 没有指数运算符。不过，C 的标准数学库提供了一个 `pow()` 函数用于指数运算。例如，`pow(3.5,2.2)` 返回 `3.5` 的 `2.2` 次幂）。

在 C 语言中，`=` 并不意味着“相等”，而是一个**赋值运算符**。下面的**赋值表达式语句**：

```c
bmw = 2002;
```

把值 `2002` 赋给变量 `bmw`。也就是说，`=` 号左侧是一个变量名，右侧是赋给该变量的值。符号 `=` 被称为**赋值运算符**。另外，上面的语句不读作“`bmw` 等于 `2002`”，而读作“把值 `2002` 赋给变量 `bmw`”。**赋值行为从右往左进行**。

也许变量名和变量值的区别看上去微乎其微，但是，考虑下面这条常用的语句：

```c
i = i + 1;
```

对数学而言，这完全行不通。如果给一个有限的数加上 `1`，它不可能“等于”原来的数。但是，在计算机赋值表达式语句中，这很合理。该语句的意思是：找出变量 `i` 的值，把该值加 `1`，然后把新值赋值变量 `i`。

在 C 语言中，类似这样的语句没有意义（实际上是无效的）：

```c
2002 = bmw;
```

因为在这种情况下，`2002` 被称为**右值**（rvalue），只能是**字面常量**。**不能给常量赋值，常量本身就是它的值**。因此，在编写代码时要记住，`=` 号左侧的项必须是一个**变量名**。实际上，<mark>赋值运算符左侧必须引用一个存储位置</mark>。最简单的方法就是使用变量名。不过，后面章节还会介绍“指针”，可用于指向一个存储位置。概括地说，C 使用**可修改的左值**（modifiable lvalue）标记那些可赋值的实体。

##### 几个术语：数据对象、左值、右值和运算符

**赋值表达式语句的目的是把值储存到内存位置上**。用于储存值的数据存储区域统称为**数据对象**（data object）。<mark>C 标准只有在提到这个概念时才会用到对象这个术语</mark>。使用变量名是标识对象的一种方法。除此之外，还有其他方法，但是要在后面的章节中才学到。例如，可以**指定数组的元素**、**结构的成员**，或者使用**指针表达式**（指针中储存的是它所指向对象的地址）。**左值**（lvalue）是 C 语言的术语，用于标识特定数据对象的名称或表达式。因此，**对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签**。

对于早期的 C 语言，提到左值意味着：

1. 它指定一个对象，所以引用内存中的地址；
2. 它可用在赋值运算符的左侧，左值（lvalue）中的 l 源自 left。

但是后来，标准中新增了 `const` 限定符。用 `const` 创建的变量不可修改。因此，`const` 标识符满足上面的第 1 项，但是不满足第 2 项。一方面 C 继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧。

为此，C 标准新增了一个术语：**可修改的左值**（modifiable lvalue），用于标识可修改的对象。所以，赋值运算符的左侧应该是可修改的左值。当前标准建议，使用术语**对象定位值**（object locator value）更好。

**右值**（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。例如，考虑下面的语句：

```c
bmw = 2002;
```

这里，`bmw` 是可修改的左值，`2002` 是右值。读者也许猜到了，右值中的 r 源自 right。右值可以是**常量**、**变量**或其他**可求值的表达式**（如，**函数调用**）。实际上，当前标准在描述这一概念时使用的是**表达式的值**（value ofan expression），而不是右值。

我们看几个简单的示例：

```c
int ex;
int why;
int zee;
const int TWO = 2;
why = 42;
zee = why;
ex = TWO * (why + zee);
```

这里，`ex`、`why` 和 `zee` 都是可修改的左值（或对象定位值），它们可用于赋值运算符的左侧和右侧。`TWO` 是不可改变的左值，它只能用于赋值运算符的右侧（在该例中，`TWO` 被初始化为 `2`，这里的 `=` 运算符表示**初始化**而不是赋值，因此并未违反规则）。同时，`42` 是右值，它不能引用某指定内存位置。另外，`why` 和 `zee` 是可修改的左值，表达式 `(why + zee)` 是右值，该表达式不能表示特定内存位置，而且也不能给它赋值。它只是程序计算的一个临时值，在计算完毕后便会被丢弃。

在学习名称时，被称为“项”（如，赋值运算符左侧的项）的就是**运算对象**（operand）。**运算对象是运算符操作的对象**。例如，可以把吃汉堡描述为：“吃”运算符操作“汉堡”运算对象。类似地可以说，`=` 运算符的左侧运算对象应该是可修改的左值。

C 的基本赋值运算符有些与众不同，请看程序清单 5.3。

```c
// 程序清单5.3 golf.c程序
/* golf.c -- 高尔夫锦标赛记分卡 */
#include <stdio.h>
int main(void)
{
    int jane, tarzan, cheeta;

    cheeta = tarzan = jane = 68;
    printf("                  cheeta   tarzan    jane\n");
    printf("First round score %4d %8d %8d\n", cheeta, tarzan, jane);

    return 0;
}
```

运行：

```c
                  cheeta   tarzan    jane
First round score   68       68       68
```

许多其他语言都会回避该程序中的**三重赋值**，但是 C 完全没问题。赋值的顺序是从右往左：首先把 `86` 赋给 `jane`，然后再赋给 `tarzan`，最后赋给 `cheeta`。

### 5.2.2 加法运算符：+

**加法运算符**（addition operator）用于加法运算，使其两侧的值相加。

相加的值（运算对象）可以是变量，也可以是常量。

### 5.2.3 减法运算符：-

**减法运算符**（subtraction operator）用于减法运算，使其左侧的数减去右侧的数。

`+` 和 `-` 运算符都被称为**二元运算符**（binary operator），即这些运算符需要两个运算对象才能完成操作。

### 5.2.4 符号运算符：- 和 +

**减号**还可用于标明或改变一个值的代数符号。例如，

```c
rocky = –12;
smokey = –rocky;
```

执行上面的语句后，`smokey` 的值为 `12`。以这种方式使用的负号被称为**一元运算符**（unary operator）。一元运算符只需要一个运算对象。C90 标准新增了一元 `+` 运算符，它不会改变运算对象的值或符号，只能这样使用：

```c
dozen = +12;
```

编译器不会报错。但是在以前，这样做是不允许的。

### 5.2.5 乘法运算符：\*

符号 `*` 表示**乘法**。

C 没有平方函数，如果要打印一个平方表，可以使用乘法来计算平方。

### 5.2.6 除法运算符：/

C 使用符号 `/` 来表示除法。`/` 左侧的值是**被除数**，右侧的值是**除数**。

例如，下面 `four` 的值是 `4.0`：

```c
four = 12.0/3.0;
```

整数除法和浮点数除法不同。<mark>浮点数除法的结果是浮点数，而整数除法的结果是整数</mark>。整数是没有小数部分的数。这使得 5 除以 3 很让人头痛，因为实际结果有小数部分。在 C 语言中，整数除法结果的小数部分被丢弃，这一过程被称为**截断**（truncation）。

```c
printf("mixed division: 7./4 is %1.2f \n", 7. / 4);
```

运行：

```c
mixed division: 7./4 is 1.75
```

上面是一个“混合类型”的示例，即浮点值除以整型值。C 相对其他一些语言而言，在类型管理上比较宽容。尽管如此，一般情况下还是要避免使用混合类型。

注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果。混合整数和浮点数计算的结果是浮点数。实际上，<mark>计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型</mark>。本例中，在进行除法运算前，整数会被转换成浮点数。

C99 标准以前，C 语言给语言的实现者留有一些空间，让他们来决定如何进行**负数的整数除法**。一种方法是，舍入过程采用小于或等于浮点数的最大整数。当然，对于 3.8 而言，处理后的 3 符合这一描述。但是 -3.8 会怎样？该方法建议四舍五入为 -4，因为 -4 小于 -3.8。但是，另一种舍入方法是直接丢弃小数部分。这种方法被称为“**趋零截断**”，即把 -3.8 转换成 -3。在 C99 以前，不同的实现采用不同的方法。<mark>但是 C99 规定使用趋零截断</mark>。所以，应把 -3.8 转换成 -3。

### 5.2.7 运算符优先级

显然，执行各种操作的顺序很重要。C 语言对此有明确的规定，通过**运算符优先级**来解决操作顺序的问题。**每个运算符都有自己的优先级**。正如普通的算术运算那样，乘法和除法的优先级比加法和减法高，所以先执行乘法和除法。<mark>如果两个运算符的优先级相同怎么办？如果它们处理同一个运算对象，则根据它们在语句中出现的顺序来执行</mark>。对大多数运算符而言，这种情况都是按**从左到右**的顺序进行（`=` 运算符除外）。

许多人喜欢用**表达式树**（expression tree）来表示求值的顺序，如图 5.3 所示。该图演示了如何从最初的表达式逐步简化为一个值。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\表达式树.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 图 5.3 用表达式树演示运算符、运算对象和求值顺序
</div>
</div>

表 5.1 总结了到目前为止学过的运算符优先级。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\运算符优先级.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 5.1 运算符优先级（从低至高）
</div>
</div>

注意正号（加号）和负号（减号）的两种不同用法。结合律栏列出了运算符如何与运算对象结合。例如，一元负号与它右侧的量相结合，在除法中用除号左侧的运算对象除以右侧的运算对象。

### 5.2.8 优先级和求值顺序

运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句：

```c
y = 6 * 12 + 5 * 20;
```

当运算符共享一个运算对象时，优先级决定了求值顺序。例如上面的语句中，`12` 是 `*` 和 `+` 运算符的运算对象。根据运算符的优先级，乘法的优先级比加法高，所以先进行乘法运算。类似地，先对 `5` 进行乘法运算而不是加法运算。简而言之，先进行两个乘法运算 `6 * 12` 和 `5 * 20`，再进行加法运算。<mark>但是，优先级并未规定到底先进行哪一个乘法</mark>。C 语言把主动权留给语言的实现者，根据不同的硬件来决定先计算前者还是后者。可能在一种硬件上采用某种方案效率更高，而在另一种硬件上采用另一种方案效率更高。无论采用哪种方案，表达式都会简化为 `72 + 100`，所以这并不影响最终的结果。但是，读者可能会根据乘法从左往右的结合律，认为应该先执行 `+` 运算符左边的乘法。<mark>结合律只适用于共享同一运算对象运算符</mark>。例如，在表达式`12 / 3 *2` 中，`/` 和 `*` 运算符的优先级相同，共享运算对象 `3`。因此，从左往右的结合律在这种情况起作用。表达式简化为 `4 * 2`，即 `8`（如果从右往左计算，会得到 `12/6`，即 `2`，这种情况下计算的先后顺序会影响最终的计算结果）。在该例中，两个 `*` 运算符并没有共享同一个运算对象，因此从左往右的结合律不适用于这种情况。

## 5.3 其他运算符

C 语言有大约 40 个运算符，有些运算符比其他运算符常用得多。前面讨论的是最常用的，本节再介绍 4 个比较有用的运算符。

### 5.3.1 sizeof 运算符和 size_t 类型

`sizeof` 运算符以字节为单位返回运算对象的大小（在 C 中，1 字节定义为 `char` 类型占用的空间大小。过去，1 字节通常是 8 位，但是一些字符集可能使用更大的字节）。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，`float`），则必须用圆括号将其括起来。

```c
// 程序清单5.8 sizeof.c程序
// sizeof.c -- 使用sizeof运算符
// 使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu
#include <stdio.h>
int main(void)
{
    int n = 0;
    size_t intsize;

    intsize = sizeof (int);
    printf("n = %d, n has %zd bytes; all ints have %zd bytes.\n",
            n, sizeof n, intsize);

    return 0;
}
```

运行：

```c
n = 0, n has 4 bytes; all ints have 4 bytes.
```

C 语言规定，`sizeof` 返回 `size_t` 类型的值。这是一个**无符号整数类型**，但它不是新类型。前面介绍过，`size_t` 是语言定义的标准类型。C 有一个 `typedef` 机制（第 14 章再详细介绍），**允许程序员为现有类型创建别名**。例如，

```c
typedef double real;
```

这样，`real` 就是 `double` 的别名。现在，可以声明一个 `real` 类型的变量：

```c
real deal; // 使用typedef
```

编译器查看 `real` 时会发现，在 `typedef` 声明中 `real` 已成为 `double` 的别名，于是把 `deal` 创建为 `double` 类型的变量。类似地，C 头文件系统可以使用 `typedef` 把 `size_t` 作为 `unsigned int` 或 `unsigned long` 的别名。这样，在使用 `size_t` 类型时，编译器会根据不同的系统替换标准类型。

C99 做了进一步调整，新增了 `%zd` 转换说明用于 `printf()` 显示 `size_t` 类型的值。如果系统不支持 `%zd`，可使用 `%u` 或 `%lu` 代替 `%zd`。

### 5.3.2 求模运算符：%

**求模运算符**（modulus operator）用于**整数运算**。求模运算符给出其左侧整数除以右侧整数的**余数**（remainder）。例如，`13 % 5`（读作“13 求模 5”）得 3，因为 13 比 5 的两倍多 3，即 13 除以 5 的余数是 3。<mark>求模运算符只能用于整数，不能用于浮点数</mark>。

求模运算符常用于控制程序流。例如，假设你正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用。这种情况可以在程序中对月份求模 3（即，`month % 3`），并检查结果是否为 0。如果为 0，便加进额外的费用。

负数求模如何进行？C99 规定“**趋零截断**”之前，该问题的处理方法很多。但自从有了这条规则之后，<mark>如果第 1 个运算对象是负数，那么求模的结果为负数；如果第 1 个运算对象是正数，那么求模的结果也是正数</mark>：

```c
11 / 5 得 2，11 % 5 得 1
11 / -5 得 -2，11 % -2 得 1
-11 / -5 得 2，-11 % -5 得 -1
-11 / 5 得 -2，-11 % 5 得 -1
```

如果当前系统不支持 C99 标准，会显示不同的结果。实际上，标准规定：无论何种情况，只要 `a` 和 `b` 都是整数值，便可通过 `a - (a/b)*b` 来计算 `a%b`。例如，可以这样计算 `-11%5`：

```c
-11 - (-11/5) * 5 = -11 -(-2)*5 = -11 -(-10) = -1
```

### 5.3.3 递增运算符：++

**递增运算符**（increment operator）执行简单的任务，将其运算对象递增 1。该运算符以两种方式出现。第 1 种方式，`++` 出现在其作用的变量前面，这是**前缀模式**；第 2 种方式，`++` 出现在其作用的变量后面，这是**后缀模式**。两种模式的区别在于递增行为发生的时间不同。我们先解释它们的相似之处，再分析它们不同之处。程序清单 5.10 中的程序示例演示了递增运算符是如何工作的。

```c
// 程序清单5.10 add_one.c程序
/* add_one.c -- 递增：前缀和后缀 */
#include <stdio.h>
int main(void)
{
    int ultra = 0, super = 0;

    while (super < 5)
    {
        super++;
        ++ultra;
        printf("super = %d, ultra = %d \n", super, ultra);
    }

    return 0;
}
```

运行：

```c
super = 1, ultra = 1
super = 2, ultra = 2
super = 3, ultra = 3
super = 4, ultra = 4
super = 5, ultra = 5
```

该程序两次同时计数到 5。用下面两条语句分别代替程序中的两条递增语句，程序的输出相同：

```c
super = super + 1;
ultra = ultra + 1;
```

这些都是很简单的语句，为何还要创建两个缩写形式？原因之一是，紧凑结构的代码让程序更为简洁，可读性更高。这些运算符让程序看起来很美
观。

递增运算符的另一个优点是，通常它生成的机器语言代码效率更高，因为它和实际的机器语言指令很相似。尽管如此，随着商家推出的 C 编译器越来越智能，这一优势可能会消失。一个智能的编译器可以把 `x = x + 1` 当作 `++x` 对待。

最后，递增运算符还有一个在某些场合特别有用的特性。我们通过程序清单 5.11 来说明。

```c
// 程序清单5.11 post_pre.c程序
/* post_pre.c -- 前缀和后缀 */
#include <stdio.h>
int main(void)
{
    int a = 1, b = 1;
    int a_post, pre_b;

    a_post = a++; // 后缀递增
    pre_b = ++b; // 前缀递增
    printf("a  a_post   b   pre_b \n");
    printf("%1d %5d %5d %5d\n", a, a_post, b, pre_b);

    return 0;
}
```

运行：

```c
a  a_post   b   pre_b
2     1     2     2
```

`a` 和 `b` 都递增了 1，但是，`a_post` 是 `a` 递增之前的值，而 `b_pre` 是 `b` 递增之后的值。这就是 `++` 的前缀形式和后缀形式的区别（见图 5.5）。

```c
a_post = a++; // 后缀：使用a的值之后，递增a
b_pre = ++b; // 前缀：使用b的值之前，递增b
```

<div align=center>
<img width="60%" src="\programme\C_C++\C_primer_plus\image\前缀和后缀.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 图 5.5 前缀和后缀
</div>
</div>

单独使用递增运算符时（如，`ego++;`），使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时（如上面的示例），使用前缀或后缀的效果不同。

<mark>如果使用前缀形式和后缀形式会对代码产生不同的影响，那么最为明智的是不要那样使用它们</mark>。例如，不要使用下面的语句：

```c
b = ++i; // 如果使用i++，会得到不同的结果
```

应该使用下列语句：

```c
++i; // 第1行
b = i; // 如果第1行使用的是i++，幵不会影响b的值
```

尽管如此，有时小心翼翼地使用会更有意思。所以，本书会根据实际情况，采用不同的写法。

### 5.3.4 递减运算符：--

每种形式的递增运算符都有一个**递减运算符**（decrement operator）与之对应，用 `--` 代替 `++` 即可：

```c
--count; // 前缀形式的递减运算符
count--; // 后缀形式的递减运算符
```

### 5.3.5 优先级

递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，`x*y++` 表示的是 `(x)*(y++)`，而不是 `(x*y)++`。不过后者无效，<mark>因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值）</mark>，而组合 `x*y` 本身不是可修改的左值。

如果 `n++` 是表达式的一部分，可将其视为“先使用 `n`，再递增”；而 `++n` 则表示“先递增 `n`，再使用”。

### 5.3.6 不要自作聪明

如果一次用太多递增运算符，自己都会糊涂。例如，下面的 `while` 循环：

```c
while (num < 21)
{
    printf("%10d %10d\n", num, num*num++);
}
```

这个想法看上去不错。打印 `num`，然后计算 `num*num` 得到平方值，最后把 `num` 递增 1。但事实上，修改后的程序只能在某些系统上能正常运行。该程序的问题是：当 `printf()` 获取待打印的值时，可能先对最后一个参数（`num*num++`）求值，这样在获取其他参数的值之前就递增了 `num`。所以，本应打印：

```c
5 25
```

却打印成：

```c
6 25
```

它甚至可能从右往左执行，对最右边的 `num`（`++` 作用的 `num`）使用 5，对第 2 个 `num` 和最左边的 `num` 使用 6，结果打印出：

```c
6 30
```

</mark>在 C 语言中，编译器可以自行选择先对函数中的哪个参数求值</mark>。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。

类似这样的语句，也会导致一些麻烦：

```c
ans = num/2 + 5*(1 + num++);
```

同样，该语句的问题是：编译器可能不会按预想的顺序来执行。你可能认为，先计算第 1 项（`num/2`），接着计算第 2 项（`5*(1 + num++)`）。但是，编译器可能先计算第 2 项，递增 `num`，然后在 `num/2` 中使用 `num` 递增后的新值。因此，无法保证编译器到底先计算哪一项。还有一种情况，也不确定：

```c
n = 3;
y = n++ + n++;
```

可以肯定的是，执行完这两条语句后，`n` 的值会比旧值大 2。但是，`y` 的值不确定。在对 `y` 求值时，编译器可以使用 `n` 的旧值（3）两次，然后把 `n` 递增 1 两次，这使得 `y` 的值为 `6`，n 的值为 `5`。或者，编译器使用 `n` 的旧值（3）一次，立即递增 `n`，再对表达式中的第 2 个 `n` 使用递增后的新值，然后再递增 `n`，这使得 `y` 的值为 `7`，`n` 的值为 `5`。两种方案都可行。对于这种情况更精确地说，结果是未定义的，这意味着 C 标准并未定义结果应该是什么。

遵循以下规则，很容易避免类似的问题：

- 如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；
- 如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。

另一方面，对于何时执行递增，C 还是做了一些保证。我们在本章后面的“副作用和序列点”中学到序列点时再来讨论这部分内容。

## 5.4 表达式和语句

在前几章中，我们已经多次使用了术语**表达式**（expression）和**语句**（statement）。现在，我们来进一步学习它们。C 的基本程序步骤由**语句**组成，而大多数语句都由**表达式**构成。因此，我们先学习表达式。

### 5.4.1 表达式

**表达式**（expression）由**运算符**和**运算对象**组成（前面介绍过，运算对象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。下面是一些表达式：

```c
4
-6
4+21
a*(b + c/d)/20
q = 5*2
x = ++q % 3
q > 3
```

如你所见，运算对象可以是**常量**、**变量**或**二者的组合**。一些表达式由**子表达式**（subexpression）组成（子表达式即较小的表达式）。例如，`c/d` 是上面例子中 `a*(b + c/d)/20` 的子表达式。

##### 每个表达式都有一个值

C 表达式的一个最重要的特性是，<mark>每个表达式都有一个值</mark>。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。在上面我们列出的表达式中，前几个都很清晰明了。但是，有赋值运算符（`=`）的表达式的值是什么？**这些表达式的值与赋值运算符左侧变量的值相同**。因此，表达式 `q = 5*2` 作为一个整体的值是 10。那么，表达式 `q > 3` 的值是多少？这种关系表达式的值不是 0 就是 1，如果条件为真，表达式的值为 1；如果条件为假，表达式的值为 0。表 5.2 列出了一些表达式及其值：

虽然最后一个表达式看上去很奇怪，但是在 C 中完全合法（但不建议使用），因为它是两个子表达式的和，每个子表达式都有一个值。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\一些表达式及其值.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;">  表 5.2 一些表达式及其值
</div>
</div>

### 5.4.2 语句

**语句**（statement）是 C 程序的基本构建块。**一条语句相当于一条完整的计算机指令**。**在 C 中，大部分语句都以分号结尾**。因此，

```c
legs = 4
```

只是一个表达式（它可能是一个较大表达式的一部分），而下面的代码则是一条语句：

```c
legs = 4;
```

最简单的语句是**空语句**：

```c
; //空语句
```

C 把末尾加上一个分号的表达式都看作是一条语句（即，**表达式语句**）。因此，像下面这样写也没问题：

```c
8;
3 + 4;
```

但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切地说，**语句可以改变值或调用函数**：

```c
x = 25;
++x;
y = sqrt(x);
```

虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令，但<mark>并不是所有的指令都是语句</mark>。考虑下面的语句：

```c
x = 6 + (y = 5);
```

该语句中的子表达式 `y = 5` 是一条完整的指令，但是它只是语句的一部分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况下的语句（即，简单语句）。

到目前为止，读者已经见过多种语句（不包括空语句）。程序清单 5.13 演示了一些常见的语句。

```c
// 程序清单5.13 addemup.c程序
/* addemup.c -- 几种常见的语句 */
#include <stdio.h>
int main(void) /* 计算前20个整数的和 */
{
    int count, sum; /* 声明[1] */

    count = 0; /* 表达式语句 */
    sum = 0; /* 表达式语句 */
    while (count++ < 20) /* 迭代语句 */
        sum = sum + count;
    printf("sum = %d\n", sum); /* 表达式语句[2] */

    return 0; /* 跳转语句 */
}
```

运行：

```c
sum = 210
```

[1] 根据 C 标准，声明不是语句。这与 C++ 有所不同。

[2] 在 C 语言中，**赋值和函数调用都是表达式**。没有所谓的“赋值语句”和“函数调用语句”，这些语句实际上都是**表达式语句**。本书将“assignment statement”均译为“**赋值表达式语句**”，以提醒读者注意。

下面我们讨论程序清单 5.13。到目前为止，相信读者已经很熟悉声明了。尽管如此，我们还是要提醒读者：**声明创建了名称和类型，并为其分配内存位置**。<mark>注意，声明不是表达式语句</mark>。也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值：

```c
int port /* 不是表达式，没有值 */
```

赋值表达式语句在程序中很常用：它为变量分配一个值。赋值表达式语句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾。注意，在 `while` 循环中有一个赋值表达式语句。赋值表达式语句是表达式语句的一个示例。

**函数表达式语句会引起函数调用**。在该例中，调用 `printf()` 函数打印结果。`while` 语句有 3 个不同的部分。首先是关键字 `while`；然后，圆括号中是待测试的条件；最后如果测试条件为真，则执行 `while` 循环体中的语句。该例的 `while` 循环中只有一条语句。可以是本例那样的一条语句，不需要用花括号括起来，也可以像其他例子中那样包含多条语句。**多条语句需要用花括号括起来**，这种语句是**复合语句**。

`while` 语句是一种**迭代语句**，有时也被称为**结构化语句**，因为它的结构比简单的赋值表达式语句复杂。

##### 副作用和序列点

我们再讨论一个 C 语言的术语**副作用**（side effect）。**副作用是对数据对象或文件的修改**。例如，语句：

```c
states = 50;
```

它的副作用是将变量的值设置为 50。副作用？这似乎更像是主要目的！但是从 C 语言的角度看，**主要目的是对表达式求值**。给出表达式 `4 + 6`，C 会对其求值得 10；给出表达式 `states = 50`，C 会对其求值得 50。对该表达式求值的**副作用**是把变量 `states` 的值改为 50。跟赋值运算符一样，递增和递减运算符也有副作用，使用它们的主要目的就是使用其副作用。

类似地，调用 `printf()` 函数时，它显示的信息其实是副作用（`printf()` 的返回值是待显示字符的个数）。

**序列点**（sequence point）是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在 C 语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。后面我们要讨论的一些运算符也有序列点。另外，<mark>任何一个完整表达式的结束也是一个序列点</mark>。

什么是**完整表达式**？所谓完整表达式（full expression），就是指这个表达式不是另一个更大表达式的子表达式。例如，表达式语句中的表达式和 `while` 循环中的作为测试条件的表达式，都是完整表达式。

序列点有助于分析后缀递增何时发生。例如，考虑下面的代码：

```c
while (guests++ < 10)
    printf("%d \n", guests);
```

对于该例，C 语言的初学者认为“先使用值，再递增它”的意思是，在 `printf()` 语句中先使用 `guests`，再递增它。但是，表达式 `guests++ < 10` 是一个完整的表达式，因为它是 `while` 循环的测试条件，所以该表达式的结束就是一个序列点。因此，C 保证了在程序转至执行 `printf()` 之前发生副作用（即，递增 `guests`）。同时，使用后缀形式保证了 `guests` 在完成与 10 的比较后才进行递增。

现在，考虑下面这条语句：

```c
y = (4 + x++) + (6 + x++);
```

表达式 `4 + x++` 不是一个完整的表达式，所以 C 无法保证 `x` 在子表达式 `4 + x++` 求值后立即递增 `x`。这里，完整表达式是整个赋值表达式语句，分号标记了序列点。所以，C 保证程序在执行下一条语句之前递增 `x` 两次。C 并未指明是在对子表达式求值以后递增 `x`，还是对所有表达式求值后再递增 `x`。因此，要尽量避免编写类似的语句。

### 5.4.3 复合语句（块）

**复合语句**（compound statement）是用花括号括起来的一条或多条语句，复合语句也称为**块**（block）。`shoes2.c` 程序使用块让 `while` 语句包含多条语句。比较下面两个程序段：

```c
/* 程序段 1 */
index = 0;
while (index++ < 10)
    sam = 10 * index + 2;
printf("sam = %d\n", sam);
/* 程序段 2 */
index = 0;
while (index++ < 10)
{
    sam = 10 * index + 2;
    printf("sam = %d\n", sam);
}
```

- 程序段 1，`while` 循环中只有一条赋值表达式语句。没有花括号，`while` 语句从 `while` 这行运行至下一个分号。循环结束后，`printf()` 函数只会被调用一次。
- 程序段 2，花括号确保两条语句都是 `while` 循环的一部分，每执行一次循环就调用一次 `printf()` 函数。根据 `while` 语句的结构，整个复合语句被视为一条语句。

##### 提示：风格提示

再看一下前面的两个 `while` 程序段，注意循环体中的缩进。<mark>缩进对编译器不起作用</mark>，编译器通过花括号和 `while` 循环的结构来识别和解释指令。这里，缩进是为了让读者一眼就可以看出程序是如何组织的。

程序段 2 中，块或复合语句放置花括号的位置是一种常见的风格。另一种常用的风格是：

```c
while (index++ < 10) {
    sam = 10*index + 2;
    printf("sam = %d \n", sam);
}
```

这种风格突出了块附属于 `while` 循环，而前一种风格则强调语句形成一个块。对编译器而言，这两种风格完全相同。

总而言之，使用缩进可以为读者指明程序的结构。

##### 总结：表达式和语句

**表达式**：表达式由运算符和运算对象组成。最简单的表达式是不带运算符的一个常量或变量（如，`22` 或 `beebop`）。更复杂的例子是 `55 + 22` 和 `vap = 2 * (vip +(vup = 4))`。

**语句**：到目前为止，读者接触到的语句可分为简单语句和复合语句。简单语句以一个分号结尾。如下所示：

- 赋值表达式语句: `toes = 12;`
- 函数表达式语句: `printf("%d\n", toes);`
- 空语句: `; /* 什么也不做 */`

**复合语句**（或块）由花括号括起来的一条或多条语句组成。如下面的 `while` 语句所示：

```c
while (years < 100)
{
    wisdom = wisdom * 1.05;
    printf("%d %d\n", years, wisdom);
    years = years + 1;
}
```

## 5.5 类型转换

通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用**混合类型**，C 不会像 Pascal 那样停在那里死掉，而是采用一套规则进行**自动类型转换**。虽然这很便利，但是有一定的危险性，尤其是在无意间混合使用类型的情况下（许多 UNIX 系统都使用 lint 程序检查类型“冲突”。如果选择更高错误级别，许多非 UNIX C 编译器也可能报告类型问题）。最好先了解一些基本的类型转换规则。

1. 当类型转换出现在表达式时：
   - 无论是 `unsigned` 还是 `signed` 的 `char` 和 `short` 都会被自动转换成 `int`，如有必要会被转换成 `unsigned int`。
   - 如果 `short` 与 `int` 的大小相同，`unsigned short` 就比 `int` 大。这种情况下，`unsigned short` 会被转换成 `unsigned int`。
   - 在 K&R 那时的 C 中，`float` 会被自动转换成 `double`，<mark>目前的 C 不是这样</mark>。
   - 由于都是从较小类型转换为较大类型，所以这些转换被称为**升级**（promotion）。
2. 涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。
3. 类型的级别从高至低依次是 `long double`、`double`、`float`、`unsigned long long`、`long long`、`unsigned long`、`long`、`unsigned int`、`int`。例外的情况是，当 `long` 和 `int` 的大小相同时，`unsigned int` 比 `long` 的级别高。之所以 `short` 和 `char` 类型没有列出，是因为它们已经被升级到 `int` 或 `unsigned int`。
4. 在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型**升级**或**降级**（demotion）。所谓降级，是指把一种类型转换成更低级别的类型
5. 当作为函数参数传递时，`char` 和 `short` 被转换成 `int`，`float` 被转换成 `double`。第 9 章将介绍，函数原型会覆盖自动升级。

类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原因很简单：较低类型可能放不下整个数字。例如，一个 8 位的 `char` 类型变量储存整数 101 没问题，但是存不下 22334。

如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。待赋值的值与目标类型不匹配时，规则如下。

1. 目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位 unsigned char，待赋的值是原始值求模 256。
2. 如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。
3. 如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。

如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为整数类型时，原来的浮点值会被截断。例如，23.12 和 23.99 都会被截断为 23，-23.5 会被截断为 -23。

```c
// 程序清单5.14 convert.c程序
/* convert.c -- 自动类型转换 */
#include <stdio.h>
int main(void)
{
    char ch;
    int i;
    float fl;

    fl = i = ch = 'C'; /* 第9行 */
    printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl); /* 第10行 */
    ch = ch + 1; /* 第11行 */
    i = fl + 2 * ch; /* 第12行 */
    fl = 2.0 * ch + i; /* 第13行 */
    printf("ch = %c, i = %d, fl = %2.2f\n", ch, i, fl); /* 第14行 */
    ch = 1107; /* 第15行 */
    printf("Now ch = %c\n", ch); /* 第16行 */
    ch = 80.89; /* 第17行 */
    printf("Now ch = %c\n", ch); /* 第18行 */

    return 0;
}
```

运行：

```c
ch = C, i = 67, fl = 67.00
ch = D, i = 203, fl = 339.00
Now ch = S
Now ch = P
```

在我们的系统中，`char` 是 8 位，`int` 是 32 位。程序的分析如下。

- 第 9 行和第 10 行：字符 `'C'` 被作为 1 字节的 ASCII 值储存在 `ch` 中。整数变量 `i` 接受由 `'C'` 转换的整数，即按 4 字节储存 67。最后，`fl` 接受由 `67` 转换的浮点数 `67.00`。
- 第 11 行和第 14 行：字符变量 `'C'` 被转换成整数 `67`，然后加 `1`。计算结果是 4 字节整数 `68`，被截断成 1 字节储存在 `ch` 中。根据 `%c` 转换说明打印时，`68` 被解释成 `'D'` 的 ASCII 码。
- 第 12 行和第 14 行：`ch` 的值被转换成 4 字节的整数（68），然后 2 乘以 `ch`。为了和 `fl` 相加，乘积整数（`136`）被转换成浮点数。计算结果（`203.00f`）被转换成 `int` 类型，并储存在 `i` 中。
- 第 13 行和第 14 行：`ch` 的值（`'D'`，或 `68`）被转换成浮点数，然后 2 乘以 `ch`。为了做加法，i 的值（`203`）被转换为浮点类型。计算结果（`339.00`）被储存在 `fl` 中。
- 第 15 行和第 16 行：演示了类型降级的示例。把 `ch` 设置为一个超出其类型范围的值，忽略额外的位后，最终 `ch` 的值是字符 `S` 的 ASCII 码。或者，更确切地说，`ch` 的值是 `1107 % 265`，即 83。
- 第 17 行和第 18 行：演示了另一个类型降级的示例。把 `ch` 设置为一个浮点数，发生截断后，`ch` 的值是字符 `P` 的 ASCII 码。

### 5.5.1 强制类型转换运算符

通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而，有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到**强制类型转换**（cast），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了**强制类型转换运算符**（cast operator），其通用形式是：

```c
(type)
```

用实际需要的类型（如，`long`）替换 `type` 即可。

考虑下面两行代码，其中 `mice` 是 `int` 类型的变量。第 2 行包含两次 `int` 强制类型转换。

```c
mice = 1.6 + 1.7;
mice = (int)1.6 + (int)1.7;
```

第 1 行使用自动类型转换。首先，`1.6` 和 `1.7` 相加得 `3.3`。然后，为了匹配 `int` 类型的变量，`3.3` 被类型转换截断为整数 `3`。第 2 行，`1.6` 和 `1.7` 在相加之前都被转换成整数（`1`），所以把 `1 + 1` 的和赋给变量 `mice`。本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。

一般而言，不应该混合使用类型（因此有些语言直接不允许这样做），但是偶尔这样做也是有用的。C 语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任。

## 5.6 带参数的函数

程序清单 5.15 中有一个 `pound()` 函数，打印指定数量的 `#` 号（该符号也叫作编号符号或井号）。该程序还演示了类型转换的应用。

```c
// 程序清单5.15 pound.c程序
/* pound.c -- 定义一个带一个参数的函数 */
#include <stdio.h>
void pound(int n);// ANSI函数原型声明
int main(void)
{
    int times = 5;
    char ch = '!'; // ASCII码是33
    float f = 6.0f;

    pound(times); // int类型的参数
    pound(ch); // 和pound((int)ch);相同
    pound(f); // 和pound((int)f);相同

    return 0;
}

void pound(int n) // ANSI风格函数头
{ // 表明该函数接受一个int类型的参数
    while (n-- > 0)
        printf("#");
    printf("\n");
}
```

运行：

```c
#####
#################################
######
```

首先，看程序的函数头：

```c
void pound(int n)
```

如果函数不接受任何参数，函数头的圆括号中应该写上关键字 `void`。由于该函数接受一个 `int` 类型的参数，所以圆括号中包含一个 `int` 类型变量 `n` 的声明。参数名应遵循 C 语言的命名规则。

声明参数就创建了被称为**形式参数**（formal argument 或 formal parameter，简称**形参**）的变量。该例中，形式参数是 `int` 类型的变量 `n`。像 `pound(10)` 这样的函数调用会把 `10` 赋给 `n`。在该程序中，调用 `pound(times)` 就是把 `times` 的值（`5`）赋给 `n`。我们称函数调用传递的值为**实际参数**（actual argument 或 actual parameter），简称**实参**。所以，函数调用 `pound(10)` 把实际参数 `10` 传递给函数，然后该函数把 `10` 赋给形式参数（变量 `n`）。也就是说，`main()` 中的变量 `times` 的值被拷贝给 `pound()` 中的新变量 `n`。

##### 注意：实参和形参

在英文中，argument 和 parameter 经常可以互换使用，但是 C99 标准规定了：对于 actual argument 或 actual parameter 使用术语 **argument**（译为**实参**）；对于 formal argument 或 formal parameter 使用术语 **parameter**（译为**形参**）。为遵循这一规定，我们可以说**形参是变量，实参是函数调用提供的值，实参被赋给相应的形参**。因此，在程序清单 5.15 中，`times` 是 `pound()` 的实参，`n` 是 `pound()` 的形参。类似地，在函数调用 `pound(times + 4)` 中，表达式 `times + 4` 的值是该函数的实参。

变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突。如果在 `pound()` 中用 `times` 代替 `n`，那么这个 `times` 与 `main()` 中的 `times` 不同。也就是说，程序中出现了两个同名的变量，但是程序可以区分它们。

现在，我们来学习函数调用。第 1 个函数调用是 `pound(times)`，`times` 的值 `5` 被赋给 `n`。因此，`printf()` 函数打印了 5 个井号和 1 个换行符。第 2 个函数调用是 `pound(ch)`。这里，`ch` 是 `char` 类型，被初始化为 `!` 字符，在 ASCII 中 `ch` 的数值是 `33`。但是 `pound()` 函数的参数类型是 `int`，与 `char` 不匹配。程序开头的**函数原型**在这里发挥了作用。原型（prototype）即是函数的声明，描述了函数的返回值和参数。`pound()` 函数的原型说明了两点：

- 该函数没有返回值（函数名前面有 `void` 关键字）；
- 该函数有一个 `int` 类型的参数。

该例中，函数原型告诉编译器 `pound()` 需要一个 `int` 类型的参数。相应地，当编译器执行到 `pound(ch)` 表达式时，会把参数 `ch` 自动转换成 `int` 类型。在我们的系统中，该参数从 1 字节的 `33` 变成 4 字节的 `33`，所以现在 `33` 的类型满足函数的要求。与此类似，最后一次调用是 `pound(f)`，使得 `float` 类型的变量被转换成合适的类型。

在 ANSI C 之前，C 使用的是**函数声明**，而不是**函数原型**。**函数声明只指明了函数名和返回类型，没有指明参数类型**。为了向下兼容，C 现在仍然允许这样的形式：

```c
void pound(); /* ANSI C乊前的函数声明 */
```

如果用这条函数声明代替 pound.c 程序中的函数原型会怎样？第 1 次函数调用，`pound(times)` 没问题，因为 `times` 是 `int` 类型。第 2 次函数调用，`pound(ch)` 也没问题，因为即使缺少函数原型，C 也会把 `char` 和 `short` 类型自动升级为 `int` 类型。第 3 次函数调用，`pound(f)` 会失败，因为缺少函数原型，`float` 会被自动升级为 `double`，这没什么用。虽然程序仍然能运行，但是输出的内容不正确。**在函数调用中显式使用强制类型转换**，可以修复这个问题：

```c
pound ((int)f); // 把f强制类型转换为正确的类型
```

注意，如果 `f` 的值太大，超过了 `int` 类型表示的范围，这样做也不行。

## 5.8 关键概念

C 通过运算符提供多种操作。每个运算符的特性包括运算对象的数量、优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定了先进行哪项运算。每个 C 表达式都有一个值。如果不了解运算符的优先级和结合律，写出的表达式可能不合法或者表达式的值与预期不符。这会影响你成为一名优秀的程序员。

虽然 C 允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型。因此，C 会进行自动类型转换。尽管如此，不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样，就不用担心出现不必要的自动类型转换。

## 5.9 本章小结

C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符。一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个运算对象的运算符（如负号和 `sizeof`）称为一元运算符，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为二元运算符。表达式由运算符和运算对象组成。在 C 语言中，每个表达式都有一个值，包括赋值表达式和比较表达式。运算符优先级规则决定了表达式中各项的求值顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。如果运算符的优先级相等，由结合律（从左往右或从右往左）决定求值顺序。

大部分语句都以分号结尾。最常用的语句是表达式语句。用花括号括起来的一条或多条语句构成了复合语句（或称为块）。`while` 语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句。

在 C 语言中，许多类型转换都是自动进行的。当 `char` 和 `short` 类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为 `int` 类型；`float` 类型在函数参数中时，会被升级为 `double` 类型。在 K&R C（不是 ANSIC）下，表达式中的 `float` 也会被升级为 `double` 类型。当把一种类型的值赋给另一种类型的变量时，值将被转换成与变量的类型相同。当把较大类型转换成较小类型时（如，`long` 转换成 `short`，或 `double` 转换成 `float`），可能会丢失数据。根据本章介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型。

定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。
