本章介绍以下内容：

- 函数：`strlen()`
- 关键字：`const`
- 字符串
- 如何创建、存储字符串
- 如何使用 `strlen()` 函数获取字符串的长度
- 用 C 预处理器指令 `#define` 和 ANSIC 的 `const` 修饰符创建**符号常量**

本章将详细介绍 C 语言的两个**输入/输出函数**：`printf()` 和 `scanf()`。学会使用这两个函数，不仅能与用户交互，还可根据个人喜好和任务要求格式化输出。最后，简要介绍一个重要的工具——**C 预处理器指令**，并学习如何定义、使用**符号常量**。

## 4.1 前导程序

```c
// 程序清单4.1 talkback.c 程序
// talkback.c -- 演示与用户交互
#include <stdio.h>
#include <string.h> // 提供 strlen() 函数的原型
#define DENSITY 62.4 // 人体密度（单位：磅/立方英尺）
int main()
{
    float weight, volume;
    int size, letters;
    char name[40]; // name 是一个可容纳 40 个字符的数组
    printf("Hi! What's your first name?\n");
    scanf("%s", name);
    printf("%s, what's your weight in pounds?\n", name);
    scanf("%f", &weight);
    size = sizeof(name);
    letters = strlen(name);
    volume = weight / DENSITY;
    printf("Well, %s, your volume is %2.2f cubic feet.\n",
            name, volume);
    printf("Also, your first name has %d letters,\n",
            letters);
    printf("and we have %d bytes to store it.\n", size);
    return 0;
}
```

运行：

```c
Hi! What's your first name?
Christine
Christine, what's your weight in pounds?
154
Well, Christine, your volume is 2.47 cubic feet.
Also, your first name has 9 letters,
and we have 40 bytes to store it.
```

该程序包含以下新特性：

- 用**数组**（array）储存**字符串**（character string）。在该程序中，用户输入的名被储存在数组中，该数组占用内存中 40 个连续的字节，每个字节储存一个字符值。
- 使用 `%s` 转换说明来处理字符串的输入和输出。注意，在 `scanf()` 中，`name` 没有 `&` 前缀，而 `weight` 有（稍后解释，`&weight` 和 `name` 都是地址）。
- 用 C 预处理器把字符常量 `DENSITY` 定义为 `62.4`。
- 用 C 函数 `strlen()` 获取字符串的长度。

## 4.2 字符串简介

**字符串**（character string）是一个或多个字符的序列，如下所示：

```c
`"Zing went the strings of my heart!"`
```

双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。

### 4.2.1 char 类型数组和 null 字符

<mark>C 语言没有专门用于储存字符串的变量类型，字符串都被储存在 char 类型的数组中</mark>。**数组由连续的存储单元组成**，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符（见图 4.1）。

<div align=center>
<img width="70%" src="\programme\C_C++\C_primer_plus\image\数组中的字符串.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 图 4.1 数组中的字符串</div>
</div>

图 4.1 中数组末尾位置的字符 `\0`。这是**空字符**（null character），C 语言用它标记字符串的结束。空字符不是数字 0，它是**非打印字符**，其 ASCII 码值是（或等价于）0。<mark>C 中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多 1</mark>。因此，程序清单 4.1 中有 40 个存储单元的字符串，只能储存 39 个字符，剩下一个字节留给空字符。

那么，什么是数组？可以把数组看作是一行连续的多个存储单元。用更正式的说法是，数组是**同类型数据元素的有序序列**。程序清单 4.1 声明创建了一个包含 40 个存储单元（或元素）的数组，每个单元储存一个 `char` 类型的值：

```c
char name[40];
```

`name` 后面的方括号表明这是一个数组，方括号中的 40 表明该数组中的元素数量。`char` 表明每个元素的类型。

字符串看上去比较复杂！必须先创建一个数组，把字符串中的字符逐个放入数组，还要记得在末尾加上一个 `\0`。还好，计算机可以自己处理这些细节。

### 4.2.2 使用字符串

```c
// 程序清单4.2 praise1.c程序
/* praise1.c -- 使用不同类型的字符串 */
#include <stdio.h>
#define PRAISE "You are an extraordinary being."
int main(void)
{
    char name[40];

    printf("What's your name? ");
    scanf("%s", name);
    printf("Hello, %s.%s\n", name, PRAISE);

    return 0;
}
```

运行：

```c
What's your name? Angela Plains
Hello, Angela.You are an extraordinary being.
```

`%s` 告诉 `printf()` 打印一个字符串。`%s` 出现了两次，因为程序要打印两个字符串：一个储存在 `name` 数组中；一个由 `PRAISE` 来表示。

不用亲自把空字符放入字符串末尾，`scanf()` 在读取输入时就已完成这项工作。也不用在字符串常量 `PRAISE` 末尾添加空字符。`PRAISE` 后面用双引号括起来的文本是一个字符串。<mark>编译器会在末尾加上空字符</mark>。

注意（这很重要），`scanf()` 只读取了 `Angela Plains` 中的 `Angela`，<mark> scanf() 在遇到第 1 个空白（空格、制表符或换行符）时就不再读取输入</mark>。因此，`scanf()` 在读到 `Angela` 和 `Plains` 之间的空格时就停止了。一般而言，根据 `%s` 转换说明，`scanf()` 只会读取字符串中的一个单词，而不是一整句。C 语言还有其他的输入函数（如，`fgets()`），用于读取一般字符串。后面章节将详细介绍这些函数。

#### 字符串和字符

字符串常量 `"x"` 和字符常量 `'x'` 不同。

- 区别之一在于 `'x'` 是**基本类型**（char），而 `"x"` 是**派生类型**（`char` 数组）；
- 区别之二是 `"x"` 实际上由两个字符组成：`'x'` 和空字符 `\0`。

### 4.2.3 sizeof 运算符和 strlen() 函数

`sizeof` 运算符以字节为单位给出对象的大小。`strlen()` 函数给出字符串中的字符长度。因为 1 字节储存一个字符，读者可能认为把
两种方法应用于字符串得到的结果相同，但事实并非如此。

```c
// 程序清单4.3 praise2.c程序
/* praise2.c */
// 如果编译器不识别 %zd，尝试换成 %u 或 %lu。
#include <stdio.h>
#include <string.h> /* 提供 strlen() 函数的原型 */
#define PRAISE "You are an extraordinary being."

int main(void)
{
    char name[40];

    printf("What's your name? ");
    scanf("%s", name);
    printf("Hello, %s.%s\n", name, PRAISE);
    printf("Your name of %zd letters occupies %zd memory cells.\n",
            strlen(name), sizeof name);
    printf("The phrase of praise has %zd letters ",
            strlen(PRAISE));
    printf("and occupies %zd memory cells.\n", sizeof PRAISE);

    return 0;
}
```

运行：

```c
What's your name? Serendipity Chance
Hello, Serendipity.You are an extraordinary being.
Your name of 11 letters occupies 40 memory cells.
The phrase of praise has 31 letters and occupies 32 memory cells.
```

`string.h` 头文件包含多个与字符串相关的函数原型，包括 `strlen()`。一般而言，C 把函数库中相关的函数归为一类，并为每类函数提供一个头文件。例如：

- `printf()` 和 `scanf()` 都隶属标准输入和输出函数，使用 `stdio.h` 头文件。
- `string.h` 头文件中包含了 `strlen()` 函数和其他一些与字符串相关的函数，如**拷贝字符串的函数**和**字符串查找函数**。

注意，程序清单 4.3 使用了两种方法处理很长的 `printf()` 语句。

- 第 1 种方法是将 `printf()` 语句分为两行，</mark>可以在参数之间断为两行，但是不要在双引号中的字符串中间断开</mark>；
- 第 2 种方法是使用两个 `printf()` 语句打印一行内容，只在第 2 条 `printf()` 语句中使用换行符（`\n`）。

`sizeof` 运算符报告，`name` 数组有 40 个存储单元。但是，只有前 11 个单元用来储存 `Serendipity`，所以 `strlen()` 得出的结果是 11。`name` 数组的第 12 个单元储存空字符，`strlen()` 并未将其计入。

对于 `PRAISE`，用 `strlen()` 得出的也是字符串中的**字符数**（包括空格和标点符号）。然而，`sizeof` 运算符给出的数更大，因为**它把字符串末尾不可见的空字符也计算在内**。该程序并未明确告诉计算机要给字符串预留多少空间，所以它必须计算双引号内的字符数。

C99 和 C11 标准专门为 `sizeof` 运算符的返回类型添加了 `%zd` 转换说明，这对于 `strlen()` 同样适用。
对于早期的 C，还要知道 `sizeof` 和 `strlen()` 返回的实际类型（通常是 `unsigned` 或 `unsigned long`）。

另外，还要注意一点：上一章的 `sizeof` 使用了**圆括号**，但本例没有。<mark>圆括号的使用时机否取决于运算对象是类型还是特定量。运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无</mark>。也就是说，对于类型，应写成 `sizeof(char)` 或 `sizeof(float)`；对于特定量，可写成 `sizeof name` 或 `sizeof 6.28`。尽管如此，还是建议所有情况下都使用圆括号，如 `sizeof(6.28)`。

## 4.3 常量和 C 预处理器

```c
circumference = 3.14159 * diameter;
circumference = pi * diameter;
```

这里，`3.14159` 是**常量**，`pi` 是**符号常量**。

为什么使用符号常量更好？

- 首先，常量名比数字表达的信息更多。
- 另外，假设程序中的多处使用一个常量，有时需要改变它的值。如果程序使用符号常量，则只需更改符号常量的定义，不用在程序中查找使用常量的地方，然后逐一修改。

如何创建符号常量？方法之一是声明一个变量，然后将该变量设置为所需的常量。如：

```c
float taxrate;
taxrate = 0.015;
```

这样做提供了一个符号名，但是 `taxrate` 是一个变量，程序可能会无意间改变它的值。

C 语言还提供了一个更好的方案——C 预处理器。**C 预处理器**也可以用来定义符号常量。只需在程序顶部添加下面一行：

```c
#define TAXRATE 0.015
```

编译程序时，程序中所有的 `TAXRATE` 都会被替换成 `0.015`。这一过程被称为**编译时替换**（compile-time substitution）。在运行程序时，程序中所有的替换均已完成。通常，这样定义的常量也称为**明示常量**（manifest constant）。

请注意格式，首先是 `#define`，接着是符号常量名（`TAXRATE`），然后是符号常量的值（`0.015`）。注意，其中并没有 `=` 符号。所以，其通用格式如下：

```c
#define NAME value
```

实际应用时，用选定的符号常量名和合适的值来替换 `NAME` 和 `value`。<mark>注意，末尾不用加分号</mark>，因为这是一种由预处理器处理的替换机制。为什么 `TAXRATE` 要用大写？用大写表示符号常量是 C 语言一贯的传统。这样，在程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。大写常量只是为了提高程序的可读性，即使全用小写来表示符号常量，程序也能照常运行。尽管如此，初学者还是应该养成大写常量的好习惯。

另外，还有一个不常用的命名约定，即在名称前带 `c_` 或 `k_` 前缀来表示常量（如，`c_level` 或 `k_line`）。

符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线字符，首字符不能为数字。

> 其实，符号常量的概念在 K&R 合著的《C 语言程序设计》中介绍过。但是，在历年的 C 标准中（包括最新的 C11），并没有符号常量的概念，只提到过 #define 最简单的用法是定义一个“明示常量”。市面上各编程书籍对此概念的理解不同，有些作者把 #define 宏定义实现的“常量”归为“明示常量”；有些作者（如，本书的作者）则认为“明示常量”相当于“符号常量”。

`#define` 指令还可定义字符和字符串常量。前者使用单引号，后者使用双引号。如下所示：

```c
#define BEEP '\a'
#define TEE 'T'
#define ESC '\033'
#define OOPS "Now you have done it!"
```

记住，符号常量名后面的内容被用来替换符号常量。不要犯这样的常见错误：

```c
/* 错误的格式 */
#define TOES = 20
```

如果这样做，替换 `TOES` 的是 `= 20`，而不是 `20`。这种情况下，下面的语句：

```c
digits = fingers + TOES;
```

将被转换成错误的语句：

```c
digits = fingers + = 20;
```

### 4.3.1 const 限定符

C90 标准新增了 `const` 关键字，**用于限定一个变量为只读**。（注意，在 C 语言中，用 `const` 类型限定符声明的是变量，不是常量。）其声明如下：

```c
const int MONTHS = 12; // MONTHS 在程序中不可更改，值为 12
```

这使得 `MONTHS` 成为一个只读值。也就是说，可以在计算中使用 `MONTHS`，可以打印 `MONTHS`，但是不能更改 `MONTHS` 的值。`const` 用起来比 `#define` 更灵活，

### 4.3.2 明示常量

C 头文件 `limits.h` 和 `float.h` 分别提供了与**整数类型和浮点类型大小限制**相关的详细信息。每个头文件都定义了一系列供实现使用的**明示常量**。例如，`limits.h` 头文件包含以下类似的代码：

```c
#define INT_MAX +32767
#define INT_MIN -32768
```

这些明示常量代表 `int` 类型可表示的最大值和最小值。如果系统使用 32 位的 `int`，该头文件会为这些明示常量提供不同的值。如果在程序中包含 `limits.h` 头文件，就可编写下面的代码：

```c
printf("Maximum int value on this system = %d\n", INT_MAX);
```

如果系统使用 4 字节的 `int`，`limits.h` 头文件会提供符合 4 字节 `int` 的 `INT_MAX` 和 `INT_MIN`。表 4.1 列出了 `limits.h` 中能找到的一些明示常量。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\limits中的一些明示常量.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 4.1 limits.h 中的一些明示常量</div>
</div>

> 本书作者认为“明示常量”相当于“符号常量”，经常在书中混用这两个术语。

类似地，`float.h` 头文件中也定义一些明示常量，如 `FLT_DIG` 和 `DBL_DIG`，分别表示 `float` 类型和 `double` 类型的有效数字位数表 4.2 列出了 float.h 中的一些明示常量，可以使用文本编辑器打开并查看系统使用的 `float.h` 头文件。表中所列都与 `float` 类型相关。把明示常量名中的 `FLT` 分别替换成 `DBL` 和 `LDBL`，即可分别表示 `double` 和 `long double` 类型对应的明示常量（表中假设系统使用 2 的幂来表示浮点数）。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\float中的一些明示常量.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 4.2 float.h 中的一些明示常量</div>
</div>

## 4.4 printf() 和 scanf()

`printf()` 函数和 `scanf()` 函数能让用户可以与程序交流，它们是输入/输出函数，或简称为 **I/O 函数**。过去，这些函数和 C 库的一些其他函数一样，并不是 C 语言定义的一部分。最初，C 把输入/输出的实现留给了编译器的作者，这样可以针对特殊的机器更好地匹配输入/输出。后来，考虑到兼容性的问题，各编译器都提供不同版本的 `printf()` 和 `scanf()`。尽管如此，各版本之间偶尔有一些差异。C90 和 C99 标准规定了这些函数的标准版本，本书亦遵循这一标准。

虽然 `printf()` 是输出函数，`scanf()` 是输入函数，但是<mark>它们的工作原理几乎相同</mark>。两个函数都使用**格式字符串**和**参数列表**。

### 4.4.1 printf() 函数

请求 `printf()` 函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时使用 `%d`，打印字符时使用 `%c`。这些符号被称为**转换说明**（conversion specification），它们指定了如何把数据转换成可显示的形式。表 4.3 列出了一些转换说明和各自对应的输出类型。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\printf转换说明.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 4.3 转换说明及其打印的输出结果</div>
</div>

### 4.4.2 使用 printf()

`printf()` 函数的格式：

```c
printf( 格式字符串, 待打印项1, 待打印项2,...);
```

待打印项 1、待打印项 2 等都是要打印的项。它们可以是**变量**、**常量**，甚至是**在打印之前先要计算的表达式**。

如图 4.7 所示，格式字符串包含两种形式不同的信息：

- 实际要打印的字符；
- 转换说明。

<div align=center>
<img width="50%" src="\programme\C_C++\C_primer_plus\image\剖析格式字符串.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 图 4.7 剖析格式字符串</div>
</div>

> 格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。

如果只打印短语或句子，就不需要使用任何转换说明。如果只打印数据，也不用加入说明文字。

```c
printf("Farewell! thou art too dear for my possessing,\n");
printf("%c%d\n", '$', 2 * cost);
```

注意第 2 条语句，待打印列表的第 1 个项是一个字符常量，不是变量；第 2 个项是一个乘法表达式。这说明 `printf()` 使用的是值，无论是变量、常量还是表达式的值。'

由于 `printf()` 函数使用 `%` 符号来标识转换说明，因此打印 `%` 符号就成了个问题。如果单独使用一个 `%` 符号，编译器会认为漏掉了一个转换字符。解决方法很简单，使用两个 `%` 符号就行了：

```c
pc = 2*6;
printf("Only %d%% of Sally's gribbles were edible.\n", pc);
```

### 4.4.3 printf() 的转换说明修饰符

在 `%` 和转换字符之间插入**修饰符**可修饰基本的转换说明。表 4.4 和表 4.5 列出可作为修饰符的合法字符。如果要插入多个字符，其书写顺序应该与表 4.4 中列出的顺序相同。不是所有的组合都可行。表中有些字符是 C99 新增的，如果编译器不支持 C99，则可能不支持表中的所有项。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\printf的修饰符.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 4.4 printf() 的修饰符</div>
</div>

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\printf的标记.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 4.5 printf() 中的标记</div>
</div>

##### 注意：类型可移植性

`sizeof` 运算符以字节为单位返回类型或值的大小。这应该是某种形式的整数，但是标准只规定了该值是无符号整数。在不同的实现中，它可以是 `unsigned int`、`unsigned long` 甚至是 `unsigned long long`。因此，如果要用 `printf()` 函数显示 `sizeof` 表达式，根据不同系统，可能使用 `%u`、`%lu` 或 `%llu`。这意味着要查找你当前系统的用法，如果把程序移植到不同的系统还要进行修改。鉴于此， C 提供了可移植性更好的类型。

- 首先，`stddef.h` 头文件（在包含 `stdio.h` 头文件时已包含其中）把 `size_t` 定义成系统使用 `sizeof` 返回的型，这被称为**底层类型**（underlying type）。
- 其次，`printf()` 使用 `z` 修饰符表示打印相应的类型。
- 同样，C 还定义了 `ptrdiff_t` 类型和 `t` 修饰符来表示系统使用的两个地址差值的底层有符号整数类型。

##### 注意：float 参数的转换

对于浮点类型，有用于 `double` 和 `long double` 类型的转换说明，却没有 `float` 类型的。这是因为在 K&R C 中，表达式或参数中的 `float` 类型值会被自动转换成 `double` 类型。一般而言，ANSI C 不会把 `float` 自动转换成 `double`。然而，为保护大量假设 float 类型的参数被自动转换成 `double` 的现有程序，`printf()` 函数中所有 `float` 类型的参数（对未使用显式原型的所有 C 函数都有效）仍自动转换成 `double` 类型。因此，无论是 K&R C 还是 ANSI C，都没有显示 `float` 类型值专用的转换说明。

#### 1. 使用修饰符和标记的示例

先来看看**字段宽度**在打印整数时的效果。考虑程序清单 4.7 中的程序。

```c
// 程序清单 4.7 width.c 程序
/* width.c -- 字段宽度 */
#include <stdio.h>
#define PAGES 959
int main(void)
{
    printf("*%d*\n", PAGES);
    printf("*%2d*\n", PAGES);
    printf("*%10d*\n", PAGES);
    printf("*%-10d*\n", PAGES);
    return 0;
}
```

运行：

```c
*959*
*959*
*       959*
*959       *
```

程序中使用**星号**（`*`）标出每个字段的开始和结束。

- 第 1 个转换说明 `%d` 不带任何修饰符，其对应的输出结果与带整数字段宽度的转换说明的输出结果相同。在默认情况下，没有任何修饰符的转换说明，就是这样的打印结果。
- 第 2 个转换说明是 `%2d`，其对应的输出结果应该是 `2` 字段宽度。因为待打印的整数有 3 位数字，所以**字段宽度自动扩大以符合整数的长度**。
- 第 3 个转换说明是 `%10d`，其对应的输出结果有 10 个空格宽度，实际上在两个星号之间有 7 个空格和 3 位数字，并且数字位于字段的右侧。
- 最后一个转换说明是 `%-10d`，其对应的输出结果同样是 10 个空格宽度，`-` 标记说明打印的数字位于字段的左侧。

接下来看看**浮点型**格式。请输入、编译并运行程序清单 4.8 中的程序。

```c
// 程序清单 4.8 floats.c 程序
// floats.c -- 一些浮点型修饰符的组合
#include <stdio.h>
int main(void)
{
    const double RENT = 3852.99; // const 变量
    printf("*%f*\n", RENT);
    printf("*%e*\n", RENT);
    printf("*%4.2f*\n", RENT);
    printf("*%3.1f*\n", RENT);
    printf("*%10.3f*\n", RENT);
    printf("*%10.3E*\n", RENT);
    printf("*%+4.2f*\n", RENT);
    printf("*%010.2f*\n", RENT);
    return 0;
}
```

运行：

```c
*3852.990000*
*3.852990e+03*
*3852.99*
*3853.0*
*  3852.990*
* 3.853E+03*
*+3852.99*
*0003852.99*
```

该程序中使用了 `const` 关键字，限定变量为只读。

- 本例的第 1 个转换说明是 `%f`。在这种情况下，字段宽度和小数点后面的位数均为系统默认设置，即字段宽度是容纳带打印数字所需的位数和小数点后打印 6 位数字。
- 第 2 个转换说明是 `%e`。默认情况下，编译器在小数点的左侧打印 1 个数字，在小数点的右侧打印 6 个数字。这样打印的数字太多！解决方案是指定小数点右侧显示的位数，程序中接下来的 4 个例子就是这样做的。请注意，第 4 个和第 6 个例子对输出结果进行了四舍五入。另外，第 6 个例子用 `E` 代替了 `e`。
- 第 7 个转换说明中包含了 `+` 标记，这使得打印的值前面多了一个代数符号（`+`）。0 标记使得打印的值前面以 0 填充以满足字段要求。注意，转换说明 `%010.2f` 的第 1 个 0 是标记，句点（`.`）之前、标记之后的数字（本例为 10）是指定的字段宽度。尝试修改 `RENT` 的值，看看编译器如何打印不同大小的值。

程序清单 4.9 演示了其他组合。

```c
// 程序清单 4.9 flags.c 程序
/* flags.c -- 演示一些格式标记 */
#include <stdio.h>
int main(void)
{
    printf("%x %X %#x\n", 31, 31, 31);
    printf("**%d**% d**% d**\n", 42, 42, -42);
    printf("**%5d**%5.3d**%05d**%05.3d**\n", 6, 6, 6, 6);
    return 0;
}
```

运行：

```c
1f 1F 0x1f
**42** 42**-42**
**    6**  006**00006**  006**
```

- 第 1 行输出中，`1f` 是十六进制数，等于十进制数 31。第 1 行 `printf()` 语句中，根据 `%x` 打印出 `1f`，`%F` 打印出 `1F`，`%#x` 打印出 `0x1f`。
- 第 2 行输出演示了如何在转换说明中用空格在输出的正值前面生成前导空格，负值前面不产生前导空格。这样的输出结果比较美观，因为打印出来的正值和负值在相同字段宽度下的有效数字位数相同。
- 第 3 行输出演示了如何在整型格式中使用精度（`%5.3d`）生成足够的前导 0 以满足最小位数的要求（本例是 3）。然而，使用 0 标记会使得编译器用前导 0 填充满整个字段宽度。最后，如果 0 标记和精度一起出现，0 标记会被忽略。

下面来看看**字符串格式**的示例。考虑程序清单 4.10 中的程序。

```c
// 程序清单 4.10 stringf.c 程序
/* stringf.c -- 字符串格式 */
#include <stdio.h>
#define BLURB "Authentic imitation!"
int main(void)
{
    printf("[%2s]\n", BLURB);
    printf("[%24s]\n", BLURB);
    printf("[%24.5s]\n", BLURB);
    printf("[%-24.5s]\n", BLURB);
    return 0;
}
```

运行：

```c
[Authentic imitation!]
[    Authentic imitation!]
[                   Authe]
[Authe                   ]
```

注意，虽然第 1 个转换说明是 `%2s`，但是字段被扩大为可容纳字符串中的所有字符。还需注意，精度限制了待打印字符的个数。`.5` 告诉 `printf()` 只打印 5 个字符。另外，`-` 标记使得文本左对齐输出。

### 4.4.4 转换说明的意义

**转换说明**把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。例如，数字 76 在计算机内部的存储格式是二进制数 01001100。

- `%d` 转换说明将其转换成字符 7 和 6，并显示为 76；
- `%x` 转换说明把相同的值（01001100）转换成十六进制记数法 `4c`；
- `%c` 转换说明把 01001100 转换成字符 `L`。

**转换**（conversion）可能会误导读者认为原始值被转替换成转换后的值。实际上，<mark>转换说明是翻译说明</mark>，`%d` 的意思是“把给定的值翻译成十进制整数文本并打印出来”。

#### 1. 转换不匹配

- 首先，`short int` 的大小是 2 字节；其次，系统使用**二进制补码**来表示有符号整数。这种方法，数字 0\~32767 代表它们本身，而数字 32768\~65535 则表示负数。其中，65535 表示 -1，65534 表示 -2，以此类推。
- 一个数字可以被解释成两个不同的值。尽管并非所有的系统都使用这种方法来表示负整数，但要注意一点：别期望用 `%u` 转换说明能把数字和符号分开。
- `short int` 是 2 字节，`char` 是 1 字节。当 `printf()` 使用 `%c` 打印 336 时，它只会查看储存 336 的 2 字节中的后 1 字节。这种截断相当于用一个整数除以 256，只保留其余数。在这种情况下，余数是 80，对应的 ASCII 值是字符 `P`。用专业术语来说，该数字被解释成“以 256 为模”（modulo 256），即该数字除以 256 后取其余数。

#### 2. printf() 的返回值

大部分 C 函数都有一个返回值，这是函数计算并返回给主调程序（calling program）的值。例如，C 库包含一个 `sqrt()` 函数，接受一个数作为参数，并返回该数的平方根。可以把返回值**赋给变量**，也可以用于**计算**，还可以**作为参数传递**。总之，可以把返回值像其他值一样使用。`printf()` 函数也有一个返回值，它返回**打印字符的个数**。注意，计算针对所有字符数，包括**空格**和不可见的**换行符**（`\n`）。如果有输出错误，`printf()` 则返回一个**负值**（`printf()` 的旧版本会返回不同的值）。

`printf()` 的返回值是其打印输出功能的附带用途，通常很少用到，但在检查输出错误时可能会用到（如，在写入文件时很常用）。

#### 3. 打印较长的字符串

有时，`printf()` 语句太长，在屏幕上不方便阅读。如果**空白**（空格、制表符、换行符）仅用于分隔不同的参数，C 编译器会忽略它们。因此，一条语句可以写成多行，只需在不同部分之间输入空白即可。

但是，<mark>不能在双引号括起来的字符串中间断行</mark>。否则，C 编译器会报错：字符串常量中有**非法字符**。在字符串中，可以使用 `\n` 来表示换行字符，但是不能通过按下 Enter（或 Return）键产生实际的换行符。

给字符串断行有 3 种方法，如程序清单 4.14 所示。

```c
// 程序清单 4.14 longstrg.c 程序
/* longstrg.c ––打印较长的字符串 */
#include <stdio.h>
int main(void)
{
    printf("Here's one way to print a ");
    printf("long string.\n");
    printf("Here's another way to print a \
        long string.\n");
    printf("Here's the newest way to print a "
        "long string.\n"); /* ANSI C */
    return 0;
}
```

运行：

```c
Here's one way to print a long string.
Here's another way to print a         long string.
Here's the newest way to print a long string.
```

- 方法 1：使用多个 `printf()` 语句。因为第 1 个字符串没有以 `\n` 字符结束，所以第 2 个字符串紧跟第 1 个字符串末尾输出。
- 方法 2：用反斜杠（`\`）和 Enter（或 Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，<mark>下一行代码必须和程序清单中的代码一样从最左边开始</mark>。如果缩进该行，比如缩进 5 个空格，那么这 5 个空格就会成为字符串的一部分。
- 方法 3：ANSI C 引入的**字符串连接**。在两个用双引号括起来的字符串之间用空白隔开，C 编译器会把多个字符串看作是一个字符串。因此，以下 3 种形式是等效的：

```c
printf("Hello, young lovers, wherever you are.");
printf("Hello, young " "lovers" ", wherever you are.");
printf("Hello, young lovers"
    ", wherever you are.");
```

上述方法中，<mark>要记得在字符串中包含所需的空格</mark>。如，`"young""lovers"` 会成为 `"younglovers"`，而 `"young " "lovers"` 才是 `"younglovers"`。

### 4.4.5 使用 scanf()

C 库包含了多个**输入函数**，`scanf()` 是最通用的一个，因为它可以读取不同格式的数据。当然，从键盘输入的都是文本，因为键盘只能生成文本字符：字母、数字和标点符号。如果要输入整数 2014，就要键入字符 2、0、1、4。如果要将其储存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是 `scanf()` 要做的。`scanf()` 把输入的字符串转换成整数、浮点数、字符或字符串，而 `printf()` 正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上的文本。

`scanf()` 和 `printf()` 类似，也使用**格式字符串**和**参数列表**。`scanf()` 中的格式字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表中。`printf()` 函数使用变量、常量和表达式，而 `scanf()` 函数使用**指向变量的指针**。

- 如果用 `scanf()` 读取基本变量类型的值，在变量名前加上一个 `&`；
- <mark>如果用 scanf() 把字符串读入字符数组中，不要使用 &</mark>。

程序清单 4.15 中的小程序演示了这两条规则。

```c
// 程序清单 4.15 input.c 程序
// input.c -- 何时使用 &
#include <stdio.h>
int main(void)
{
    int age; // 变量
    float assets; // 变量
    char pet[30]; // 字符数组，用于储存字符串

    printf("Enter your age, assets, and favorite pet.\n");
    scanf("%d %f", &age, &assets); // 这里要使用 &
    scanf("%s", pet); // 字符数组不使用 &
    printf("%d $%.2f %s\n", age, assets, pet);
    return 0;
}
```

运行：

```c
Enter your age, assets, and favorite pet.
38
92360.88 llama
38 $92360.88 llama
```

`scanf()` 函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。注意，上面示例的输入项（粗体部分是用户的输入）分成了两行。<mark>只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入</mark>：

```c
Enter your age, assets, and favorite pet.
42
2121.45
guppy
42 $2121.45 guppy
```

<mark>唯一例外的是 %c 转换说明。根据 %c，scanf() 会读取每个字符，包括空白</mark>。

`scanf()` 函数所用的转换说明与 `printf()` 函数几乎相同。主要的区别是，对于 `float` 类型和 `double` 类型，`printf()` 都使用`%f`、`%e`、`%E`、`%g` 和 `%G` 转换说明。而 `scanf()` 只把它们用于 `float` 类型，对于 `double` 类型时要使用 `l` 修饰符。表 4.6 列出了 C99 标准中常用的转换说明。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\scanf转换说明.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 4.6 ANSI C 中 scanf() 的转换说明</div>
</div>

可以在表 4.6 所列的转换说明中（百分号和转换字符之间）使用修饰符。如果要使用多个修饰符，必须按表 4.7 所列的顺序书写。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\scanf修饰符.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 4.7 scanf() 转换说明中的修饰符</div>
</div>

使用转换说明比较复杂，而且这些表中还省略了一些特性。省略的主要特性是，从高度格式化源中读取选定数据，如穿孔卡或其他数据 z 记录。因为在本书中，`scanf()` 主要作为与程序交互的便利工具，所以我们不在书中讨论更复杂的特性。

#### 1. 从 scanf() 角度看输入

假设 `scanf()` 根据一个 `%d` 转换说明读取一个整数。`scanf()` 函数每次读取一个字符，跳过所有的空白字符，直至遇到第 1 个非空白字符才开始读取。因为要读取整数，所以 `scanf()` 希望发现一个数字字符或者一个符号（`+` 或 `-`）。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。`scanf()` 不断地读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后，`scanf()` 把非数字字符放回输入。<mark>这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符</mark>。最后，`scanf()` 计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。

如果使用**字段宽度**，`scanf()` 会在字段结尾或第 1 个空白字符处停止读取（满足两个条件之一便停止）。

如果第 1 个非空白字符是 A 而不是数字，会发生什么情况？`scanf()` 将停在那里，并把 A 放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是 A。如果程序只使用 `%d` 转换说明， `scanf()` 就一直无法越过 A 读下一个字符。<mark>另外，如果使用带多个转换说明的 scanf()，C 规定在第 1 个出错处停止读取输入</mark>。

用其他数值匹配的转换说明读取输入和用 `%d` 的情况相同。区别在于 `scanf()` 会把更多字符识别成数字的一部分。例如，`%x` 转换说明要求 `scanf()` 识别十六进制数 a\~f 和 A\~F。浮点转换说明要求 `scanf()` 识别小数点、e 记数法（指数记数法）和新增的 p 记数法（十六进制指数记数法）。

如果使用 `%s` 转换说明，`scanf()` 会读取除空白以外的所有字符。`scanf()` 跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着 `scanf()` 根据 `%s` 转换说明读取一个单词，即不包含空白字符的字符串。如果使用字段宽度，`scanf()` 在字段末尾或第 1 个空白字符处停止读取。无法利用字段宽度让只有一个 `%s` 的 `scanf()` 读取多个单词。最后要注意一点：当 `scanf()` 把字符串放进指定数组中时，它会在字符序列的末尾加上 `'\0'`，让数组中的内容成为一个 C 字符串。

实际上，在 C 语言中 `scanf()` 并不是最常用的输入函数。这里重点介绍它是因为它能读取不同类型的数据。C 语言还有其他的输入函数，如 `getchar()` 和 `fgets()`。这两个函数更适合处理一些特殊情况，如**读取单个字符**或**包含空格的字符串**。

#### 2. 格式字符串中的普通字符

`scanf()` 函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗号：

```c
scanf("%d,%d", &n, &m);
```

`scanf()` 函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像下面这样进行输入两个整数：

```c
88,121
```

由于格式字符串中，`%d` 后面紧跟逗号，所以必须在输入 88 后再输入一个逗号。但是，由于 `scanf()` 会跳过整数前面的空白，所以下面两种输入方式都可以：

```c
88, 121
88,
121
```

格式字符串中的空白意味着跳过下一个输入项前面的所有空白。例如，对于下面的语句：

```c
scanf("%d ,%d", &n, &m);
```

- 以下的输入格式都没问题：

```c
88,121
88 ,121
88 , 121
```

<mark>请注意，“所有空白”的概念包括没有空格的特殊情况</mark>。

除了 `%c`，其他转换说明都会自动跳过待输入值前面所有的空白。因此，`scanf("%d%d", &n, &m)` 与 `scanf("%d %d", &n, &m)` 的行为相同。对于 `%c`，在格式字符串中添加一个空格字符会有所不同。例如，如果把 `%c` 放在格式字符串中的空格前面，`scanf()` 便会跳过空格，从第 1 个非空白字符开始读取。也就是说，`scanf("%c", &ch)` 从输入中的第 1 个字符开始读取，而 `scanf(" %c", &ch)` 则从第 1 个非空白字符开始读取。

#### 3. scanf() 的返回值

- `scanf()` 函数返回成功读取的项数。
- 如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，`scanf()` 便返回 0。
- 当 `scanf()` 检测到“文件结尾”时，会返回 `EOF`（`EOF` 是 `stdio.h` 中定义的特殊值，通常用 `#define` 指令把 `EOF` 定义为 `-1`）。

### 4.4.6 printf() 和 scanf() 的 \* 修饰符

`printf()` 和 `scanf()` 都可以使用 `*` 修饰符来修改转换说明的含义。但是，它们的用法不太一样。

首先，我们来看 `printf()` 的 `*` 修饰符。如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用 `*` 修饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。也就是说，如果转换说明是 `%*d`，那么参数列表中应包含 `*` 和 `d` 对应的值。这个技巧也可用于浮点值指定精度和字段宽度。程序清单 4.16 演示了相关用法。

```c
// 程序清单4.16 varwid.c程序
/* varwid.c -- 使用变宽输出字段 */
#include <stdio.h>
int main(void)
{
    unsigned width, precision;
    int number = 256;
    double weight = 242.5;

    printf("Enter a field width:\n");
    scanf("%d", &width);
    printf("The number is :%*d:\n", width, number);
    printf("Now enter a width and a precision:\n");
    scanf("%d %d", &width, &precision);
    printf("Weight = %*.*f\n", width, precision, weight);
    printf("Done!\n");

    return 0;
}
```

运行：

```c
Enter a field width:
6
The number is : 256:
Now enter a width and a precision:
8 3
Weight = 242.500
Done!
```

变量 `width` 提供字段宽度，`number` 是待打印的数字。因为转换说明中 `*` 在 `d` 的前面，所以在 `printf()` 的参数列表中，`width` 在 `number` 的前面。同样，`width` 和 `precision` 提供打印 `weight` 的格式化信息。

这里，用户首先输入 6，因此 6 是程序使用的字段宽度。类似地，接下来用户输入 8 和 3，说明字段宽度是 8，小数点后面显示 3 位数字。一般而言，程序应根据 `weight` 的值来决定这些变量的值。

`scanf()` 中 `*` 的用法与此不同。把 `*` 放在 `%` 和转换字符之间时，会使得 `scanf()` 跳过相应的输出项。程序清单 4.17 就是一个例子。

```c
// 程序清单4.17 skip2.c程序
/* skiptwo.c -- 跳过输入中的前两个整数 */
#include <stdio.h>
int main(void)
{
    int n;

    printf("Please enter three integers:\n");
    scanf("%*d %*d %d", &n);
    printf("The last integer was %d\n", n);

    return 0;
}
```

运行：

```c
Please enter three integers:
2013 2014 2015
226
The last integer was 2015
```

程序清单 4.17 中的 `scanf()` 指示：跳过两个整数，把第 3 个整数拷贝给 n。在程序需要读取文件中特定列的内容时，这项跳过功能很有用。

### 4.4.7 printf() 的用法提示

想把数据打印成列，指定固定字段宽度很有用。因为默认的字段宽度是待打印数字的宽度，如果同一列中打印的数字位数不同，打印出来的数字可能参差不齐。

使用足够大的固定字段宽度可以让输出整齐美观。例如，若使用下面的语句：

```c
printf("%9d %9d %9d\n", val1, val2, val3);
```

运行示例：

```c
       12       234      1222
        4         5        23
    22334      2322     10001
```

在两个转换说明中间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟该数字一起输出（这样两个数字看起来像是一个数字）。这是因为格式字符串中的普通字符（包括空格）会被打印出来。

另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便。这样，输出数字的宽度正合适，没有不必要的空白。

## 4.5 关键概念

C 语言用 `char` 类型表示单个字符，用字符串表示字符序列。**字符常量**是一种字符串形式，即用双引号把字符括起来：`"Good luck, my friend"`。可以把字符串储存在**字符数组**（由内存中相邻的字节组成）中。字符串，无论是表示成字符常量还是储存在字符数组中，都以一个叫做空字符的隐藏字符结尾。

在程序中，最好用 `#define` 定义**数值常量**，用 `const` 关键字声明的变量为**只读变量**。在程序中使用**符号常量**（**明示常量**），提高了程序的可读性和可维护性。

C 语言的标准输入函数（`scanf()`）和标准输出函数（`printf()`）都使用一种系统。在该系统中，第 1 个参数中的转换说明必须与后续参数中的值相匹配。例如，`int` 转换说明 `%d` 与一个浮点值匹配会产生奇怪的结果。必须格外小心，确保转换说明的数量和类型与函数的其余参数相匹配。对于 `scanf()`，一定要记得在变量名前加上地址运算符（`&`）。

空白字符（制表符、空格和换行符）在 `scanf()` 处理输入时起着至关重要的作用。除了 `%c` 模式（读取下一个字符），`scanf()` 在读取输入时会跳过非空白字符前的所有空白字符，然后一直读取字符，直至遇到空白字符或与正在读取字符不匹配的字符。考虑一下，如果 `scanf()` 根据不同的转换说明读取相同的输入行，会发生什么情况。假设有如下输入行：

```c
  -13.45e12# 0
```

如果其对应的转换说明是 `%d`，`scanf()` 会读取 3 个字符（`-13`）并停在小数点处，小数点将被留在输入中作为下一次输入的首字符。如果其对应的转换说明是 `%f`，`scanf()` 会读取 `-13.45e12`，并停在 `#` 符号处，而 `#` 将被留在输入中作为下一次输入的首字符；然后，`scanf()` 把读取的字符序列 `-13.45e12` 转换成相应的浮点值，并储存在 `float` 类型的目标变量中。如果其对应的转换说明是 `%s`，`scanf()` 会读取 `-13.45e12#`，并停在空格处，空格将被留在输入中作为下一次输入的首字符；然后，`scanf()` 把这 10 个字符的字符码储存在目标字符数组中，并在末尾加上一个空字符。如果其对应的转换说明是 `%c`，`scanf()`只会读取并储存第 1 个字符，该例中是一个空格。

## 4.6 本章小结

字符串是一系列被视为一个处理单元的字符。在 C 语言中，字符串是以空字符（ASCII 码是 0）结尾的一系列字符。可以把字符串储存在字符数组中。数组是一系列同类型的项或元素。下面声明了一个名为 `name`、有 30 个 `char` 类型元素的数组：

```c
char name[30];
```

要确保有足够多的元素来储存整个字符串（包括空字符）。

字符串常量是用双引号括起来的字符序列，如：`"This is an example of astring"`。

`scanf()` 函数（声明在 `string.h` 头文件中）可用于获得字符串的长度（末尾的空字符不计算在内）。`scanf()` 函数中的转换说明是 `%s` 时，可读取一个单词。

C 预处理器为预处理器指令（以 `#` 符号开始）查找源代码程序，并在开始编译程序之前处理它们。处理器根据 `#include` 指令把另一个文件中的内容添加到该指令所在的位置。`#define` 指令可以创建明示常量（符号常量），即代表常量的符号。`limits.h` 和 `float.h` 头文件用 `#define` 定义了一组表示整型和浮点型不同属性的符号常量。另外，还可以使用 `const` 限定符创建定义后就不能修改的变量。

`printf()` 和 `scanf()` 函数对输入和输出提供多种支持。两个函数都使用格式字符串，其中包含的转换说明表明待读取或待打印数据项的数量和类型。另外，可以使用转换说明控制输出的外观：字段宽度、小数位和字段内的布局。
