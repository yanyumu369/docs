本章介绍以下内容：

- C 的历史和特性
- 编写程序的步骤
- 编译器和链接器的一些知识

#### C 语言的起源

1972 年，贝尔实验室的**丹尼斯·里奇**（Dennis Ritch）和**肯·汤普逊**（Ken Thompson）在开发 **UNIX** 操作系统时设计了 C 语言。

#### 嵌入式编程

C 语言已成为**嵌入式系统编程**的流行语言。也就是说，越来越多的汽车、照相机、DVD 播放机和其他现代化设备的**微处理器**都用 C 语言进行编程。

#### CPU 与寄存器

CPU 从内存中获取并执行一条指令，然后再从内存中获取并执行下一条指令（一个 GHz 的 CPU 一秒钟能重复这样的操作大约十亿次）。CPU 中的小工作区由若干个**寄存器**组成，每个寄存器都可以储存一个数字。一个寄存器储存下一条指令的内存地址，CPU 使用该地址来获取和更新下一条指令。在获取指令后，CPU 在另一个寄存器中储存该指令，并更新第 1 个寄存器储存下一条指令的地址。CPU 能理解的指令有限（这些指令的集合叫作**指令集**）。而且，这些指令相当具体，其中的许多指令都是用于请求计算机把一个数字从一个位置移动到另一个位置。例如，从内存移动到寄存器。

#### C 语言标准

C 语言发展之初，并没有所谓的 C 标准。1987 年，**布莱恩·柯林汉**（Brian Kernighan）和**丹尼斯·里奇**（Dennis Ritchie）合著的**TheCProgramming Language**（《C 语言程序设计》）第 1 版是公认的 C 标准，通常称之为 **K&R C** 或**经典 C**。特别是，该书中的附录中的“C 语言参考手册”已成为实现 C 的指导标准。例如，编译器都声称提供完整的 K&R 实现。虽然这本书中的附录定义了 C 语言，但却没有定义 C 库。与大多数语言不同的是，C 语言比其他语言更依赖库，因此需要一个**标准库**。实际上，由于缺乏官方标准，UNIX 实现提供的库已成为了标准库。

**美国国家标准协会（American National Standards Institute, ANSI）**于 **1983** 年组建了一个委员会（X3J11），开发了一套新标准，并于 1989 年正式公布。该标准（**ANSI C**）定义了 C 语言和 C 标准库。**国际标准化组织**于 1990 年采用了这套 C 标准（**ISO C**）。ISO C 和 ANSI C 是完全相同的标准。ANSI/ISO 标准的最终版本通常叫作 **C89**（因为 ANSI 于 1989 年批准该标准）或 **C90**（因为 ISO 于 1990 年批准该标准）。另外，由于 ANSI 先公布 C 标准，因此业界人士通常使用 **ANSI C**。

标准委员会在 2007 年承诺 C 标准的下一个版本是 **C1X**，2011 年终于发布了 **C11 标准**。

#### 汇编语言 & 编译器 & 编译

**汇编语言**是为特殊的中央处理单元设计的一系列内部**指令**，使用**助记符**来表示；不同的 CPU 系列使用不同的汇编语言。

**编译器**是把**高级语言程序**翻译成计算机能理解的**机器语言指令集**的程序。

编译器是把**源代码**转换成**可执行代码**的程序。可执行代码是用计算机的机器语言表示的代码。这种语言**由数字码表示的指令组成**。<mark>不同的计算机使用不同的机器语言方案</mark>。C 编译器负责把 C 代码翻译成特定的机器语言。此外，C 编译器还将源代码与 C 库（库中包含大量的**标准函数**供用户使用，如`printf()`和 `scanf()`）的代码合并成最终的程序（更精确地说，应该是由一个被称为**链接器**的程序来链接库函数，但是在大多数系统中，编译器运行链接器）。其结果是，生成一个用户可以运行的**可执行文件**，其中包含着计算机能理解的代码。

用 C 语言编写程序时，编写的内容被储存在**文本文件**中，该文件被称为**源代码文件**（source code file）。大部分 C 系统，包括之前提到的，都要求**文件名以 .c 结尾**（如，wordcount.c 和 budget.c）。在文件名中，点号（.）前面的部分称为**基本名**（basename），点号后面的部分称为**扩展名**（extension）。因此，budget 是基本名，c 是扩展名。基本名与扩展名的组合（budget.c）就是**文件名**。

#### 目标代码文件、可执行文件和库

**C 编程的基本策略是，用程序把源代码文件转换为可执行文件（其中包含可直接运行的机器语言代码）**。典型的 C 实现通过**编译**和**链接**两个步骤来完成这一过程。**编译器把源代码转换成中间代码，链接器把中间代码和其他代码合并，生成可执行文件**。C 使用这种分而治之的方法方便对程序进行**模块化**，可以独立编译单独的模块，稍后再用链接器合并已编译的模块。通过这种方式，如果只更改某个模块，不必因此重新编译其他模块。**另外，链接器还将你编写的程序和预编译的库代码合并**。

**中间文件**有多种形式。这里描述的是最普遍的一种形式，即把**源代码**转换为**机器语言代码**，并把结果放在**目标代码文件**（或简称**目标文件**）中（这里假设源代码只有一个文件）。虽然目标文件中包含机器语言代码，但是并不能直接运行该文件。因为目标文件中储存的是编译器翻译的源代码，这还不是一个完整的程序。

**目标代码文件缺失启动代码**（startup code）。**启动代码充当着程序和操作系统之间的接口**。例如，Windows 和 Linux 所需的启动代码不同，因为这些系统处理程序的方式不同。

**目标代码还缺少库函数**。几乎所有的 C 程序都要使用 C 标准库中的函数。例如，目标代码文件并不包含 `printf()` 函数的代码，它只包含了使用 `printf()` 函数的指令。`printf()` 函数真正的代码储存在另一个被称为**库**的文件中。**库文件**中有许多函数的目标代码。**链接器的作用是，把你编写的目标代码、系统的标准启动代码和库代码这 3 部分合并成一个文件，即可执行文件**。**对于库代码，链接器只会把程序中要用到的库函数代码提取出来**。

<div align=center>
<img width="60%" src="\programme\C_C++\C_primer_plus\image\编译器和连接器.png"/> <br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 编译器和链接器。</div>
</div>

**简而言之，目标文件和可执行文件都由机器语言指令组成的。然而，目标文件中只包含编译器为你编写的代码翻译的机器语言代码，可执行文件中还包含你编写的程序中使用的库函数和启动代码的机器代码**。

在有些系统中，必须分别运行编译程序和链接程序，而在另一些系统中，编译器会自动启动链接器，用户只需给出编译命令即可。

#### 在 Unix 系统上编译

如果编译器报告 void 的错误，说明你的系统未更新成 ANSI C 编译器，只需删除 void 即可。

<div align=center>
<img width="30%" src="\programme\C_C++\C_primer_plus\image\用Unix准备C程序.png"/> <br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 用Unix准备C程序。</div>
</div>

如果要储存**可执行文件**（a.out），应该把它**重命名**。否则，该文件会被下一次编译程序时生成的新 a.out 文件替换。

如何处理目标代码？C 编译器会创建一个与源代码基本名相同的目标代码文件，但是其扩展名是 .o。在该例中，目标代码文件是 inform.o。然而，却找不到这个文件，**因为一旦链接器生成了完整的可执行程序，就会将其删除**。如果原始程序有多个源代码文件，则保留目标代码文件。

#### GNU 编译器集合

GNU 项目始于 1987 年，是一个开发大量免费 UNIX 软件的集合（GNU 的意思是“GNU's Not UNIX”，即 GNU 不是 UNIX）。**GNU 编译器集合**（也被称为 **GCC**，其中包含**GCC C 编译器**）是该项目的产品之一。用 `gcc` 命令便可调用 GCC C 编译器。许多使用`gcc`的系统都用 `cc` 作为 `gcc` 的别名。

`gcc` 可以根据不同的**版本**选择运行时选项来调用不同 C 标准：

1. `gcc -std=c99 inform.c`
2. `gcc -std=c1x inform.c`
3. `gcc -std=c11 inform.c`

#### PC 的命令行编译

MinGW 在 Windows 的**命令提示模式**中运行。

源代码文件应该是**文本文件**，不是**字处理器文件**（字处理器文件包含许多额外的信息，如字体和格式等）。因此，要使用**文本编辑器**（如，Windows Notepad）来编辑源代码。如果使用字处理器，要以文本模式另存文件。源代码文件的扩展名应该是 .c。一些字处理器会为文本文件自动添加 .txt 扩展名。如果出现这种情况，要更改文件名，把 txt 替换成 c。

通常，C 编译器生成的**中间目标代码文件**的扩展名是 .obj（也可能是其他扩展名）。与 UNIX 编译器不同，这些编译器在完成编译后通常不会删除这些中间文件。

#### 击键等待

程序的输出是否在屏幕上一闪而过？某些窗口环境会在单独的窗口运行程序，然后在程序运行结束后自动关闭窗口。如果遇到这种情况，可以在序中添加额外的代码，让窗口等待用户按下一个键后才关闭。一种方法是，在程序的 `return` 语句前添加一行代码：`getchar()；` 这行代码会让程序等待击键，窗口会在用户按下一个键后才关闭。有时根据程序的需要，可能还需要一个击键等待。这种情况下，必须用两次 `getchar();`。第 1 个 `getchar()` 读取换行符，第 2 个 `getchar()` 让程序暂停，等待输入。

#### 本书的约定

1. 本书用类似在屏幕上或打印输出时的字体（一种**等宽字体**），表示**文本程序和计算机输入、输出**。在涉及与代码相关的术语时，也使用相同的等宽字体。本书用**等宽斜体**表示**占位符**，可以用具体的项替换这些占位符。
2. 本书用相同的字体表示计算机的输出，**粗体**表示用户输入。
3. 一般情况下，我们默认你在每行输入的末尾都会按下 Enter 键。尽管如此，为了标示一些特定的位置，本书使用 [enter] 显式标出 Enter 键。方括号表示按下一次 Enter 键，而不是输入 enter。

#### 本书使用的系统

C 语言的某些方面（如，储存数字的空间大小）因系统而异。本书在示例中提到“我们的系统”时，通常是指**在 iMac 上运行 OS X 10.8.4，使用 Xcode4.6.2 开发系统的 Clang 3.2 编译器**。本书的大部分程序都能使用 Windows7 系统的 Microsoft Visual Studio Express 2012 和 C7.0，以及 **Ubuntu13.04 Linux 系统的 GCC 4.7.3** 进行编译。
