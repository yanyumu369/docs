本章介绍以下内容：

- 关键字：`for`、`while`、`do while`
- 运算符：`<`、`>`、`>=`、`<=`、`!=`、`==`、`+=`、`*=`、`-=`、`/=`、`%=`
- 函数：`fabs()`
- C 语言有 3 种循环：`for`、`while`、`do while`
- 使用**关系运算符**构建控制循环的表达式
- 其他运算符
- 循环常用的数组
- 编写有**返回值**的函数

编写好的 C 程序的诀窍是控制程序流。对于**计算机科学**（是研究计算机，不是用计算机做研究）而言，一门语言应该提供以下 3 种形式的程序流：

- 执行**语句序列**；
- 如果满足某些条件就重复执行语句序列（**循环**）
- 通过测试选择执行哪一个语句序列（**分支**）。

读者对第一种形式应该很熟悉，前面学过的程序中大部分都是由**语句序列**组成。`while` 循环属于第二种形式。本章将详细讲解 `while` 循环和其他两种循环：`for` 和 `do while`。第三种形式用于在不同的执行方案之间进行选择，让程序更“智能”，且极大地提高了计算机的用途。不过，要等到下一章才介绍这部分的内容。本章还将介绍**数组**，可以把新学的知识应用在数组上。另外，本章还将继续介绍函数的相关内容。首先，我们从 `while` 循环开始学习。

## 6.1 再探 while 循环

程序清单 6.1 根据用户从键盘输入的整数进行求和。程序利用了 `scanf()` 的返回值来结束循环。

```c
// 程序清单6.1 summing.c程序
/* summing.c -- 根据用户键入的整数求和 */
#include <stdio.h>
int main(void)
{
    long num;
    long sum = 0L; /* 把sum初始化为0 */
    int status;

    printf("Please enter an integer to be summed ");
    printf("(q to quit): ");
    status = scanf("%ld", &num);
    while (status == 1) /* == 的意思是“等于” */
    {
        sum = sum + num;
        printf("Please enter next integer (q to quit): ");
        status = scanf("%ld", &num);
    }
    printf("Those integers sum to %ld.\n", sum);

    return 0;
}
```

运行：

```c
Please enter an integer to be summed (q to quit): 44
Please enter next integer (q to quit): 33
Please enter next integer (q to quit): 88
Please enter next integer (q to quit): 121
Please enter next integer (q to quit): q
Those integers sum to 286.
```

该程序使用 `long` 类型以储存更大的整数。尽管 C 编译器会把 `0` 自动转换为合适的类型，但是为了保持程序的一致性，我们把 `sum` 初始化为 `0L`（`long` 类型的 `0`），而不是 `0`（`int` 类型的 `0`）。

### 6.1.1 程序注释

先看 `while` 循环，该循环的测试条件是如下表达式：

```c
status == 1
```

`==` 运算符是 C 的**相等运算符**（equality operator），该表达式判断 `status` 是否等于 `1`。根据测试条件 `status == 1`，只要 `status` 等于 1，循环就会重复。

`scanf()` 返回成功读取项的数量。如果 `scanf()` 成功读取一个整数，就把该数存入 `num` 并返回 `1`，如果用户输入的不是数字（如， `q`），`scanf()` 会读取失败并返回 `0`。此时，`status` 的值就是 `0`，循环结束。因为输入的字符 `q` 不是数字，所以它会被放回输入队列中（实际上，不仅仅是 `q`，任何非数值的数据都会导致循环终止，但是提示用户输入 `q` 退出程序比提示用户输入一个非数字字符要简单）。

如果 `scanf()` 在转换值之前出了问题（例如，检测到**文件结尾**或遇到**硬件问题**），会返回一个特殊值 `EOF`（其值通常被定义为 `-1`）。这个值也会引起循环终止。

**伪代码**（pseudocode），是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应。伪代码有助于设计程序的逻辑。确定程序的逻辑无误之后，再把伪代码翻译成实际的编程代码。使用伪代码的好处之一是，可以把注意力集中在程序的组织和逻辑上，不用在设计程序时还要分心如何用编程语言来表达自己的想法。例如，可以用缩进来代表一块代码，不用考虑 C 的语法要用花括号把这部分代码括起来。

### 6.1.2 C 循环读取循环

下面的代码：

```c
status = scanf("%ld", &num);
while (status == 1)
{
    /* 循环行为 */
    status = scanf("%ld", &num);
}
```

可以用这些代码替换：

```c
while (scanf("%ld", &num) == 1)
{
    /*循环行为*/
}
```

第二种形式同时使用 `scanf()` 的两种不同的特性。首先，如果函数调用成功，`scanf()` 会把一个值存入 `num`。然后，利用 `scanf()` 的返回值（`0` 或 `1`，不是 `num` 的值）控制 `while` 循环。因为每次迭代都会判断循环的条件，所以每次迭代都要调用 `scanf()` 读取新的 `num` 值来做判断。换句话说，C 的语法特性让你可以用下面的精简版本替换标准版本：

```c
当获取值和判断值都成功
    处理该值
```

接下来，我们正式地学习 `while` 语句。

## 6.2 while 语句

`while` 循环的通用形式如下：

```c
while ( expression )
    statement
```

`statement` 部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。

到目前为止，程序示例中的 `expression` 部分都使用**关系表达式**。也就是说，`expression` 是值之间的比较，可以使用任何表达式。如果 `expression` 为真（或者更一般地说，非零），执行 `statement` 部分一次，然后再次判断 `expression`。在 `expression` 为假（`0`）之前，循环的判断和执行一直重复进行。每次循环都被称为一次**迭代**（iteration）。

### 6.2.1 终止 while 循环

`while` 循环有一点非常重要：在构建 `while` 循环时，必须让测试表达式的值有变化，表达式最终要为假。否则，循环就不会终止（实际上，可以使用 `break` 和 `if` 语句来终止循环）。

### 6.2.2 何时终止循环

要明确一点：只有在对测试条件求值时，才决定是终止还是继续循环。

### 6.2.3 while：入口条件循环

`while` 循环是使用**入口条件**的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件，如 `(index < 5)`。该表达式是一个**入口条件**（entry condition），因为必须满足条件才能进入循环体。

### 6.2.4 语法要点

使用 `while` 时，要牢记一点：只有在测试条件后面的**单独语句**（简单语句或复合语句）才是循环部分。

记住，即使 `while` 语句本身使用**复合语句**，在语句构成上，它也是一条单独的语句。该语句从 `while` 开始执行，到第 1 个分号结束。在使用了复合语句的情况下，到右花括号结束。

```c
while (n++ < 3);
```

在该例中，测试条件后面的单独分号是**空语句**（null statement），它什么也不做。在 C 语言中，单独的分号表示空语句。有时，程序员会故意使用带空语句的 `while` 语句，因为所有的任务都在测试条件中完成了，不需要在循环体中做什么。例如，假设你想跳过输入到第 1 个非空白字符或数字，可以这样写：

```c
while (scanf("%d", &num) == 1)
    ; /* 跳过整数输入 */
```

只要 `scanf()` 读取一个整数，就会返回 1，循环继续执行。注意，为了提高代码的可读性，应该让这个分号独占一行，不要直接把它放在测试表达式同行。这样做一方面让读者更容易看到空语句，一方面也提醒自己和读者空语句是有意而为之。处理这种情况更好的方法是使用下一章介绍的 `continue` 语句。

## 6.3 用关系运算符和表达式比较大小

`while` 循环经常依赖测试表达式作比较，这样的表达式被称为**关系表达式**（relational expression），出现在关系表达式中间的运算符叫做**关系运算符**（relational operator）。前面的示例中已经用过一些关系运算符，表 6.1 列出了 C 语言的所有关系运算符。该表也涵盖了所有的数值关系。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\关系运算符.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;">  表 6.1 关系运算符
</div>
</div>

关系运算符常用于构造 `while` 语句和其他 C 语句（稍后讨论）中用到的关系表达式。这些语句都会检查关系表达式为真还是为假。

`while` 语句的关系表达式还可用于比较字符。比较时使用的是**机器字符码**（假定为 ASCII）。<mark>但是，不能用关系运算符比较字符串</mark>。第 11 章将介绍如何比较字符串。

虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽量只使用 `<` 和 `>`。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。例如，3 乘以 1/3 的积是 1.0。如果用把 1/3 表示成小数点后面 6 位数字，乘积则是 .999999，不等于 1。使用 `fabs()` 函数（声明在 `math.h` 头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即，没有代数符号的值）。

### 6.3.1 什么是真

在 C 中，表达式一定有一个值，关系表达式也不例外。

对 C 而言，表达式为真的值是 1，表达式为假的值是 0。

### 6.3.2 其他真值

既然 1 或 0 可以作为 `while` 语句的测试表达式，是否还可以使用其他数字？一般而言，所有的非零值都视为真，只有 0 被视为假。

也可以说，只要测试条件的值为**非零**，就会执行 `while` 循环。这是从数值方面而不是从真/假方面来看测试条件。要牢记：关系表达式为真，求值得 1；关系表达式为假，求值得 0。因此，这些表达式实际上相当于数值。

许多 C 程序员都会很好地利用测试条件的这一特性。例如，用 `while(goats)` 替换 `while (goats !=0)`，因为表达式 `goats != 0` 和 `goats` 都只有在 `goats` 的值为 0 时才为 0 或假。第 1 种形式（`while (goats != 0)`）对初学者而言可能比较清楚，但是第 2 种形式（`while (goats)`）才是 C 程序员最常用的。要想成为一名 C 程序员，应该多熟悉 `while (goats)` 这种形式。

### 6.3.3 真值的问题

```c
status = scanf("%ld", &num);
```

如果 `scanf()` 读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取。当 `scanf()` 把 `q` 作为整数读取时失败了，它把 `q` 留下。在下次循环时，`scanf()` 从上次读取失败的地方（`q`）开始读取，`scanf()` 把 `q` 作为整数读取，又失败了。

如果待比较的一个值是常量，可以把该常量放在左侧有助于编译器捕获错误：

```c
5 = canoes      // 语法错误
5 == canoes     // 检查 canoes 的值是否为 5
```

可以这样做是因为 C 语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。

总之，关系运算符用于构成关系表达式。关系表达式为真时值为 1，为假时值为 0。通常用关系表达式作为测试条件的语句（如 `while` 和 `if`）可以使用任何表达式作为测试条件，非零为真，零为假。

### 6.3.4 新的 \_Bool 类型

在 C 语言中，一直用 `int` 类型的变量表示真/假值。C99 专门针对这种类型的变量新增了 `_Bool` 类型。该类型是以英国数学家 George Boole 的名字命名的，他开发了用代数表示逻辑和解决逻辑问题。在编程中，表示真或假的变量被称为**布尔变量**（Boolean variable），所以 `_Bool` 是 C 语言中布尔变量的类型名。`_Bool` 类型的变量只能储存 1（真）或 0（假）。如果把其他非零数值赋给 `_Bool` 类型的变量，该变量会被设置为 1。这反映了 C 把所有的非零值都视为真。

C99 提供了 `stdbool.h` 头文件，该头文件让 `bool` 成为 `_Bool` 的别名，而且还把 `true` 和 `false` 分别定义为 1 和 0 的符号常量。包含该头文件后，写出的代码可以与 C++ 兼容，因为 C++ 把 `bool`、`true` 和 `false` 定义为关键字。

如果系统不支持 `_Bool` 类型，导致无法运行该程序，可以把 `_Bool` 替换成 `int` 即可。

### 6.3.5 优先级和关系运算符

关系运算符的优先级比算术运算符（包括 `+` 和 `-`）低，比赋值运算符高。这意味着 `x > y + 2` 和 `x > (y + 2)` 相同，`x = y > 2` 和 `x = (y > 2)` 相同。换言之，如果 `y` 大于 2，则给 `x` 赋值 1，否则赋值 0。`y` 的值不会赋给 `x`。

关系运算符之间有两种不同的优先级。

- 高优先级组： `<` `<=` `>` `>=`
- 低优先级组： `==` `!=`

与其他大多数运算符一样，**关系运算符的结合律也是从左往右**。因此：

```c
ex != wye == zee 与 (ex != wye) == zee 相同
```

首先，C 判断 `ex` 与 `wye` 是否相等；然后，用得出的值 1 或 0（真或假）再与 `zee` 比较。我们并不推荐这样写，但是在这里有必要说明一下。

表 6.2 列出了目前我们学过的运算符的性质。附录 B 的参考资料 II “C 运算符”中列出了全部运算符的完整优先级表。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\运算符优先级1.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;"> 表 6.2 运算符优先级
</div>
</div>

## 6.4 不确定循环和计数循环

一些 `while` 循环是**不确定循环**（indefinite loop）。所谓不确定循环，指在测试表达式为假之前，预先不知道要执行多少次循环。例如，程序清单 6.1 通过与用户交互获得数据来计算整数之和。我们事先并不知道用户会输入什么整数。另外，还有一类是**计数循环**（counting loop）。这类循环在执行循环之前就知道要重复执行多少次。程序清单 6.10 就是一个简单的计数循环。

```c
// 程序清单6.10 sweetie1.c程序
// sweetie1.c -- 一个计数循环
#include <stdio.h>
int main(void)
{
    const int NUMBER = 22;
    int count = 1; // 初始化

    while (count <= NUMBER) // 测试
    {
        printf("Be my Valentine!\n"); // 行为
        count++; // 更新计数
    }

    return 0;
}
```

虽然程序清单 6.10 运行情况良好，但是定义循环的行为并未组织在一起，程序的编排并不是很理想。我们来仔细分析一下。

在创建一个重复执行固定次数的循环中涉及了 3 个行为：

1. 必须初始化计数器；
2. 计数器与有限的值作比较；
3. 每次循环时递增计数器。

`while` 循环的测试条件执行比较，递增运算符执行递增。程序清单 6.10 中，递增发生在循环的末尾，这可以防止不小心漏掉递增。因此，这样做比将测试和更新组合放在一起（即使用 `count++ <= NUMBER`）要好，但是计数器的初始化放在循环外，就有可能忘记初始化。实践告诉我们可能会发生的事情终究会发生，所以我们来学习另一种控制语句，可以避免这些问题。

## 6.5 for 循环

`for` 循环把上述 3 个行为（初始化、测试和更新）组合在一处。程序清单 6.11 使用 `for` 循环修改了程序清单 6.10 的程序。

```c
// 程序清单6.11 sweetie2.c程序
// sweetie2.c -- 使用for循环的计数循环
#include <stdio.h>
int main(void)
{
    const int NUMBER = 22;
    int count;

    for (count = 1; count <= NUMBER; count++)
        printf("Be my Valentine!\n");

    return 0;
}
```

关键字 `for` 后面的圆括号中有 3 个表达式，分别用两个分号隔开。第 1 个表达式是初始化，只会在 `for` 循环开始时执行一次。第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假（本例中，`count` 大于 `NUMBER` 时），循环结束。第 3 个表达式执行更新，在每次循环结束时求值。程序清单 6.10 用这个表达式递增 `count` 的值，更新计数。完整的 `for` 语句还包括后面的简单语句或复合语句。`for` 圆括号中的表达式也叫做**控制表达式**，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。

### 6.5.1 利用 for 的灵活性

灵活性源于如何使用 `for` 循环中的 3 个表达式。以前面程序示例中的 `for` 循环为例，第 1 个表达式给计数器赋初值，第 2 个表达式表示计数器的范围，第 3 个表达式递增计数器。这样使用 `for` 循环确实很像其他语言的循环。除此之外，`for` 循环还有其他 9 种用法。

1. 可以使用递减运算符来递减计数器

```c
/* for_down.c */
#include <stdio.h>
int main(void)
{
    int secs;

    for (secs = 5; secs > 0; secs--)
        printf("%d seconds!\n", secs);
    printf("We have ignition!\n");
    return 0;
}
```

2. 可以让计数器递增 2、10 等

```c
/* for_13s.c */
#include <stdio.h>
int main(void)
{
    int n; // 从2开始，每次递增13

    for (n = 2; n < 60; n = n + 13)
        printf("%d \n", n);
    return 0;
}
```

3. 可以用字符代替数字计数

```c
/* for_char.c */
#include <stdio.h>
int main(void)
{
    char ch;

    for (ch = 'a'; ch <= 'z'; ch++)
        printf("The ASCII value for %c is %d.\n", ch, ch);
    return 0;
}
```

该程序能正常运行是因为字符在内部是以整数形式储存的，因此该循环实际上仍是用整数来计数。

4. 除了测试迭代次数外，还可以测试其他条件。在 for_cube 程序中，可以把：

```c
for (num = 1; num <= 6; num++)
```

替换成：

```c
for (num = 1; num*num*num <= 216; num++)
```

如果与控制循环次数相比，你更关心限制立方的大小，就可以使用这样的测试条件。

5. 可以让递增的量**几何增长**，而不是算术增长。也就是说，每次都乘上而不是加上一个固定的量：

```c
/* for_geo.c */
#include <stdio.h>
int main(void)
{
    double debt;

    for (debt = 100.0; debt < 150.0; debt = debt * 1.1)
        printf("Your debt is now $%.2f.\n", debt);
    return 0;
}
```

6. 第 3 个表达式可以使用任意合法的表达式。无论是什么表达式，每次迭代都会更新该表达式的值。

```c
/* for_wild.c */
#include <stdio.h>
int main(void)
{
    int x;
    int y = 55;

    for (x = 1; y <= 75; y = (++x * 5) + 50)
        printf("%10d %10d\n", x, y);
    return 0;
}
```

注意，测试涉及 `y`，而不是 `x`。for 循环中的 3 个表达式可以是不同的变量（注意，虽然该例可以正常运行，但是编程风格不太好。如果不在更新部分加入代数计算，程序会更加清楚）。

7. 可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。

```c
/* for_none.c */
#include <stdio.h>
int main(void)
{
    int ans, n;
    ans = 2;
    for (n = 3; ans <= 25;)
        ans = ans * n;
    printf("n = %d; ans = %d.\n", n, ans);
    return 0;
}
```

该循环保持 `n` 的值为 3。变量 `ans` 开始的值为 2，然后递增到 6 和 18，最终是 54（18 比 25 小，所以 `for` 循环进入下一次迭代，18 乘以 3 得 54）。顺带一提，<mark>省略第 2 个表达式被视为真</mark>，所以下面的循环会一直运行：

```c
for (; ; )
    printf("I want some action\n");
```

8. 第 1 个表达式不一定是给变量赋初值，也可以使用 `printf()`。记住，在执行循环的其他部分之前，只对第 1 个表达式求值一次或执行一次。

```c
/* for_show.c */
#include <stdio.h>
int main(void)
{
    int num = 0;

    for (printf("Keep entering numbers!\n"); num != 6;)
        scanf("%d", &num);
    printf("That's the one I want!\n");
    return 0;
}
```

9. 循环体中的行为可以改变循环头中的表达式。例如，假设创建了下面的循环：

```c
for (n = 1; n < 10000; n = n + delta)
```

如果程序经过几次迭代后发现 `delta` 太小或太大，循环中的 `if` 语句（详见第 7 章）可以改变 `delta` 的大小。在交互式程序中，用户可以在循环运行时才改变 `delta` 的值。这样做也有危险的一面，例如，把 `delta` 设置为 0 就没用了。

总而言之，可以自己决定如何使用 `for` 循环头中的表达式，这使得在执行固定次数的循环外，还可以做更多的事情。接下来，我们将简要讨论一些运算符，使 `for` 循环更加有用。

## 6.6 其他赋值运算符：+=、-=、\*=、/=、%=

C 有许多赋值运算符。最基本、最常用的是 `=`，它把右侧表达式的值赋给左侧的变量。其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式。赋给变量的新值是根据右侧表达式的值调整后的值。确切的调整方案取决于具体的运算符。例如：

```c
scores += 20 与 scores = scores + 20 相同
dimes -= 2 与 dimes = dimes - 2 相同
bunnies *= 2 与 bunnies = bunnies * 2 相同
time /= 2.73 与 time = time / 2.73 相同
reduce %= 3 与 reduce = reduce % 3 相同
```

上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式，例如：

```c
x *= 3 * y + 12 与 x = x * (3 * y + 12) 相同
```

以上提到的赋值运算符与 `=` 的优先级相同，即比 `+` 或 `*` 优先级低。上面最后一个例子也反映了赋值运算符的优先级，`3 * y` 先与 `12` 相加，再把计算结果与 `x` 相乘，最后再把乘积赋给 `x`。

并非一定要使用这些组合形式的赋值运算符。但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效。当需要在 `for` 循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用。

## 6.7 逗号运算符

逗号运算符扩展了 `for` 循环的灵活性，以便在循环头中包含更多的表达式。例如，程序清单 6.13 演示了一个打印一类邮件资费（first-class postage rate）的程序（在撰写本书时，邮资为首重 40 美分/盎司，续重 20 美分/盎司，可以在互联网上查看当前邮资）。

```c
// 程序清单6.13 postage.c程序
// postage.c -- 一类邮资
#include <stdio.h>
int main(void)
{
    const int FIRST_OZ = 46; // 2013邮资
    const int NEXT_OZ = 20; // 2013邮资
    int ounces, cost;

    printf(" ounces cost\n");
    for (ounces = 1, cost = FIRST_OZ; ounces <= 16; ounces++, cost += NEXT_OZ)
        printf("%5d $%4.2f\n", ounces, cost / 100.0);
    return 0;
}
```

运行（前 5 行输出）：

```c
ounces cost
    1 $0.46
    2 $0.66
    3 $0.86
    4 $1.06
```

该程序在初始化表达式和更新表达式中使用了**逗号运算符**。初始化表达式中的逗号使 `ounces` 和 `cost` 都进行了初始化，更新表达式中的逗号使每次迭代 `ounces` 递增 1、`cost` 递增 20（`NEXT_Z` 的值是 20）。绝大多数计算都在 `for` 循环头中进行。

逗号运算符并不局限于在 `for` 循环中使用，但是这是它最常用的地方。逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求值（换言之，<mark>逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生</mark>）。因此，`ounces` 在 `cost` 之前被初始化。在该例中，顺序并不重要，但是如果 `cost` 的表达式中包含了 `ounces` 时，顺序就很重要。例如，假设有下面的表达式：

```c
ounces++, cost = ounces * FIRST_OZ
```

在该表达式中，先递增 `ounce`，然后在第 2 个子表达式中使用 `ounce` 的新值。作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生。

其次，<mark>整个逗号表达式的值是右侧项的值</mark>。例如，下面语句

```c
x = (y = 3, (z = ++y + 2) + 5);
```

的效果是：先把 3 赋给 `y`，递增 `y` 为 4，然后把 4 加 2 之和（6）赋给 `z`，接着加上 5，最后把结果 11 赋给 `x`。另一方面，假设在写数字时不小心输入了逗号：

```c
houseprice = 249, 500;
```

这不是语法错误，C 编译器会将其解释为一个逗号表达式，即 `houseprice = 249` 是逗号左侧的子表达式，`500` 是右侧的子表达式。因此，整个逗号表达式的值是逗号右侧表达式的值，而且左侧的赋值表达式把 `249` 赋给变量 `houseprice`。因此，这与下面代码的效果相同：

```c
houseprice = 249;
500;
```

记住，任何表达式后面加上一个分号就成了表达式语句。所以，`500;` 也是一条语句，但是什么也不做。

另外，下面的语句

```c
houseprice = (249, 500);
```

赋给 `houseprice` 的值是逗号右侧子表达式的值，即 `500`。**逗号也可用作分隔符**。在下面语句中的逗号都是分隔符，不是逗号运算符：

```c
char ch, date;
printf("%d %d\n", chimps, chumps);
```

### 6.7.1 当 Zeno 遇到 for 循环

## 6.8 出口条件循环：do while

`while` 循环和 `for` 循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。C 语言还有出口条件循环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。这种循环被称为 `do while` 循环。程序清单 6.15 演示了一个示例。

```c
// 程序清单6.15 do_while.c程序
/* do_while.c -- 出口条件循环 */
#include <stdio.h>
int main(void)
{
    const int secret_code = 13;
    int code_entered;

    do
    {
        printf("To enter the triskaidekaphobia therapy club,\n");
        printf("please enter the secret code number: ");
        scanf("%d", &code_entered);
    } while (code_entered != secret_code);
    printf("Congratulations! You are cured!\n");

    return 0;
}
```

使用 `while` 循环也能写出等价的程序，但是长一些，如程序清单 6.16 所示。

```c
// 程序清单6.16 entry.c程序
/* entry.c -- 出口条件循环 */
#include <stdio.h>
int main(void)
{
    const int secret_code = 13;
    int code_entered;

    printf("To enter the triskaidekaphobia therapy club,\n");
    printf("please enter the secret code number: ");
    scanf("%d", &code_entered);
    while (code_entered != secret_code)
    {
        printf("To enter the triskaidekaphobia therapy club,\n");
        printf("please enter the secret code number: ");
        scanf("%d", &code_entered);
    }
    printf("Congratulations! You are cured!\n");

    return 0;
}
```

下面是 `do while` 循环的通用形式：

```c
do
    statement
while ( expression );
```

`statement` 可以是一条简单语句或复合语句。<mark>注意，do while 循环以分号结尾</mark>。

`do while` 循环在执行完循环体后才执行测试条件，所以至少执行循环体一次；而 `for` 循环或 `while` 循环都是在执行循环体之前先执行测试条件。`do while` 循环适用于那些至少要迭代一次的循环。

## 6.9 如何选择循环

如何选择使用哪一种循环？首先，确定是需要**入口条件循环**还是**出口条件循环**。通常，入口条件循环用得比较多，有几个原因。其一，**一般原则是在执行循环之前测试条件比较好**。其二，**测试放在循环的开头，程序的可读性更高**。另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。

那么，假设需要一个入口条件循环，用 `for` 循环还是 `while` 循环？这取决于个人喜好，因为二者皆可。要让 `for` 循环看起来像 `while` 循环，可以省略第 1 个和第 3 个表达式。例如：

```c
for ( ; test ; )
```

与下面的 `while` 效果相同：

```c
while ( test )
```

要让 `while` 循环看起来像 `for` 循环，可以在 `while` 循环的前面初始化变量，并在 `while` 循环体中包含更新语句。例如：

```c
初始化;
while ( 测试 )
{
    其他语句
    更新语句
}
```

与下面的 `for` 循环效果相同：

```c
for ( 初始化 ;测试 ; 更新 )
    其他语句
```

一般而言，当循环涉及初始化和更新变量时，用 `for` 循环比较合适，而在其他情况下用 `while` 循环更好。对于下面这种条件，用 `while` 循环就很合适：

```c
while (scanf("%ld", &num) == 1)
```

对于涉及索引计数的循环，用 `for` 循环更适合。例如：

```c
for (count = 1; count <= 100; count++)
```

## 6.10 嵌套循环

**嵌套循环**（nested loop）指在一个循环内包含另一个循环。嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行。程序清单 6.17 演示了一个简单的示例。

```c
// 程序清单6.17 rows1.c程序
/* rows1.c -- 使用嵌套循环 */
#include <stdio.h>
#define ROWS 6
#define CHARS 10
int main(void)
{
    int row;
    char ch;

    for (row = 0; row < ROWS; row++) /* 第10行 */
    {
        for (ch = 'A'; ch < ('A' + CHARS); ch++) /* 第12行 */
            printf("%c", ch);
        printf("\n");
    }

    return 0;
}
```

运行：

```c
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
```

### 6.10.1 程序分析

第 10 行开始的 `for` 循环被称为**外层循环**（outer loop），第 12 行开始的 `for` 循环被称为**内层循环**（inner loop）。外层循环从 `row` 为 0 开始循环，到 `row` 为 6 时结束。因此，外层循环要执行 6 次，`row` 的值从 0 变为 5。每次迭代要执行的第 1 条语句是内层的 `for` 循环，该循环要执行 10 次，在同一行打印字符 `A~J`；第 2 条语句是外层循环的 `printf("\n");`，该语句的效果是另起一行，这样在下一次运行内层循环时，将在下一行打印的字符。

注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环。在程序清单 6.17 中，内层循环一行打印 10 个字符，外层循环创建 6 行。

### 6.10.2 嵌套变式

上一个实例中，内层循环和外层循环所做的事情相同。可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务。把程序清单 6.17 稍微修改后，如程序清单 6.18 所示。内层循环开始打印的字符取决于外层循环的迭代次数。该程序的第 1 行使用了新的注释风格，而且用 `const` 关键字代替 `#define`，有助于读者熟悉这两种方法。

```c
// 程序清单6.18 rows2.c程序
// rows2.c -- 依赖外部循环的嵌套循环
#include <stdio.h>
int main(void)
{
    const int ROWS = 6;
    const int CHARS = 6;
    int row;
    char ch;

    for (row = 0; row < ROWS; row++)
    {
        for (ch = ('A' + row); ch < ('A' + CHARS); ch++)
            printf("%c", ch);
        printf("\n");
    }

    return 0;
}
```

运行：

```c
ABCDEF
BCDEF
CDEF
DEF
EF
F
```

因为每次迭代都要把 `row` 的值与 `A` 相加，所以 `ch` 在每一行都被初始化为不同的字符。然而，测试条件并没有改变，所以每行依然是以 `F` 结尾，这使得每一行打印的字符都比上一行少一个。

## 6.11 数组简介

在许多程序中，**数组**很重要。数组可以作为一种储存多个相关项的便利方式。我们在第 10 章中将详细介绍数组，但是由于循环经常用到数组，所以在这里先简要地介绍一下。

数组（array）是按顺序储存的一系列类型相同的值，如 10 个 `char` 类型的字符或 15 个 `int` 类型的值。整个数组有一个数组名，通过整数**下标**访问数组中单独的项或元素（element）。例如，以下声明：

```c
float debts[20];
```

声明 `debts` 是一个内含 20 个元素的数组，每个元素都可以储存 `float` 类型的值。数组的第 1 个元素是 `debts[0]`，第 2 个元素是 `debts[1]`，以此类推，到 `debts[19]`。<mark>注意，数组元素的编号从 0 开始，不是从 1 开始</mark>。可以给每个元素赋 `float` 类型的值。例如，可以这样写：

```c
debts[5] = 32.54;
debts[6] = 1.2e+21;
```

实际上，使用数组元素和使用同类型的变量一样。例如，可以这样把值读入指定的元素中：

```c
scanf("%f", &debts[4]); // 把一个值读入数组的第5个元素
```

这里要注意一个潜在的陷阱：<mark>考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确</mark>。下面的代码，都不正确：

```c
debts[20] = 88.32; // 该数组元素不存在
debts[33] = 828.12; // 该数组元素不存在
```

编译器不会查找这样的错误。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。数组的类型可以是任意数据类型。

我们在第 4 章中讨论过**字符串**，可以把字符串储存在 `char` 类型的数组中（一般而言，`char` 类型数组的所有元素都储存 `char` 类型的值）。如果 `char` 类型的数组末尾包含一个表示字符串末尾的空字符 `\0`，则该数组中的内容就构成了一个字符串（见图 6.6）。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\字符数组和字符串.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;">  图 6.6 字符数组和字符串
</div>
</div>

用于识别数组元素的数字被称为**下标**（subscript）、**索引**（indice）或**偏移量**（offset）。下标必须是整数，而且要从 0 开始计数。<mark>数组的元素被依次储存在内存中相邻的位置</mark>，如图 6.7 所示。

<div align=center>
<img width="90%" src="\programme\C_C++\C_primer_plus\image\内存中的数组.png"/><br>
<div style="text-align: justify; display: inline-block; color: #5b5b5b; padding: 2px;">  图 6.7 内存中的 char 和 int 类型的数组
</div>
</div>

## 6.12 使用函数返回值的循环示例

编写一个有返回值的函数，要完成以下内容：

1. 定义函数时，确定函数的返回类型；
2. 使用关键字 `return` 表明待返回的值。

例如，可以这样写：

```c
double power(double n, int p) // 返回一个double类型的值
{
    double pow = 1;
    int i;

    for (i = 1; i <= p; i++)
        pow *= n;

    return pow; // 返回pow的值
}
```

要声明函数的返回类型，在函数名前写出类型即可，就像声明一个变量那样。关键字 `return` 表明该函数将把它后面的值返回给主调函数。根据上面的代码，函数返回一个变量的值。**返回值也可以是表达式的值**，如下所示：

```c
return 2 * x + b;
```

函数将计算表达式的值，并返回该值。**在主调函数中，可以把返回值赋给另一个变量、作为表达式中的值、作为另一个函数的参数**（如，`printf("%f", power(6.28, 3))`），或者忽略它。

### 6.12.2 使用带返回值的函数

**声明函数**、**调用函数**、**定义函数**、**使用关键字** `return`，都是定义和使用带返回值函数的基本要素。

这里，读者可能有一些问题。例如，既然在使用函数返回值之前要声明函数，那么为什么在使用 `scanf()` 的返回值之前没有声明 `scanf()`？为什么在定义中说明了 `power()` 的返回类型为 `double`，还要单独声明这个函数？我们先回答第 2 个问题。编译器在程序中首次遇到 power() 时，需要知道 power() 的返回类型。此时，编译器尚未执行到 `power()` 的定义，并不知道函数定义中的返回类型是 `double`。因此，必须通过**前置声明**（forward declaration）预先说明函数的返回类型。前置声明告诉编译器，`power()` 定义在别处，其返回类型为 `double`。如果把 `power()` 函数的定义置于 `main()` 的文件顶部，就可以省略前置声明，因为编译器在执行到 `main()` 之前已经知道 `power()` 的所有信息。但是，这不是 C 的标准风格。因为 `main()` 通常只提供整个程序的框架，最好把 `main()` 放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少。

接下来，为什么不用声明 `scanf()` 函数就可以使用它？其实，你已经声明了。`stdio.h` 头文件中包含了 `scanf()`、`printf()` 和其他 I/O 函数的原型。`scanf()` 函数的原型表明，它返回的类型是 `int`。

## 6.13 关键概念

循环是一个强大的编程工具。在创建循环时，要特别注意以下 3 个方面：

- 注意循环的测试条件要能使循环结束；
- 确保循环测试中的值在首次使用之前已初始化；
- 确保循环在每次迭代都更新测试的值。

C 通过求值来处理测试条件，结果为 0 表示假，非 0 表示真。带关系运算符的表达式常用于循环测试，它们有些特殊。如果关系表达式为真，其值为 1；如果为假，其值为 0。这与新类型 `_Bool` 的值保持一致。数组由相邻的内存位置组成，只储存相同类型的数据。记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少 1。C 编译器不会检查数组下标值是否有效，自己要多留心。

使用函数涉及 3 个步骤：

- 通过函数原型声明函数；
- 在程序中通过函数调用使用函数；
- 定义函数。

函数原型是为了方便编译器查看程序中使用的函数是否正确，函数定义描述了函数如何工作。现代的编程习惯是把程序要素分为接口部分和实现部分，例如**函数原型**和**函数定义**。接口部分描述了如何使用一个特性，也就是函数原型所做的；实现部分描述了具体的行为，这正是函数定义所做的。

## 6.14 本章小结

本章的主题是程序控制。C 语言为实现结构化的程序提供了许多工具。`while` 语句和 `for` 语句提供了入口条件循环。`for` 语句特别适用于需要初始化和更新的循环。使用逗号运算符可以在 `for` 循环中初始化和更新多个变量。有些场合也需要使用出口条件循环，C 为此提供了 `do while` 语句。

典型的 `while` 循环设计的伪代码如下：

```c
获得初值
while (值满足测试条件)
{
    处理该值
    获取下一个值
}
```

for循环也可以完成相同的任务：
```c
for (获得初值; 值满足测试条件; 获得下一个值)
    处理该值
```

这些循环都使用测试条件来判断是否继续执行下一次迭代。一般而言，如果对测试表达式求值为非 0，则继续执行循环；否则，结束循环。通常，测试条件都是关系表达式（由关系运算符和表达式构成）。表达式的关系为真，则表达式的值为 1；如果关系为假，则表达式的值为 0。C99 新增了 `_Bool` 类型，该类型的变量只能储存 1 或 0，分别表示真或假。

除了关系运算符，本章还介绍了其他的组合赋值运算符，如 `+=` 或 `*=`。这些运算符通过对其左侧运算对象执行算术运算来修改它的值。

接下来还简单地介绍了数组。声明数组时，方括号中的值指明了该数组的元素个数。数组的第 1 个元素编号为 0，第 2 个元素编号为 1，以此类推。例如，以下声明：

```c
double hippos[20];
```

创建了一个有 20 个元素的数组 `hippos`，其元素从 `hippos[0]~hippos[19]`。利用循环可以很方便地操控数组的下标。

最后，本章演示了如何编写和使用带返回值的函数。
