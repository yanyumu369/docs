类的基本思想是**数据抽象**（data abstraction）和**封装**（encapsulation）。数据抽象是一种依赖于**接口**（interface）和**实现**（implementation）分离的编程（以及设计）技术。类的接口包括用户所能执行的操作：类的实现则包括**类的数据成员**、负责接口实现的**函数体**以及定义类所需的各种**私有函数**。封装实现了类的接口和实现的分离。

封装后的类隐藏了它的实现细节，也就是说，<mark>类的用户只能使用接口而无法访问实现部分</mark>。

类要想实现数据抽象和封装，需要首先定义一个**抽象数据类型**（abstract data type）。在抽象数据类型中，由类的设计者负责考虑类的实现过程：使用该类的程序员则只需要抽象地思考类型做了什么，而无须了解类型的工作细节。

### 7.1 定义抽象数据类型

在第 1 章中使用的 `Sales item` 类是一个**抽象数据类型**，我们通过它的接口来使用一个 `Sales item` 对象，我们不能访问 `Sales item` 对象的数据成员，事实上，我们甚至根本不知道这个类有哪些数据成员。

与之相反，`Sales_data` 类不是一个抽象数据类型。它允许类的用户直接访问它的数据成员，并且要求由用户来编写操作。要想把 `Sales_data` 变成抽象数据类型，我们需要**定义一些操作**以供类的用户使用。一旦 `Sales_data` 定义了它自己的操作，我们就可以封装（隐藏）它的数据成员了。

#### 7.1.1 设计 Sales_data 类

由于 14.1 节将要解释的原因，执行加法和 IO 的函数不作为 `Sales_data` 的成员，相反的，我们将其定义成**普通函数**；执行复合赋值运算的函数是**成员函数**。`Sales_data` 类无须专门定义赋值运算，其原因将在 7.l.5 节介绍。

Sales_data 的接口应该包含以下操作：

- 一个 `isbn` 成员函数，用于返回对象的 ISBN 编号；
- 一个 `combine` 成员函数，用于将一个 Sales_data 对象加到另一个对象上；
- 一个名为 `add` 的函数，执行两个 Sales_data 对象的加法；
- 一个 `read` 函数，将数据从 `istream` 读入到 Sales_data 对象中；
- 一个 `print` 函数，将 Sales_data 对象的值输出到 `ostream`。

> 关键概念：不同的编程角色<br>
> 程序员们常把运行其程序的人称作用户（user）。类似的，类的设计者也是为其用户设计并实现一个类的人；显然，类的用户是程序员，而非应用程序的最终使用者。<br>
> 当我们提及“用户”一词时，不同的语境决定了不同的含义。如果我们说用户代码或者 `Sales_data` 类的用户，指的是使用类的程序员；如果我们说书店应用程序的用户，则意指运行该应用程序的书店经理。

> 注意：C++ 程序员们无须可以区分应用程序的用户以及类的用户。

##### 使用改进的 Sales_data 类

在考虑如何实现我们的类之前，首先来看看应该如何使用上面这些接口函数。

```cpp
// avg_price.cpp
#include <iostream>
using std::cerr; using std::cin; using std::cout; using std::endl;

#include "Sales_data.h"

int main()
{
	Sales_data total;         // 保存当前求和结果的变量
	if (read(cin, total))  {  // 读入第一笔交易
		Sales_data trans;     // 保存下一条交易数据的变量
		while(read(cin, trans)) {      // 读入剩余的交易
			if (total.isbn() == trans.isbn())   // 检查 isbn
				total.combine(trans);  // 更新变量 total 的当前值
			else {
				print(cout, total) << endl;  // 打印结果
				total = trans;               // 处理下一本书
			}
		}
		print(cout, total) << endl;          // 输出最后一条交易
	} else {                                 // 没有输入任何信息
		cerr << "No data?!" << endl;         // 通知用户
	}

	return 0;
}
```

- 一开始我们定义了一个 `Sales_data` 对象用于保存实时的汇总信息。
- 在 `if` 和 `while` 条件内部，调用 `read` 函数将第一条交易读入到 `total` 中，这里的条件部分与之前我们使用 >> 运算符的效果是一样的。`read` 函数返回它的流参数，而条件部分负责检查这个返回值，如果 `read` 函数失败，程序将直接跳转到 `else` 语句并输出一条错误信息。
- 因为 `print` 返回的是它的流参数的引用，所以我们可以把 `print` 的返回值作为 `<<` 运算符的左侧运算对象。

#### 7.1.2 定义改进的 Sales_data 类

改进的 `Sales_data` 类应该如下所示：

```cpp
// Sales_data.h
#ifndef SALES_DATA_H
#define SALES_DATA_H

#include "Version_test.h"

#include <string>
#include <iostream>

class Sales_data {
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
public:
	// constructors
// using the synthesized version is safe only
// if we can also use in-class initializers
#if defined(IN_CLASS_INITS) && defined(DEFAULT_FCNS)
	Sales_data() = default;
#else
	Sales_data(): units_sold(0), revenue(0.0) { }
#endif
#ifdef IN_CLASS_INITS
	Sales_data(const std::string &s): bookNo(s) { }
#else
	Sales_data(const std::string &s):
	           bookNo(s), units_sold(0), revenue(0.0) { }
#endif
	Sales_data(const std::string &s, unsigned n, double p):
	           bookNo(s), units_sold(n), revenue(p*n) { }
	Sales_data(std::istream &);

	// 关于 Dales_data 对象的操作
	std::string isbn() const { return bookNo; }
	Sales_data& combine(const Sales_data&);
	double avg_price() const;
private:
	std::string bookNo;
#ifdef IN_CLASS_INITS   // using the synthesized version is safe only
	unsigned units_sold = 0;
	double revenue = 0.0;
#else
	unsigned units_sold;
	double revenue;
#endif
};


// Sales_data 的非成员接口函数
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);

// used in future chapters
inline
bool compareIsbn(const Sales_data &lhs, const Sales_data &rhs)
{
	return lhs.isbn() < rhs.isbn();
}
#endif
```

- 改进之后的 `Sales_data` 类的数据成员包括：`std::string bookNo`，表示 ISBN 编号；`unsigned units_sold`，表示某本书的销量；以及 `double revenue`，表示这本书的总销售收入。
- 如前所述，`Sales_data` 类将包含两个**成员函数**：`combine` 和 `isbn`。此外，`avg_price` 成员函数用于返回售出书籍的平均价格。因为 `avg_price` 的目的并非通用，所以它应该属于类的实现的一部分，而非接口的一部分。
- **定义**和**声明**成员函数的方式与普通函数差不多。<mark>成员函数的声明必须在类的内部，它的定义则既可以在类的内部也可以在类的外部</mark>。<mark>作为接口组成部分的非成员函数，例如 `add`、`read` 和 `print` 等，它们的定义和声明都在类的外部</mark>。

> 注意：定义在类内部的函数时隐式的 `inline` 函数。

##### 定义成员函数

```cpp
// Sales_data.cpp
#include <iostream>
using std::istream; using std::ostream;

#include "Sales_data.h"
Sales_data::Sales_data(std::istream &is)
{
	// read will read a transaction from is into this object
	read(is, *this);
}

double
Sales_data::avg_price() const {
	if (units_sold)
		return revenue/units_sold;
	else
		return 0;
}

// add the value of the given Sales_data into this object
Sales_data&
Sales_data::combine(const Sales_data &rhs)
{
	units_sold += rhs.units_sold; // add the members of rhs into
	revenue += rhs.revenue;       // the members of ``this'' object
	return *this; // return the object on which the function was called
}

Sales_data
add(const Sales_data &lhs, const Sales_data &rhs)
{
	Sales_data sum = lhs;  // copy data members from lhs into sum
	sum.combine(rhs);      // add data members from rhs into sum
	return sum;
}

// transactions contain ISBN, number of copies sold, and sales price
istream&
read(istream &is, Sales_data &item)
{
	double price = 0;
	is >> item.bookNo >> item.units_sold >> price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream&
print(ostream &os, const Sales_data &item)
{
	os << item.isbn() << " " << item.units_sold << " "
	   << item.revenue << " " << item.avg_price();
	return os;
}
```

尽管所有成员都必须在类的内部声明，但是成员函数体可以定义在类内也可以定义在类外。对于 `Sales_data` 类来说，`isbn` 函数定义在了类内（后面花括号中的内容即为函数定义），而 `combine` 和 `avg_price` 定义在了类外（Sales_data.cpp 文件内）。

我们首先介绍 `isbn` 函数，它的参数列表为空，返回值是一个 `string` 对象：

```cpp
std::string isbn() const { return bookNo; }
```

和其他函数一样，成员函数体也是一个块。在此例中，块只有一条 `return` 语句，用于返回 `Sales_data` 对象的 `bookNo` 数据成员。关于 `isbn` 函数一件有意思的事情是：它是如何获得 `bookNo` 成员所依赖的对象的呢？

##### 引入 this

对 isbn 成员函数的调用：`total.isbn()`。在这里，我们使用了点运算符来访问 total 对象的 isbn 成员，然后调用它。

当我们调用成员函数时，实际上是在替某个对象调用它。如果 `isbn` 指向 `Sales_data` 的成员（例如 `booNo`），则它隐式地指向**调用该函数的对象**（`total`）的成员。在上面所示的调用中，当 `isbn` 返回 `bookNo` 时，实际上它隐式地返回 `total.bookNo`。

成员函数通过一个名为 `this` 的额外隐式参数来访问调用它的那个对象。当我们调用一个成员函数时，用请求该函数的对象地址初始化 `this`。例如，如果调用 `total.isbn()`，则编译器负责把 `total` 的地址传递给 `isbn` 的隐式形参 this，可以等价地认为编译器将该调用重写成了如下的形式：

```cpp
// 伪代码，用于说明调用成员函数的实际执行过程
Sales_data::isbn(&total)
```

其中，调用 `Sales_data` 的 `isbn` 成员时传入了 `total` 的地址。

在成员函数内部，我们可以直接使用调用该函数的对象的成员，而无须通过成员访问运算符来做到这一点，因为 this 所指的正是这个对象。任何对类成员的直接访问都被看作 `this` 的隐式引用，也就是说，当 `isbn` 使用 `bookNo` 时，它隐式地使用 `this` 指向的成员，就像我们书写了 `this->bookNo` 一样。

<mark>对于我们来说，`this` 形参是隐式定义的。实际上，任何自定义名为 `this` 的参数或变量的行为都是非法的</mark>。我们可以在成员函数体内部使用 `this`，因此尽管没有必要，但我们还是能把 `isbn` 定义成如下的形式：

```cpp
std::string isbn () const { return this->bookNo; }
```

因为 `this` 的目的总是指向“这个”对象，所以<mark> `this` 是一个常量指针，我们不允许改变 `this` 中保存的地址</mark>。

##### 引入 const 成员函数

`isbn` 函数的另一个关键之处是紧随参数列表之后的 `const` 关键字，这里，`const` 的作用是修改隐式 `this` 指针的类型。

<mark>默认情况下，`this` 的类型是指向类类型非常量版本的常量指针</mark>，例如在 `Sales_data` 成员函数中，`this` 的类型是 `Sales_data*const`。尽管 `this` 是隐式的，但它仍然需要遵循初始化规则，意味着<mark>（在默认情况下）我们不能把 `this` 指向一个常量对象。这一情况也就使得我们不能在一个常量对象上调用普通的成员函数</mark>〔声明为指向非常量对象的指针不能指向常量对象，反之可行〕。

如果 `isbn` 是一个普通函数而且 `this` 是一个普通的指针参数，则我们应该把 `this` 声明成 `const Sales_data*const`。毕竟，在 `isbn` 的函数体内不会改变 `this` 所指的对象，所以把 `this` 设置为指向常量的指针有助于提高函数的灵活性。〔成员函数 `combine` 可以改变 `this` 所指对象中的数据成员，因此没有使用 `const` 关键字，不能作用于一个常量对象。〕

然而，`this` 是隐式的并且不会出现在参数列表中，所以在哪儿将 `this` 声明成指向常量的指针就成为我们必须面对的问题。C++ 语言的做法是允许把 `const` 关键字放在成员函数的参数列表之后，此时，紧跟在参数列表后面的 `const` 表示 `this` 是一个**指向常量的指针**。像这样使用 `const` 的成员函数被称作**常量成员函数**（const member function）〔即常量对象和非常量对象都可以调用常量成员函数，而只有非常量对象才可以调用非常量成员函数〕。

可以把 isbn 的函数体想象成如下的形式：

```cpp
// 伪代码，说明隐式的 this 指针是如何使用的
// 下面的代码是非法的：因为我们不能显式地定义自己的 this 指针
// 谨记此处的 this 是一个指向常量的指针，因为 isbn 是一个常量成员
std::string Sales_data::isbn(const Sales_data *const this) { return this->isbn; }
```

因为 `this` 是指向常量的指针，所以常量成员函数不能改变调用它的对象的内容。在上例中，`isbn` 可以读取调用它的对象的数据成员，但是不能写入新值。

> 注意：常量对象，以及常量对象的引用或指针都只能调用常量成员函数。

##### 类作用域和成员函数

类本身就是一个作用域。类的成员函数的**定义**〔函数体〕嵌套在类的作用域之内，因此，`isbn` 中用到的名字 `bookNo` 其实就是定义在 `Sales_data` 内的数据成员。

值得注意的是，即使 `bookNo` 定义在 `isbn` 之后，`isbn` 也还是能够使用 `bookNo`。就如我们将在 7.4.1 节学习到的那样，编译器分两步处理类：首先编译成员〔函数成员和数据成员〕的声明，然后才轮到成员函数体（如果有的话）。因此，成员函数体可以随意使用类中的其他成员而无须在意这些成员出现的次序。

##### 在类的外部定义成员函数

像其他函数一样，当我们在类的外部定义成员函数时，成员函数的定义必须与它的声明匹配。也就是说，**返回类型**、**参数列表**和**函数名**都得与类内部的声明保持一致。如果成员被声明成常量成员函数，那么它的定义也必须在参数列表后明确指定 `const` 属性。同时，**类外部定义的成员的名字必须包含它所属的类名**：

```cpp
double Sales_data::avg_price() const {
	if (units_sold)
		return revenue/units_sold;
	else
		return 0;
}
```

函数名 `Sales_data :: avg_price` 使用作用**域运算符**来说明如下的事实：我们定义了一个名为 `avg_price` 的函数，并且该函数被声明在类 `Sales_data` 的作用域内。一旦编译器看到这个函数名，就能理解剩余的代码是位于类的作用域内的。因此，当 `avg_price` 使用 `revenue` 和 `units_sold` 时，实际上它隐式地使用了 `Sales_data` 成员。

##### 定义一个返回 this 对象的函数

函数 `combine` 的设计初衷类似于**复合赋值运算符** `+=`，调用该函数的对象代表的是赋值运算符左侧的运算对象，右侧运算对象则通过显式的实参被传入函数：

```cpp
Sales_data& Sales_data::combine(const Sales_data &rhs)
{
	units_sold += rhs.units_sold;   // 把 rhs 的成员加到 this 对象的成员上
	revenue += rhs.revenue;
	return *this;   // 返回调用该函数的对象
}
```

当我们的交易处理程序调用如下的函数时，

```cpp
total.combine(trans);   // 更改变量 total 当前的值
```

`total` 的地址被绑定到隐式的 `this` 参数上，而 `rhs` 绑定到了 `trans` 上。因此，当 `combine` 执行下面的语句时，

```cpp
units_sold += rhs.units_sold;   // 把 rhs 的成员添加到 this 对象的成员中
```

效果等同于求 `total.units_sold` 和 `trans.units_sold` 的和，然后把结果保存到 `total.units_sold` 中。

该函数一个值得关注的部分是它的**返回类型**和**返回语句**。**一般来说，当我们定义的函数类似于某个内置运算符时，应该令该函数的行为尽量模仿这个运算符**。内置的赋值运算符把它的左侧运算对象当成**左值**返回，因此为了与它保持一致，`combine` 函数**必须返回引用类型**。因为此时的左侧运算对象是一个 `Sales_data` 的对象，所以返回类型应该是 `Sales_data&`。

如前所述，我们无须使用隐式的 `this` 指针访问函数调用者的某个具体成员，而是需要把调用函数的对象当成一个整体来访问：

```cpp
return *this;   // 返回调用该函数的对象
```

其中，`return` 语句解引用 `this` 指针以获得执行该函数的对象，换句话说，上面的这个调用返回 `total` 的引用。〔`*this = &total`〕

#### 7.1.3 定义类相关的非成员函数

类的作者常常需要定义一些**辅助函数**，比如 `add`、`read` 和 `print` 等。**尽管这些函数定义的操作从概念上来说属于类的接口的组成部分，但它们实际上并不属于类本身**。

我们定义非成员函数的方式与定义其他函数一样，**通常把函数的声明和定义分离开来**。如果函数在概念上属于类但是不定义在类中，则它一般应与**类声明**（而非定义）在同一个头文件内。在这种方式下，用户使用接口的任何部分都只需要引入一个文件。

> 注意：一般来说，如果非成员函数是类接口的组成部分，则这些函数的声明应该与类在同一个头文件内。

##### 定义 read 和 print 函数

```cpp
// 输入的交易信息包括 ISBN、售出总数和售出价格
istream& read(istream &is, Sales_data &item)
{
	double price = 0;
	is >> item.bookNo >> item.units_sold >> price;
	item.revenue = price * item.units_sold;
	return is;
}

ostream& print(ostream &os, const Sales_data &item)
{
	os << item.isbn() << " " << item.units_sold << " "
	   << item.revenue << " " << item.avg_price();
	return os;
}
```

`read` 函数从给定流中将数据读到给定的对象里，`print` 函数则负责将给定对象的内容打印到给定的流中。

除此之外，关于上面的函数还有两点是非常重要的：

- 第一点，`read` 和 `print` 分别接受一个各自 IO 类型的引用作为其参数，这是<mark>因为 IO 类属于不能被拷贝的类型，因此我们只能通过引用来传递它们</mark>。而且，因为**读取和写入的操作会改变流的内容**，所以两个函数接受的都是**普通引用**，而非对常量的引用。〔即 `istream &is` 和 `ostream &os`，函数返回类型也是普通引用。〕
- 第二点，`print` 函数不负责换行。一般来说，执行输出任务的函数应该尽量减少对格式的控制，这样可以确保由用户代码来决定是否换行。

##### 定义 add 函数

`add` 函数接受两个 `Sales_data` 对象作为其参数，返回值是一个新的 `Sales_data` 〔对象〕，用于表示前两个对象的和：

```cpp
Sales_data add(const Sales_data &lhs, const Sales_data &rhs)
{
	Sales_data sum = lhs;  // 把 lhs 的数据成员拷贝给 sum
	sum.combine(rhs);      // 把 rhs 的数据成员加到 sum 当中
	return sum;
}
```

在函数体中，我们定义了一个新的 `Sales_data` 对象并将其命名为 `sum`。`sum` 将用于存放两笔交易的和，我们用 `lhs` 的副本来初始化 `sum`。**默认情况下，拷贝类的对象其实拷贝的是对象的数据成员**。在拷贝工作完成之后，`sum` 的 `bookNo`、`units sold` 和 `revenue` 将和 `lhs` 一致。接下来我们调用 `combine` 函数，将 `rhs` 的 `units sold` 和 `revenue` 添加给 `sum`。最后，函数返回 `sum` 的副本。

#### 7.1.4 构造函数

每个类都分别定义了它的对象被初始化的方式，**类通过一个或几个特殊的成员函数来控制其对象的初始化过程**，这些函数叫做**构造函数**（constructor）。**构造函数的任务是初始化类对象的数据成员，无论何时只要类的对象被创建，就会执行构造函数**。

<mark>构造函数的名字和类名相同</mark>。和其他函数不一样的是，<mark>构造函数没有返回类型</mark>：除此之外类似于其他的函数，构造函数也有一个（可能为空的）参数列表和一个（可能为空的）函数体。**类可以包含多个构造函数**，和其他重载函数差不多，不同的构造函数之间必须在参数数量或参数类型上有所区别。

不同于其他成员函数，<mark>构造函数不能被声明成 `const` 的</mark>。当我们创建类的一个 `cost` 对象时，直到构造函数完成初始化过程，对象才能真正取得其“常量”属性。因此，**构造函数在** `cost` **对象的构造过程中可以向其写值**。

##### 合成的默认构造函数

如果我们没有为对象提供初始值，它们会执行默认初始化。类通过一个特殊的构造函数来控制默认初始化过程，这个函数叫做**默认构造函数**（default constructor）。<mark>默认构造函数无须任何实参</mark>。

默认构造函数在很多方面都有其特殊性。其中之一是，如果我们的类没有显式地定义构造函数，那么编译器就会隐式地定义一个默认构造函数。**编译器创建的构造函数**又被称为**合成的默认构造函数**（synthesized default constructor）。对于大多数类来说，这个合成的默认构造函数将按照如下规则初始化类的数据成员：

- 如果存在类内的初始值，用它来初始化成员。
- 否则，默认初始化该成员。

因为 `Sales_data` 为 `units_sold` 和 `revenue` 提供了初始值，所以合成的默认构造函数将使用这些值来初始化对应的成员；同时，它把 `bookNo` 默认初始化成一个空字符串。

##### 某些类不能依赖于合成的默认构造函数

合成的默认构造函数只适合非常简单的类，比如现在定义的这个 `Sales_data` 版本。<mark>对于一个普通的类来说，必须定义它自己的默认构造函数</mark>，原因有三：

- 第一个原因是<mark>编译器只有在发现类不包含任何构造函数的情况下才会替我们生成一个默认的构造函数</mark>。一旦我们定义了一些其他的构造函数，那么除非我们再定义一个默认的构造函数，否则类将没有默认构造函数。这条规则的依据是，如果一个类在某种情况下需要控制对象初始化，那么该类很可能在所有情况下都需要控制。
- 第二个原因是对于某些类来说，合成的默认构造函数可能执行错误的操作。<mark>如果定义在块〔花括号〕中的内置类型或复合类型（比如数组和指针）的对象被默认初始化，则它们的值将是未定义的</mark>。该准则同样适用于默认初始化的内置类型成员。因此，含有内置类型或复合类型成员的类应该在类的内部初始化这些成员，或者定义一个自己的默认构造函数。否则，用户在创建类的对象时就可能得到未定义的值。
- 第三个原因是有的时候编译器不能为某些类合成默认的构造函数。例如，<mark>如果类中包含一个其他类类型的成员且这个成员的类型没有默认构造函数，那么编译器将无法初始化该成员</mark>。对于这样的类来说，我们必须自定义默认构造函数，否则该类将没有可用的默认构造函数。在 13.1.6 节中我们将看到还有其他一些情况也会导致编译器无法生成一个正确的默认构造函数。

> 注意：只有当类没有声明任何构造函数时，编译器才会自动地生成默认构造函数。

> 警告：如果类包含有内置类型或者复合类型的成员，则只有当这些成员全都被赋予了类内初始值时，这个类才适合于使用合成的默认构造函数。

##### 定义 Sales_data 的构造函数

对于我们的 `Sales_data` 类来说，我们将使用下面的参数定义 4 个不同的构造函数：

- 一个 `istream&`，从中读取一条交易信息。
- 一个 `const string&`，表示 ISBN 编号；一个 `unsigned`，表示售出的图书数量；以及一个 `double`，表示图书的售出价格。
- 一个 `const string&`，表示 ISBN 编号；编译器将赋予其他成员默认值。
- 一个**空参数列表**（即默认构造函数），既然我们已经定义了其他构造函数，那么也必须定义一个默认构造函数。

给类添加了这些成员之后，将得到：

```cpp
struct Sales_data {
// 新增的构造函数
	Sales_data() = default;
	Sales_data(const std::string &s): bookNo(s) { }
	Sales_data(const std::string &s, unsigned n, double p):
	           bookNo(s), units_sold(n), revenue(p*n) { }
	Sales_data(std::istream &);

	// 之前已有的其它成员
	std::string isbn() const { return bookNo; }
	Sales_data& combine(const Sales_data&);
	double avg_price() const;

	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
```

##### = default 的含义

我们从解释默认构造函数的含义开始：

```cpp
Sales_data() = default;
```

首先请明确一点：**因为该构造函数不接受任何实参，所以它是一个默认构造函数**。我们定义这个构造函数的目的仅仅是因为我们既需要其他形式的构造函数，也需要默认的构造函数。我们希望**这个函数的作用完全等同于之前使用的合成默认构造函数**。

在 C++11 新标准中，如果我们需要默认的行为，那么可以通过在参数列表后面写上 `= default` 来要求编译器生成构造函数。其中，`= default` 既可以和声明一起出现在类的内部，也可以作为定义出现在类的外部。和其他函数一样，如果 `= default` 在类的内部，则默认构造函数是内联的：如果它在类的外部，则该成员默认情况下不是内联的。

> 警告：上面的默认构造函数之所以对 Sales_data 有效，是因为我们为内置类型的数据成员提供了初始值。如果你的编译器不支持类内初始值，那么你的默认构造函数就应该使用构造函数初始值列表（马上就会介绍）来初始化类的每个成员。

##### 构造函数初始值列表

接下来我们介绍类中定义的另外两个构造函数：

```cpp
Sales_data(const std::string &s): bookNo(s) { }
Sales_data(const std::string &s, unsigned n, double p):
           bookNo(s), units_sold(n), revenue(p*n) { }
```

这两个定义中出现了新的部分，即冒号以及冒号和花括号之间的代码，其中花括号定义了（空的）函数体。我们把新出现的部分称为**构造函数初始值列表**（constructor initialize list），它**负责为新创建的对象的一个或几个数据成员赋初值**。**构造函数初始值是〔数据〕成员名字的一个列表，每个名字后面紧跟括号括起来的（或者在花括号内的）成员初始值**。不同成员的初始化通过逗号分隔开来。

含有三个参数的构造函数分别使用它的前两个参数初始化成员 `bookN`。和 `units sold`，`revenue` 的初始值则通过将售出图书总数和每本书单价相乘计算得到。

只有一个 `string` 类型参数的构造函数使用这个 `string` 对象初始化 `bookNo`，对于 units sold 和 revenue 则没有显式地初始化。**当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化**。在此例中，这样的成员使用类内初始值初始化，因此只接受一个 `string` 参数的构造函数等价于:

```cpp
// 与上面定义的那个构造函数效果相同
Sales_data(const std::string &s):
           bookNo(s), units_sold(0), revenue(0.0) { }
```

通常情况下，构造函数使用类内初始值不失为一种好的选择，因为只要这样的初始值存在我们就能确保为成员赋予了一个正确的值。不过，如果你的编译器不支持类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。

> Best practices：构造函数不应该轻易覆盖掉类内的初始值，除非新赋的值与原值不同。如果你不能使用类内初始值，则所有构造函数都应该显式地初始化每个内置类型的成员。

有一点需要注意，在上面的两个构造函数中函数体都是空的。这是因为这些构造函数的唯一目的就是为数据成员赋初值，一旦没有其他任务需要执行，函数体也就为空了。

##### 在类的外部定义构造函数

与其他几个构造函数不同，以 `istream` 为参数的构造函数需要执行一些实际的操作。在它的函数体内，调用了 `read` 函数以给数据成员赋以初值：〔从输入数据流中读取数据，然后给使用此构造函数的对象的数据成员赋初值〕

```cpp
Sales_data::Sales_data(std::istream &is)
{
	read(is, *this);  // read 函数的作用是从 is 中读取一条交易信息然后存入 this 对象中
}
```

构造函数没有返回类型，所以上述定义从我们指定的函数名字开始。和其他成员函数一样，<mark>当我们在类的外部定义构造函数时，必须指明该构造函数是哪个类的成员</mark>。因此，`Sales_data :: Sales_data` 的含义是我们定义 `Sales_data` 类的成员，它的名字是 `Sales_data`。又因为该成员的名字和类名相同，所以它是一个构造函数。

这个构造函数没有构造函数初始值列表，或者讲得更准确一点，它的构造函数初始值列表是空的。**尽管构造函数初始值列表是空的，但是由于执行了构造函数体，所以对象的成员仍然能被初始化**。没有出现在构造函数初始值列表中的成员将通过相应的类内初始值（如果存在的话）初始化，或者执行默认初始化。对于 `Sales_data` 来说，这意味着一旦函数开始执行，则 `bookNo` 将被初始化成空 `string` 对象，而 `units sold` 和 `revenue` 将分别是 `0` 和 `0.0`。

为了更好地理解调用函数 `read` 的意义，要特别注意 `read` 的第二个参数是一个 `Sales_data` 对象的引用。在 7.l.2 节中曾经提到过，使用 `this` 来把对象当成一个整体访问，而非直接访问对象的某个成员。因此在此例中，我们使用 `*this` 将“this”对象作为实参传递给 `read` 函数。

#### 7.1.5 拷贝、赋值和析构

除了定义类的对象如何初始化之外，类还需要控制**拷贝**、**赋值**和**销毁**对象时发生的行为。对象在几种情况下会被拷贝，如我们**初始化变量**以及**以值的方式传递**或**返回一个对象**等。〔将一个对象拷贝给一个初始化对象〕当我们使用了赋值运算符时会发生对象的赋值操作。〔将一个对象赋值给另一个对象〕当对象不再存在时执行销毁操作，比如一个局部对象会在创建它的块结束时被销毁，当 `vector` 对象（或者数组）销毁时存储在其中的对象也会被销毁。

如果我们不主动定义这些操作，则编译器将替我们合成它们。一般来说，编译器生成的版本将对对象的每个成员执行拷贝、赋值和销毁操作。例如在 7.1.1 节的书店程序中，当编译器执行如下赋值语句时，

```cpp
total = trans;  // 处理下一本书的信息
```

它的行为与下面的代码相同：

```cpp
// Sales_data 的默认赋值操作等价于：
total.bookNo = trans.bookNo;
total.units_sold = trans.units_sold;
total.revenue = trans.revenue;
```

我们将在第 13 章中介绍如何自定义上述操作。

##### 某些类不能依赖于合成的版本

尽管编译器能替我们合成拷贝、赋值和销毁的操作，但是必须要清楚的一点是，对于某些类来说合成的版本无法正常工作。特别是，<mark>当类需要分配类对象之外的资源时，合成的版本常常会失效</mark>。举个例子，第 12 章将介绍 C++ 程序是如何**分配和管理动态内存**的。而在 13.1.4 节我们将会看到，**管理动态内存的类通常不能依赖于上述操作的合成版本**。

不过值得注意的是，很多需要动态内存的类能（而且应该）使用 `vector` 对象或者 `string` 对象管理必要的存储空间。使用 `vector` 或者 `string` 的类能避免分配和释放内存带来的复杂性。

进一步讲，如果类包含 `vector` 或者 `string` 成员，则其拷贝、赋值和销毁的合成版本能够正常工作。当我们对含有 `vector` 成员的对象执行拷贝或者赋值操作时，`vector` 类会设法拷贝或者赋值成员中的元素。当这样的对象被销毁时，将销毁 `vector` 对象，也就是依次销毁 `vector` 中的每一个元素。这一点与 `string` 是非常类似的。

> 警告：在学习第 13 章关于如何自定义操作的知识之前，类中所有分配的资源都应该直接以类的数据成员的形式存储。

### 7.2 访问控制与封装

到目前为止，我们已经为类定义了接口，但并没有任何机制强制用户使用这些接口。我们的类还没有封装，也就是说，用户可以直达 `Sales_data` 对象的内部并且控制它的具体实现细节。在 C++ 语言中，我们使用**访问说明符**（access specifiers）加强类的封装性：

- 定义在 `public` 说明符之后的成员在整个程序内可被访问，`public` 成员定义类的接口。
- 定义在 `private` 说明符之后的成员可以被类的成员函数访问，但是不能被使用该类的代码访问，`private` 部分封装了（即隐藏了）类的实现细节。

再一次定义 `Sales_data` 类，其新形式如下所示：

```cpp
class Sales_data {
public:     // 添加了访问说明符
	Sales_data() = default;
	Sales_data(const std::string &s): bookNo(s) { }
	Sales_data(const std::string &s, unsigned n, double p):
	           bookNo(s), units_sold(n), revenue(p*n) { }
	Sales_data(std::istream &);
	std::string isbn() const { return bookNo; }
	Sales_data& combine(const Sales_data&);
private:    // 添加了访问说明符
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
```

作为接口的一部分，构造函数和部分成员函数（即 `isbn` 和 `combine`）紧跟在 `public` 说明符之后；而数据成员和作为实现部分的函数则跟在 `private` 说明符的后面。

<mark>一个类可以包含 0 个或多个访问说明符，而且对于某个访问说明符能出现多少次也没有严格限定</mark>。每个访问说明符指定了接下来的成员的访问级别，其有效范围直到出现下一个访问说明符或者到达类的结尾处为止。

##### 使用 class 或 struct 关键字

在上面的定义中我们还做了一个微妙的变化，我们使用了 `class` 关键字而非 `struct` 开始类的定义。这种变化仅仅是形式上有所不同，实际上我们可以使用这两个关键字中的任何一个定义类。唯一的一点区别是，`struct` 和 `class` 的**默认访问权限不太一样**。

类可以在它的第一个访问说明符之前定义成员，对这种成员的访问权限依赖于类定义的方式。如果我们使用 `struct` 关键字，则定义在第一个访问说明符之前的成员是 `pub1ic` 的：相反，如果我们使用 `class` 关键字，则这些成员是 `private` 的。

出于统一编程风格的考虑，当我们希望定义的类的所有成员是 `pub1ic` 的时，使用 `struct`；反之，如果希望成员是 `private` 的，使用 `class`。

> 警告：使用 `class` 和 `struct` 定义类唯一的区别就是默认的访问权限。

#### 7.2.1 友元

既然 `Sales_data` 的数据成员是 `private` 的，我们的 `read`、`print` 和 `add` 函数〔非成员函数〕也就无法正常编译了，这是因为尽管这几个函数是类的接口的一部分，但它们不是类的成员。

类可以允许其他类或者函数访问它的非公有成员，方法是令其他类或者函数成为它的**友元**（`friend`）。如果类想把一个函数作为它的友元，只需要增加一条以 `friend` 关键字开始的函数声明语句即可：

```cpp
class Sales_data {
// 为 Sales_data 的非成员函数所做的友元声明
friend Sales_data add(const Sales_data&, const Sales_data&);
friend std::ostream &print(std::ostream&, const Sales_data&);
friend std::istream &read(std::istream&, Sales_data&);
// 其他成员及访问说明符与之前的一致
public:
	Sales_data() = default;
	Sales_data(const std::string &s): bookNo(s) { }
	Sales_data(const std::string &s, unsigned n, double p):
	           bookNo(s), units_sold(n), revenue(p*n) { }
	Sales_data(std::istream &);
	std::string isbn() const { return bookNo; }
	Sales_data& combine(const Sales_data&);
private:
	double avg_price() const;
	std::string bookNo;
	unsigned units_sold = 0;
	double revenue = 0.0;
};
// Sales_data 接口的非成员组成部分的声明
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

<mark>友元声明只能出现在类定义的内部</mark>，但是在类内出现的具体位置不限。<mark>友元不是类的成员也不受它所在区域访问控制级别的约束</mark>。我们将在 7.3.4 节介绍更多关于友元的知识。

> 提示：一般来说，最好在类定义开始或结束前的位置集中声明友元。

> 关键概念：封装的益处<br>
> 封装有两个重要的优点：<br>
>
> - 确保用户代码不会无意间破坏封装对象的状态。
> - 被封装的类的具体实现细节可以随时改变，而无须调整用户级别的代码。
>
> 一旦把数据成员定义成 `private` 的，类的作者就可以比较自由地修改数据了。当实现部分改变时，我们只需要检查类的代码本身以确认这次改变有什么影响：换句话说，只要类的接口不变，用户代码就无须改变。如果数据是 `public` 的，则所有使用了原来数据成员的代码都可能失效，这时我们必须定位并重写所有依赖于老版本实现的代码，之后才能重新使用该程序。〔比如增加/删除数据成员或者改变数据成员的名字〕<br>
> 把数据成员的访问权限设成 `private` 还有另外一个好处，这么做能防止由于用户的原因造成数据被破坏。如果我们发现有程序缺陷破坏了对象的状态，则可以在有限的范围内定位缺陷：因为只有实现部分的代码可能产生这样的错误。因此，将查错限制在有限范围内将能极大地降低维护代码及修正程序错误的难度。<br>
> 注意：尽管当类的定义发生改变时无须更改用户代码，但是使用了该类的源文件必须重新编译。

##### 友元的声明

友元的声明仅仅指定了访问的权限，而非一个通常意义上的函数声明。如果我们希望类的用户能够调用某个友元函数，那么我们就必须在友元声明之外再专门对函数进行一次声明。

为了使友元对类的用户可见，我们通常把友元的声明与类本身放置在同一个头文件中（**类的外部**）。因此，我们的 `Sales_data` 头文件应该为 `read`、`print` 和 `add` 提供独立的声明（除了类内部的友元声明之外）。

> 注意：许多编译器并未强制限定友元函数必须在使用之前在类的外部声明。

一些编译器允许在尚无友元函数的初始声明的情况下就调用它。不过即使你的编译器支持这种行为，最好还是提供一个独立的函数声明。这样即使你更换了一个有这种强制要求的编译器，也不必改变代码。

### 7.3 类的其它特性

虽然 `Sales_data` 类非常简单，但是通过它我们已经了解 C++ 语言中关于类的许多语法要点。在本节中，我们将继续介绍 `Sales_data` 没有体现出来的一些类的特性。这些特性包括：**类型成员**、**类的成员的类内初始值**、**可变数据成员**、**内联成员函数**、**从成员函数返回** `*this`、关于**如何定义并使用类类型及友元类**的更多知识。

#### 7.3.1 类成员再探

为了展示这些新的特性，我们需要定义**一对相互关联的类**，它们分别是 `Screen` 和 `Window_mgr`。

```cpp
// Screen.h
#include "Version_test.h"

#include <string>
#include <iostream>

class Screen {
public:
    typedef std::string::size_type pos;
#if defined(IN_CLASS_INITS) && defined(DEFAULT_FCNS)
	Screen() = default;  // needed because Screen has another constructor
#else
	Screen(): cursor(0), height(0), width(0) { }
#endif
	// cursor initialized to 0 by its in-class initializer
    Screen(pos ht, pos wd, char c): height(ht), width(wd),
	                                contents(ht * wd, c) { }
	friend class Window_mgr;
    Screen(pos ht = 0, pos wd = 0):
       cursor(0), height(ht), width(wd), contents(ht * wd, ' ') { }
    char get() const              // get the character at the cursor
	    { return contents[cursor]; }       // implicitly inline
    inline char get(pos ht, pos wd) const; // explicitly inline
	Screen &clear(char = bkground);
private:
	static const char bkground = ' ';
public:
    Screen &move(pos r, pos c);      // can be made inline later
    Screen &set(char);
    Screen &set(pos, pos, char);
	// other members as before
    // display overloaded on whether the object is const or not
    Screen &display(std::ostream &os)
                  { do_display(os); return *this; }
    const Screen &display(std::ostream &os) const
                  { do_display(os); return *this; }
private:
     // function to do the work of displaying a Screen
     void do_display(std::ostream &os) const {os << contents;}
	// other members as before
private:
#ifdef IN_CLASS_INITS
    pos cursor = 0;
    pos height = 0, width = 0;
#else
    pos cursor;
    pos height, width;
#endif
    std::string contents;
};

Screen &Screen::clear(char c)
{
	contents = std::string(height*width, c);
	return *this;
}

inline                   // we can specify inline on the definition
Screen &Screen::move(pos r, pos c)
{
    pos row = r * width; // compute the row location
    cursor = row + c;    // move cursor to the column within that row
    return *this;        // return this object as an lvalue
}

char Screen::get(pos r, pos c) const // declared as inline in the class
{
    pos row = r * width;      // compute row location
    return contents[row + c]; // return character at the given column
}

inline Screen &Screen::set(char c)
{
    contents[cursor] = c; // set the new value at the current cursor location
    return *this;         // return this object as an lvalue
}
inline Screen &Screen::set(pos r, pos col, char ch)
{
	contents[r*width + col] = ch;  // set specified location to given value
	return *this;                  // return this object as an lvalue
}
```

```cpp
// WindowMgr.h
#ifndef WINDOW_MGR
#define WINDOW_MGR

#include <vector>
#include <string>
#include <iostream>
#include "newscreen.h"

class BitMap;
// overloaded storeOn functions
extern std::ostream& storeOn(std::ostream &, Screen &);
extern BitMap& storeOn(BitMap &, Screen &);

class Window_mgr {
public:
	// location ID for each screen on the window
	using ScreenIndex = std::vector<Screen>::size_type;
	// add a Screen to the window and returns its index

	ScreenIndex addScreen(const Screen&);

	// reset the Screen at the given position to all blanks
	void clear(ScreenIndex);

	// change dimensions of a given Screen
	void resize(Screen::pos r, Screen::pos c, ScreenIndex i);
private:
	// Screens this Window_mgr is tracking
	// by default, a Window_mgr has one standard sized blank Screen
	std::vector<Screen> screens{Screen(24, 80, ' ')};
};

// return type is seen before we're in the scope of Window_mgr
inline
Window_mgr::ScreenIndex
Window_mgr::addScreen(const Screen &s)
{
	screens.push_back(s);
	return screens.size() - 1;
}

inline
void Window_mgr::clear(ScreenIndex i)
{
	// s is a reference to the Screen we want to clear
	Screen &s = screens[i];
	// reset the contents of that Screen to all blanks
	s.contents = std::string(s.height * s.width, ' ');
}

inline
void
Window_mgr::resize(Screen::pos r, Screen::pos c, ScreenIndex i)
{
    screens[i].height = r;  // Window_mgr is a friend of Screen
    screens[i].width = c;   // so it is ok to use Screen's private members
	// resize and clear the contents member
	screens[i].contents = std::string(r * c, ' ');
}

#endif
```

##### 定义一个类型成员

`Screen` 表示显示器中的一个窗口。每个 `Screen` 包含一个用于保存 `Screen` 内容的 `string` 成员和三个`string:size_type` 类型的成员，它们分别表示光标的位置以及屏幕的高和宽。

除了定义数据和函数成员之外，类还可以自定义某种类型在类中的别名。由类定义的类型名字和其他成员一样存在访问限制，可以是 `public` 或者 `private` 中的一种：

```cpp
class Screen {
public:
    typedef std::string::size_type pos;
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```

我们在 `Screen` 的 `public` 部分定义了 `pos`，这样用户就可以使用这个名字。`Screen` 的用户不应该知道 `Screen` 使用了一个 `string` 对象来存放它的数据，因此通过〔只〕把 `pos` 定义成 `public` 成员可以隐藏 `Screen` 实现的细节。

关于 `pos` 的声明有两点需要注意。首先，我们使用了 `typedef`，也可以等价地使用类型别名〔非必要不这样做〕：

```cpp
class Screen {
public:
    // 使用类型别名等价地声明一个类型名字
    using pos = std::string::size_type;
    // 其他成员与之前的版本一致
};
```

其次，<mark>用来定义类型的成员必须先定义后使用</mark>，这一点与普通成员有所区别，具体原因将在 7.4.1 节解释。因此，**类型成员通常出现在类开始的地方**。

##### Screen 类的成员函数

要使我们的类更加实用，还需要添加一个**构造函数**令用户能够定义屏幕的尺寸和内容，以及其他两个成员〔函数〕，分别负责移动光标和读取给定位置的字符：

```cpp
class Screen {
public:
    typedef std::string::size_type pos;
    Screen() = default;    // 因为 Screen 有另一个构造函数，所以本函数是必需的
                            // cursor 被其类内初始值初始化为 0
    Screen(pos ht, pos wd, char c): height(ht), width(wd), contents(ht * wd, c) { }
    char get() const                        // 读取光标处的字符
        { return contents[cursor]; }        // 隐式内联
    inline char get(pos ht, pos wd) const;  // 显式内联
    Screen &move(pos r, pos c);             // 能在之后被设为内联
private:
    pos cursor = 0;
    pos height = 0, width = 0;
    std::string contents;
};
```

需要指出的是，第二个构造函数（接受三个参数）为 `cursor` 成员隐式地使用了类内初始值。如果类中不存在 `cursor` 的类内初始值，我们就需要像其他成员一样显式地初始化 `cursor` 了。

##### 令成员作为内联函数

在类中，常有一些规模较小的函数适合于被声明成内联函数。如我们之前所见的，<mark>定义在类内部的成员函数是自动 `inline` 的</mark>。因此，`Screen` 的构造函数和返回光标所指字符的 `get` 函数默认是 `inline` 函数。

我们可以在类的内部把 `inline` 作为声明的一部分显式地声明成员函数，同样的，也能在类的外部用 `inline` 关键字修饰函数的定义：

```cpp
inline                                  // 可以在函数的定义处指定 inline
Screen &Screen::move(pos r, pos c)
{
    pos row = r * width;                // 计算行的位置
    cursor = row + c;                   // 在行内将光标移动到指定了列
    return *this;                       // 以左值的形式返回对象
}
char Screen::get(pos r, pos c) const    // 在类的内部声明成 inline
{
    pos row = r * width;                // 计算行的位置
    return contents[row + c];           // 返回给定列的字符
}
```

虽然我们无须在声明和定义的地方同时说明 `inline`，但这么做其实是合法的。不过，**最好只在类外部定义的地方说明**`inline`，**这样可以使类更容易理解**。

> 注意：和我们在头文件中定义 `inline` 函数的原因一样，`inline` 成员函数也应该与相应的类定义在同一个头文件中。〔明确声明为 `inline` 的函数与相应的类定义在同一个头文件中〕

##### 重载成员函数

和非成员函数一样，成员函数也可以被重载，只要函数之间在参数的数量和/或类型上有所区别就行。成员函数的函数匹配过程同样与非成员函数非常类似。

举个例子，我们的 `Screen` 类定义了两个版本的 `get` 函数。一个版本返回光标当前位置的字符：另一个版本返回由行号和列号确定的位置的字符。编译器根据实参的数量来决定运行哪个版本的函数：

```cpp
Screen myscreen;
char ch = myscreen.get();   // 调用 Screen::get()
ch = myscreen.get(0, 0);    // 调用 Screen::get(pos, pos)
```

##### 可变数据成员

有时（但并不频繁）会发生这样一种情况，**我们希望能修改类的某个数据成员，即使是在一个** `const` **成员函数内**。可以通过在变量的声明中加入 `mutable` 关键字做到这一点。

一个**可变数据成员**（mutable data member）永远不会是 `const`，即使它是 `const` 对象的成员。因此，一个 `const` 成员函数可以改变一个可变成员的值。举个例子，我们将给 `Screen` 添加一个名为 `access ctr` 的可变成员，通过它我们可以追踪每个 `Screen` 的成员函数被调用了多少次：

```cpp
class Screen {
public:
    void some_member() const;
private:
    mutable size_t access_ctr;  // 即使在一个 const 对象内也能被修改
    // 其他成员与之前的版本一致
};
void Screen::some_member() const
{
    ++access_ctr;   // 保存一个计数值，用于记录成员函数被调用的次数
    // 该成员需要完成的其他工作
}
```

尽管 `some member` 是一个 `const` 成员函数，它仍然能够改变 `access ctr` 的值。<mark>该成员是个可变成员，因此任何成员函数，包括 `const` 函数在内都能改变它的值</mark>。

##### 类数据成员的初始值

在定义好 `Screen` 类之后，我们将继续**定义一个窗口管理类并用它表示显示器上的一组** `Screen`。这个类将包含一个 `Screen` 类型的 `vector`，每个元素表示一个特定的 `Screen`。

默认情况下，我们希望 `window mgr` 类开始时总是拥有一个默认初始化的 `Screen`。在 C++11 新标准中，最好的方式就是把这个默认值声明成一个类内初始值：

```cpp
class Window_mgr {
private:
    // 这个 Window_mgr 追踪的 Screen
    // 默认情况下，一个 Window_mgr 包含一个标准尺寸的空白 Screen
    std::vector<Screen> screens{Screen(24, 80, ' ')};
}
```

**当我们初始化类类型的成员时，需要为构造函数传递一个符合成员类型的实参**。在此例中，我们使用一个单独的元素值对 `vector` 成员执行了列表初始化，这个 `Screen` 的值被传递给 `vector<Screen>` 的构造函数，从而创建了一个单元素的 `vector` 对象。具体地说，`Screen` 的构造函数接受两个尺寸参数和一个字符值，创建了一个给定大小的空白屏幕对象。

如我们之前所知的，<mark>类内初始值必须使用 `=` 的初始化形式（初始化 `Screen` 的数据成员时所用的）或者花括号括起来的直接初始化形式（初始化 `screens` 所用的）</mark>。

> 注意：当我们提供一个类内初始值时，必须以符号 `=` 或者花括号表示。

#### 7.3.2 返回 \*this 的成员函数

接下来我们继续添加一些函数，它们负责设置光标所在位置的字符或者其他任一给定位置的字符：

```cpp
class Screen {
public:
    Screen &set(char);
    Screen &set(pos, pos, char);
    // 其他成员和之前的版本一致
};
inline Screen &Screen::set(char c)
{
    contents[cursor] = c;       // 设置当前光标所在位置的新值
    return *this;               // 将 this 对象作为左值返回
}
inline Screen &Screen::set(pos r, pos col, char ch)
{
    contents[r * width + col] = ch;     // 设置给定位置的新值
    return *this;                       // 将 this 对象作为左值返回
}
```

和 `move` 操作一样，我们的 `set` 成员的返回值是调用 `set` 的对象的引用。返回引用的函数是左值的，意味着这些函数返回的是对象本身而非对象的副本。如果我们把一系列这样的操作连接在一条表达式中的话：

```cpp
// 把光标移动到一个指定的位置，然后设置该位置的字符值
myScreen.move(4, 0).set('#');
```

这些操作将在同一个对象上执行。在上面的表达式中，我们首先移动 `myScreen` 内的光标，然后设置 `myScreen` 的 `contents` 成员。也就是说，上述语句等价于

```cpp
myScreen.move(4, 0);
myScreen.set('#');
```

如果我们令 `move` 和 `set` 返回 `Screen` 而非 `Screen&`，则上述语句的行为将大不相同。在此例中等价于：

```cpp
// 如果 move 返回 Screen 而非 Screen&
Screen temp = myScreen.move(4, 0);      // 对返回值进行拷贝
temp.set('#');                          // 不会改变 myScreen 的 contents
```

假如当初我们定义的返回类型不是引用，则 `move` 的返回值将是 `*this` 的副本，因此调用 `set` 只能改变临时副本，而不能改变 `myScreen` 的值。

##### 从 const 成员函数返回 \*this

接下来，我们继续添加一个名为 `display` 的操作，它负责打印 `Screen` 的内容。我们希望这个函数能和 `move` 以及 `set` 出现在同一序列中，因此类似于 `move` 和 `set`，`display` 函数也应该返回执行它的对象的引用。

从逻辑上来说，显示一个 `Screen` 并不需要改变它的内容，因此我们令 `display` 为一个 `const` 成员，此时，`this` 将是一个指向 `const` 的指针而 `*this` 是 `const` 对象。由此推断，`display` 的返回类型应该是 `const Sales data&`。然而，如果真的令 `display` 返回一个 `const` 的引用，则我们将不能把 `display` 嵌入到一组动作的序列中去：

```cpp
Screen myScreen;
// 如果 display 返回常量引用，则调用 set 将引发错误
myScreen.display(cout).set('*');
```

即使 `myScreen` 是个非常量对象，对 `set` 的调用也无法通过编译。问题在于 `display` 的 `const` 版本返回的是常量引用，而我们显然无权 `set` 一个常量对象。

> 注意：一个 `const` 成员函数如果以引用的形式返回 `*this`，那么它的返回类型将是常量引用。

##### 基于 const 的重载

**通过区分成员函数是否是** `const` **的，我们可以对其进行重载**，其原因与我们之前根据指针参数是否指向 `const` 而重载函数的原因差不多。具体说来，因为非常量版本的函数对于常量对象是不可用的，所以我们只能在一个常量对象上调用 `cost` 成员函数。另一方面，虽然可以在非常量对象上调用常量版本或非常量版本，但显然此时非常量版本是一个更好的匹配。

在下面的这个例子中，我们将定义一个名为 `do_display` 的私有成员，由它负责打印 `Screen` 的实际工作。所有的 `display` 操作都将调用这个函数，然后返回执行操作的对象：

```cpp
class Screen {
public；
    // 根据对象是否是 const 重载了 display 函数
    Screen &display(std::ostream &os)
        { do_display(os); return *this; }
    const Screen &display(syd::ostream &os) const
        { do_display(os); return *this; }
private:
    // 该函数负责显示 Screen 的内容
    void do_display(std::ostream &os) const { os << contents; }
    // 其它成员与之前的版本一致
};
```

和我们之前所学的一样，当一个成员调用另外一个成员时，`this` 指针在其中隐式地传递。因此，当 `display` 调用 `do _display` 时，它的 `this` 指针隐式地传递给 `do_display`。而当 `display` 的非常量版本调用 `do _display` 时，它的 `this` 指针将隐式地从指向非常量的指针转换成指向常量的指针。

当 `do _display` 完成后，`display` 函数各自返回解引用 `this` 所得的对象。在非常量版本中，`this` 指向一个非常量对象，因此 `display` 返回一个普通的（非常量）引用：而 `const` 成员则返回一个常量引用。

当我们在某个对象上调用 `display` 时，该对象是否是 `const` 决定了应该调用 `display` 的哪个版本：

```cpp
Screen myScreen(5, 3);
const Screen blank(5, 3);
myScreen.set('#').display(cout);    // 调用非常量版本
blank.display(cout);                // 调用常量版本
```

> 建议：对于公共代码使用私有功能函数
> 有些读者可能会奇怪为什么我们要费力定义一个单独的 `do_display` 函数。毕竟，对 `do_display` 的调用并不比 `do _display` 函数内部所做的操作简单多少。为什么还要这么做呢？实际上我们是出于以下原因的：
>
> - 一个基本的愿望是避免在多处使用同样的代码。
> - 我们预期随着类的规模发展，`display` 函数有可能变得更加复杂，此时，把相应的操作写在一处而非两处的作用就比较明显了。
> - 我们很可能在开发过程中给 `do _display` 函数添加某些调试信息，而这些信息将在代码的最终产品版本中去掉。显然，只在 `do_display` 一处添加或删除这些信息要更容易一些。
> - 这个额外的函数调用不会增加任何开销。因为我们在类内部定义了 `do_display`，所以它隐式地被声明成内联函数。这样的话，调用 `do_display` 就不会带来任何额外的运行时开销。
>   在实践中，设计良好的 C++ 代码常常包含大量类似于 `do_display` 的小函数，通过调用这些函数，可以完成一组其他函数的“实际”工作。

#### 7.3.3 类类型

每个类定义了唯一的类型。对于两个类来说，即使它们的成员完全一样，这两个类也是两个不同的类型。所以不能进行赋值操作。

> 注意：即使两个类的成员列表完全一致，它们也是不同的类型。对于一个类来说，它的成员和其他任何类（或者任何其他作用域）的成员都不是一回事儿。

**我们可以把类名作为类型的名字使用，从而直接指向类类型**。或者，我们也可以把类名跟在关键字 class 或 struct 后面：

```cpp
Sales_data item1;           // 默认初始化 Sales_data 类型的成员
class Sales_data item1;     // 一条等价的声明
```

上面这两种使用类类型的方式是等价的，其中第二种方式从 C 语言继承而来，并且在 C++ 语言中也是合法的。

##### 类的声明〔非必要不使用〕

就像可以把函数的声明和定义分离开来一样，我们也能仅仅声明类而暂时不定义它：

```cpp
class Screen;           // Screen 类的声明
```

这种声明有时被称作**前向声明**（forward declaration），它向程序中引入了名字 `Screen` 并且指明 `Screen` 是一种类类型。对于类型 `Screen` 来说，在它声明之后定义之前是一个**不完全类型**（incomplete type），也就是说，此时我们已知 `Screen` 是一个类类型，但是不清楚它到底包含哪些成员。

不完全类型只能在非常有限的情景下使用：**可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数**。

<mark>对于一个类来说，在我们创建它的对象之前该类必须被定义过，而不能仅仅被声明</mark>。否则，编译器就无法了解这样的对象需要多少存储空间。类似的，类也必须首先被定义，然后才能用引用或者指针访问其成员。毕竟，如果类尚未定义，编译器也就不清楚该类到底有哪些成员。

</mark>直到类被定义之后数据成员才能被声明成这种类类型</mark>，在 7.6 节中我们将描述一种例外的情况〔静态成员可以是不完全类型〕。换句话说，**我们必须首先完成类的定义，然后编译器才能知道存储该数据成员需要多少空间**。因为只有当类全部完成后类才算被定义，所以一个类的成员类型不能是该类自己。然而，一旦一个类的名字出现后，它就被认为是声明过了（但尚未定义），因此类允许包含指向它自身类型的引用或指针：

```cpp
class Link_Screen {
    Screen window;
    Link_screen *next;
    Link_screen *prev;
}
```

#### 7.3.4 友元再探

我们的 `Sales_data` 类把三个普通的非成员函数定义成了友元。类还可以把其他的类定义成友元，也可以把其他类（之前己定义过的）的成员函数定义成友元。此外，友元函数能定义在类的内部，这样的函数是隐式内联的。

##### 类之间的友元关系

举个友元类的例子，我们的 `Window_mgr` 类的某些成员可能需要访问它管理的 `Screen` 类的内部数据。例如，假设我们需要为 `Window_mgr` 添加一个名为 `clear` 的成员，它负责把一个指定的 `Screen` 的内容都设为空白。为了完成这一任务，`clear` 需要访问 `Screen` 的私有成员；而要想令这种访问合法，`Screen` 需要把 `Window_mgr` 指定成它的友元：

```cpp
class Screen {
    // Window_mgr 的成员可以访问 Screen 类的私有部分
    friend class Window_mgr;
    // Screen 类的剩余部分
}
```

如果一个类指定了友元类，则友元类的成员函数可以访问此类包括非公有成员在内的所有成员。通过上面的声明，`Window_mgr` 被指定为 `Screen` 的友元，因此我们可以将 `window_mgr` 的 `clear` 成员写成如下的形式：

```cpp
class Window_mgr {
public:
    // 窗口中每个屏幕的编号
    using ScreenIndex = std::vector<Screen>::size_type;
    // 按照编号将指定的 Screen 重置为空白
    void clear{ScreenIndex};
private:
    std::vector<Screen> screens{Screen(24, 80, ' ')};
};
void Window_mgr::clear(ScreenIndex i)
{
    // s 是一个 Screen 的引用，指向我们想清空的那个屏幕
    Screen &s = screens[i];
    // 将那个选定的 Screen 重置为空白
    s.contents = string(s.height * s.width, ' ');
}
```

一开始，首先把 `s` 定义成 `screens vector` 中第 `i` 个位置上的 `Screen` 的引用，随后利用 `Screen` 的 `height` 和 `width` 成员计算出一个新的 `string` 对象，并令其含有若干个空白字符，最后我们把这个含有很多空白的字符串赋给 `contents` 成员。〔这里的清空屏幕是通过 `s.height * s.width` 个空格填充 `s.contents` 实现的〕

如果 `clear` 不是 `Screen` 的友元，上面的代码将无法通过编译，因为此时 `clear` 将不能访问 `Screen` 的 `height`、`width` 和 `contents` 成员。而当 `Screen` 将 `Window_mgr` 指定为其友元之后，`Screen` 的所有成员对于 `window_mgr` 就都变成可见的了。

必须要注意的一点是，<mark>友元关系不存在传递性</mark>。也就是说，如果 `window_mgr` 有它自己的友元，则这些友元并不能理所当然地具有访问 `Screen` 的特权。

> 每个类负责控制自己的友元类或非友元函数。

除了令整个 `Window_mgr` 作为友元之外，`Screen` 还可以只为 `clear` 提供访问权限。当把一个成员函数声明成友元时，我们必须明确指出该成员函数属于哪个类：

```cpp
class Screen {
    // Window_mgr::clear 必须在 Screen 类之前被声明
    friend void Window_mgr::clear(ScreenIndex)
    // Screen 类的剩余部分
}
```

要想令某个成员函数作为友元，我们必须仔细组织程序的结构以满足声明和定义的彼此依赖关系。在这个例子中，我们必须按照如下方式设计程序：

- 首先定义 `Window_mgr` 类，其中声明 `clear` 函数，但是不能定义它。在 `clear` 使用 `Screen` 的成员之前必须先声明 `Screen`。
- 接下来定义 `Screen`，包括对于 `clear` 的友元声明。
- 最后定义 `clear`，此时它才可以使用 `Screen` 的成员。

##### 函数重载和友元

尽管重载函数的名字相同，但它们仍然是不同的函数。因此，如果一个类想把一组重载函数声明成它的友元，它需要对这组函数中的每一个分别声明：
```cpp
// 重载的 storeOn 函数
extern std::ostream& storeOn(std::ostream &, Screen &);
extern BitMap& storeOn(BitMap &, Screen &);
class Screen {
    // storeOn 的 ostream 版本能访问 Screen 对象的私有部分
    friend std::ostream& storeOn(std::ostream &, Screen &);
    // ...
};
```
`Screen` 类把接受 `ostream&` 的 `storeOn` 函数声明成它的友元，但是接受 `BitMap&` 作为参数的版本仍然不能访问 `Screen`。 

##### 友元声明和作用阈

类和非成员函数的声明不是必须在它们的友元声明〔将前者作为友元的另一个类的友元声明〕之前。当一个名字第一次出现在一个友元声明中时，我们隐式地假定该名字在当前作用域中是可见的。〔在当前作用域可见，意味着正式声明之后可以被该作用域的函数调用〕然而，友元本身不一定真的声明在当前作用域中。〔如果本身没有声明在当前作用域，则该作用域内不能使用该友元函数〕

<mark>甚至就算在类的内部定义该〔友元〕函数，我们也必须在类的外部提供相应的声明从而使得函数可见</mark>。换句话说，即使我们仅仅是用声明友元的类的成员〔这里是构造函数和成员函数〕调用该友元函数，它也必须是被声明过的：
```cpp
struct X {
    friend void f() { /*友元函数可以定义在类的内部*/ }
    X() { f(); }            // 错误：f 还没有被声明
    void g();
    void h();
};
void X::g() { return f(); }     // 错误：f 还没有被声明
void f();                       // 声明那个定义在 X 中的函数
void X::h() { return f(); }     // 正确：现在 f 的声明在作用域中了
```
关于这段代码最重要的是理解友元声明的作用是影响访问权限，它本身并非普通意义上的声明。

> 注意：请注意，有的编译器并不强制执行上述关于友元的限定规则。

### 7.4 类的作用域

### 7.5 构造函数再探

### 7.6 类的静态成员
