## 内容提要

本章介绍用于分析数字电路逻辑功能的数学方法一逻辑代数。首先将介绍逻辑代数的基本公式、常用公式和几个重要的定理，然后讲授逻辑函数的各种描述方法以及这些描述方法之间的互相转换。最后，介绍逻辑函数的化简方法。

## 2.1 概述

1. 二值逻辑：在数字逻辑电路中，用 1 位二进制数码的 0 和 1 表示一个事物的两种不同逻辑状态。例如，可以用 1 和 0 分别表示一件事情的是和非、真和伪、有和无、好和坏，或者表示电路的通和断、电灯的亮和暗、门的开和关等等。这种只有两种对立逻辑状态的逻辑关系称为二值逻辑。
2. 逻辑运算：所谓“逻辑”，在这里是指事物间的因果关系。当两个二进制数码表示不同的逻辑状态时，它们之间可以按照指定的某种因果关系进行推理运算。我们将这种运算称为逻辑运算。逻辑运算表示的是逻辑变量及常量之间逻辑状态的推理运算，而不是数量之间的运算。
3. 布尔代数：1849 年由英国数学家乔治·布尔（George Boole）首先提出的进行逻辑运算的数学方法。后来，由于布尔代数被广泛应用于解决开关电路和数字逻辑电路的分析和设计中，所以也将布尔代数称为**开关代数**或**逻辑代数**。本章所讲的逻辑代数就是布尔代数在二值逻辑电路中的应用。
4. 逻辑变量：逻辑代数中也用字母表示变量，这种变量称为逻辑变量。

## 2.2 逻辑代数中的三种基本运算

逻辑代数的基本运算有**与**（AND）、**或**（OR）、**非**（NOT）三种。

- 只有决定事物结果的全部条件同时具备时，结果才发生。这种因果关系称为**逻辑与**，或称**逻辑相乘**。
- 在决定事物结果的诸条件中只要有任何一个满足，结果就会发生。这种因果关系称为**逻辑或**，也称**逻辑相加**。
- 只要条件具备了，结果便不会发生；而条件不具备时，结果一定发生。这种因果关系称为**逻辑非**，也称**逻辑求反**。
- 同时，将实现与逻辑运算的单元电路称为**与门**，将实现或逻辑运算的单元电路称为**或门**，将实现非逻辑运算的单元电路称为**非门**（也称为**反相器**）。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\真值表.png"/><br>
</div>

与、或、非逻辑运算还可以用图形符号表示。图 2.2.2 中给出了被 EEE（电气与电子工程师协会）和 EC（国际电工协会）认定的两套与、或、非的图形符号，其中一套是目前在国外教材和 EDA 软件中普遍使用的特定外形符号，如图 2.2.2 (a) 所示。另一套是矩形轮廓的符号，如图 2.2.2(b) 所示。本书中采用特定外形符号。

实际的逻辑问题往往比与、或、非复杂得多，不过它们都可以用与、或、非的组合来实现。最常见的复合逻辑运算有**与非**（NAND）、**或非**（NOR）、**与或非**（AND-NOR）、**异或**（EXCLUSIVE OR）、**同或**（EXCLUSIVE NOR）等。表 2.2.4 ~ 表 2.2.8 给出了这些复合逻辑运算的真值表。图 2.2.3 是它们的图形逻辑符号和运算符号。这些图形符号同样也有特定外形符号和矩形轮廓符号两种。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\复合逻辑真值表和图形符号.png"/><br>
</div>

由表 2.2.4 可见，将 $A$、$B$ 先进行与运算，然后将结果求反，最后得到的即为 $A$、$B$ 的**与非**运算结果。因此，可以把与非运算看作是与运算和非运算的组合。图 2.2.3 中图形符号上的小圆圈表示非运算。

**在与或非逻辑中**，$A$、$B$ 之间以及 $C$、$D$ 之间都是与的关系，只要 $A$、$B$ 或 $C$、$D$ 任何一组同时为 1，输出 $Y$ 就是 0。只有当每一组输入都不全是 1 时，输出 $Y$ 才是 1.

**异或**是这样一种逻辑关系：当 $A$、$B$ 不同时，输出 $Y$ 为 1；而当 $A$、$B$ 相同时，输出 $Y$ 为 0。异或也可以用与、或、非的组合表示。
$$AB = A \cdot B' + A'\cdot B \tag{2.2.4}$$

**同或**和异或相反，当 $A$、$B$ 相同时，$Y$ 等于 1，$A$、$B$ 不同时，$Y$ 等于 0。同或也可以写成与、或、非的组合形式
$$A\odot B = A\cdot B+A'\cdot B \tag{2.2.5}$$

而且，由表 2.2.7 和表 2.2.8 可见，**异或和同或互为反运算**，即
$$A\oplus B=(A\odot B)';\ A\odot B=(A\oplus B)' \tag{2.2.6}$$

为简化书写，允许将 $A \cdot B$ 简写成 $AB$，略去逻辑相乘的运算符号“$\cdot$”

## 2.3 逻辑代数的基本公式和常用公式

### 2.3.1 基本公式

表 2.3.1 给出了逻辑代数的基本公式。这些公式也称为**布尔恒等式**。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\逻辑代数的基本公式.png"/><br>
</div>

- 式（1）、（2）、（11）和（12）给出了变量与常量间的运算规则。
- 式（3）和（13）是同一变量的运算规律，也称为**重叠律**。
- 式（4）和（14）表示变量与它的反变量之间的运算规律，也称为**互补律**。
- 式（5）和（15）为**交换律**，式（6）和（16）为**结合律**，式（7）和（17）为**分配律**。
- 式（8）和（18）是著名的**德·摩根**（De.Morgan）定理，亦称**反演律**。在逻辑函数的化简和变换中经常要用到这一对公式。
- 式（9）表明，一个变量经过两次求反运算之后还原为其本身，所以该式又称为**还原律**。
- 式（10）是对 0 和 1 求反运算的规则，它说明 0 和 1 互为求反的结果。

这些公式的正确性可以用列**真值表**的方法加以验证。如果等式成立，那么将任何一组变量的取值代入公式两边所得的结果应该相等。因此，**等式两边所对应的真值表也必然相同**。

【例 2.3.1】用真值表证明表 2.3.1 中式（17）的正确性。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\式17的真值表.png"/><br>
</div>

### 2.3.2 若干常用公式

表 2.3.3 中列出了几个**常用公式**。这些公式是利用**基本公式**导出的。直接运用这些导出公式可以给化简逻辑函数的工作带来很大方便。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\若干常用公式.png"/><br>
</div>

表 2.3.3 中的各式证明如下：

1. 式（21）：$A + A \cdot B = A$
   $$\begin{align} A+A \cdot B &= A \cdot(1+B) \\\ &=A \cdot 1 \\\ &=A \end{align}$$
   上式说明，在两个乘积项相加时，若其中一项以另一项为因子，则该项是多余的，可以删去。
2. 式（22）：$A+A' \cdot B=A+B$
   $$\begin{align} A+A' \cdot B &= (A+A')\cdot (A+B) \\\ &=1\cdot (A+B) \\\ &=A+B \end{align}$$
   这一结果表明，两个乘积项相加时，如果一项取反后是另一项的因子，则此因子是多余的，可以消去。
3. 式（23）：$A\cdot B+A\cdot B'=A$
   $$\begin{align} A\cdot B+A\cdot B' &= A(B+B') \\\ &=A \cdot 1 \\\ &=A \end{align}$$
   这个公式的含义是，当两个乘积项相加时，若它们分别包含 $B$ 和 $B'$ 两个因子而其它因子相同，则两项定能合并，且可将 $B$ 和 $B'$ 两个因子消去。
4. 式（24）：$A\cdot (A+B)=A$
   $$\begin{align} A\cdot (A+B) &= A\cdot A+A\cdot B \\\ &=A+A\cdot B \\\ &=A\cdot (1+B) \\\ &=A \cdot 1 \\\ &=A  \end{align}$$
   该式说明，变量 $A$ 和包含 $A$ 的和相乘时，其结果等于 $A$，即可以将和消掉。
5. 式（25）：$A\cdot B+A'\cdot C+B\cdot C=A\cdot B+A'\cdot C$
   $$\begin{align} A \cdot B+A' \cdot C+B \cdot C &=A \cdot B+A' \cdot C+B \cdot C\left(A+A'\right) \\\ &=A \cdot B+A' \cdot C+A \cdot B \cdot C+A' \cdot B \cdot C \\\ &=A \cdot B \cdot(1+C)+A' \cdot C \cdot(1+B) \\\ &=A \cdot B+A' \cdot C \end{align} $$
   这个公式说明，若两个乘积项中分别包含 $A$ 和 $A'$ 两个因子，而这两个乘积项的其余因子组成第三个乘积项时，则第三个乘积项是多余的，可以消去。<br>
   从上式不难进一步导出：$A\cdot B+A'\cdot C+B\cdot C\cdot D=A\cdot B+A'\cdot C$
6. 式（26）：$A\cdot (A\cdot B)'=A\cdot B'$；$A'\cdot (A\cdot B)'=A'$
   $$\begin{align} A\cdot (A\cdot B)' &= A\cdot (A'+B') \\\ &=A\cdot A'+A\cdot B' \\\ &=A\cdot B' \end{align}$$
   上式说明，当 $A$ 和一个乘积项的非相乘，且 $A$ 为乘积项的因子时，则 $A$ 这个因子可以消去。
   $$\begin{align} A'\cdot (A\cdot B)' &= A'\cdot (A'+B') \\\ &=A'\cdot A'+A'\cdot B' \\\ &=A'\cdot (1+B') \\\ &=A' \end{align}$$
   此式表明，当 $A'$ 和一个乘积项的非相乘，且 $A$ 为乘积项的因子时，其结果就等于 $A'$。

   从以上的证明可以看到，这些常用公式都是从基本公式导出的结果。当然，还可以推导出更多的常用公式。

## 2.4 逻辑代数的基本定理

### 2.4.1 代入定理

在任何一个包含变量 $A$ 的逻辑等式中，若以另外一个逻辑式代入式中所有 $A$ 的位置，则等式仍然成立。这就是所谓的**代入定理**。

因为变量 $A$ 仅有 0 和 1 两种可能的状态，所以无论将 $A=0$ 还是 $A=1$ 代入逻辑等式，等式都一定成立。而任何一个逻辑式的取值也不外 0 和 1 两种，所以用它取代式中的 $A$ 时，等式自然也成立。因此，可以将代入定理看作无需证明的公理。

利用代入定理很容易把表 2.3.1 中的基本公式和表 2.3.3 中的常用公式推广为多变量的形式。

【例 2.4.1】用代入定理证明德·摩根定理也适用于多变量的情况。

$$(A+(B+C))'=A'\cdot (B+C)'=A'\cdot B' \cdot C' \\\ (A\cdot (B\cdot C))'=A'+(B\cdot C)'=A'+B'+C'$$

对一个乘积项或逻辑式求反时，应在乘积项或逻辑式外边加括号，然后对括号内的整个内容求反。

此外，在对复杂的逻辑式进行运算时，仍需遵守与普通代数一样的运算优先顺序，即先算括号里的内容，其次算乘法，最后算加法。

### 2.4.2 反演定理

对于任意一个逻辑式 $Y$，若将其中所有的“$\cdot$”换成“$+$”，“$+$”换成“$\cdot$”，0 换成 1，1 换成 0，原变量换成反变量，反变量换成原变量，则得到的结果就是 $Y'$。这个规律称为**反演定理**。

反演定理为求取已知逻辑式的反逻辑式提供了方便。

在使用反演定理时，还需注意遵守以下两个规则：

1. 仍需遵守“先括号、然后乘、最后加”的运算优先次序。
2. 不属于单个变量上的反号应保留不变。

德·摩根定理只不过是反演定理的一个特例而已。正是由于这个原因，才将它称为反演律。

【例 2.4.2】已知 $Y=A(B+C)+CD$，求 $Y'$。

$$\begin{align} Y'&=(A'+B'C')(C'+D')\\\ &=A'C'+B'C'+A'D'+B'C'D'\\\ &=A'C'+B'C'+A'D' \end{align}$$

【例 2.4.3】若 $Y=((AB'+C)'+D)'+C$，求 $Y'$。

$$\begin{align} Y' &=(((A'+B)C')'D')'C' \\\ &=((A'C'+BC')+D)C' \\\ &=A'C'+BC'+C'D \end{align}$$

### 2.4.3 对偶定理

若两逻辑式相等，则它们的对偶式也相等，这就是**对偶定理**。

所谓对偶式是这样定义的：对于任何一个逻辑式 $Y$，若将其中的“$\cdot$”换成“$+$”，“$+$”换成“$\cdot$”，0 换成 1，1 换成 0，则得到一个新的逻辑式 $Y^{\rm{D}}$，这个 $Y^{\rm{D}}$ 就称为 $Y$ 的对偶式，或者说 $Y$ 和 $Y^{\rm{D}}$ 互为对偶式。例如：

- 若 $Y=A(B+C)$，则 $Y^{\rm{D}}=A+BC$；
- 若 $Y=(AB+CD)'$，则 $Y^{\rm{D}}=((A+B)(C+D))'$；
- 若 $Y=AB+(C+D)'$，则 $Y^{\rm{D}}=(A+B)(CD)'$

为了证明两个逻辑式相等，也可以通过证明它们的对偶式相等来完成，因为有些情况下证明它们的对偶式相等更加容易。

【例 2.4.4】试证明表 2.3.1 中的式（17），即 $A+BC=(A+B)(A+C)$

首先写出等式两边的对偶式，得到 $A(B+C)$ 和 $AB+AC$

根据乘法分配律可知，这两个对偶式是相等的，亦即 $A(B+C)=AB+AC$。由对偶定理即可确定原来的两式也一定相等，于是式（17）得到证明。

如果仔细分析一下表 2.3.1 就能够发现，其中的公式（1）和（11）、（2）和（12）、（3）和（13）、（4）和（14）、（5）和（15）、（6）和（16）、（7）和（17）、（8）和（18）皆互为对偶式。因此，只要能证明公式（1）\~（8）成立，则公式（11）\~（18）已无需另做证明。

## 2.5 逻辑函数及其描述方法

### 2.5.1 逻辑函数

从上面讲过的各种逻辑关系中可以看到，如果以逻辑变量作为输入，以运算结果作为输出，那么当输入变量的取值确定之后，输出的取值便随之而定。因此，输出与输入之间乃是一种函数关系。这种函数关系称为逻辑函数（logic function），写作
$$Y=F(A,B,C,…)$$

由于变量和输出（函数）的取值只有 0 和 1 两种状态，所以我们所讨论的都是二值逻辑函数。

### 2.5.2 逻辑函数的描述方法

常用的逻辑函数描述方法有**逻辑真值表**、**逻辑函数式**（简称逻辑式或函数式）、**逻辑图**、**波形图**、**卡诺图**和**硬件描述语言**等。这一节只介绍前面四种方法，用卡诺图和硬件描述语言描述逻辑函数的方法将在后面做专门介绍。

#### 一、逻辑真值表

将输入变量所有的取值下对应的输出值找出来，列成表格，即可得到**真值表**。

#### 二、逻辑函数式

将输出与输入之间的逻辑关系写成与、或、非等运算的组合式，即逻辑代数式，就得到了所需的逻辑函数式。
$$Y=A(B+C)$$

#### 三、逻辑图

将逻辑函数式中各变量之间的与、或、非等逻辑关系用图形符号表示出来，就可以画出描述函数关系的逻辑图（logic diagram）。

<div align=center>
<img width=40% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\逻辑图.png"/><br>
</div>

#### 四、波形图

如果将逻辑函数输入变量每一种可能出现的取值与对应的输出值按时间顺序依次排列起来，就得到了描述该逻辑函数的波形图。这种波形图（waveform）也称为时序图（timing diagram）。在逻辑分析仪和一些计算机仿真工具中，经常以这种波形图的形式给出分析结果。此外，也可以通过实验观察这些波形图，以检验实际逻辑电路的功能是否正确。

<div align=center>
<img width=60% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\波形图.png"/><br>
</div>

#### 五、各种描述方法间的相互转换

从上面的讨论中可以看到，这几种描述方式各具有不同的特点。因此，在实际应用中，需要选择一种最合适的方式来描述所讨论的逻辑函数。当讨论的逻辑函数不是用我们所希望的描述方式给出时，就必须将给出的描述方式转换成我们所需要的描述方式。

既然同一个逻辑函数可以用多种不同的方法描述，那么这几种方法之间必能相互转换。

##### 1. 真值表与逻辑函数式的相互转换

首先讨论从真值表得到逻辑函数式的方法。为了便于理解转换的原理，先来讨论下面一个具体的例子。

【例 2.5.1】 已知一个奇偶判别函数的真值表如表 2.5.2 所示，试写出它的逻辑函数式。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\函数真值表.png"/><br>
</div>

$Y$ 的逻辑函数应当等于使其等于 1 的四个乘积项之和，即
$$Y=A'B'C'+A'BC+AB'C+ABC'$$

通过例 2.5.1 可以总结出由真值表写出逻辑函数式的一般方法，这就是：

1. 找出真值表中使逻辑函数 $Y=1$ 的那些输入变量取值的组合。
2. 每组输入变量取值的组合对应一个乘积项，其中取值为 1 的写入原变量，取值为 0 的写入反变量。
3. 将这些乘积项相加，即得 $Y$ 的逻辑函数式。

由逻辑式列出真值表就更简单了。这时只需将输入变量取值的所有组合状态逐一代入逻辑式求出函数值，列成表，即可得到真值表。

##### 2. 逻辑函数式与逻辑图的相互转换

从给定的逻辑函数式转换为相应的逻辑图时，只要用逻辑图形符号代替逻辑函数式中的逻辑运算符号并按运算优先顺序将它们连接起来，就可以得到所求的逻辑图了。

而在从给定的逻辑图转换为对应的逻辑函数式时，只要从逻辑图的输入端到输出端逐级写出每个图形符号的输出逻辑式，就可以在输出端得到所求的逻辑函数式了。

【例 2.5.3】已知逻辑函数为 $Y=(A+B'C)'+A'BC'+C$，画出其对应的逻辑图。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.5.3_逻辑图.png"/><br>
</div>

##### 3. 波形图与真值表的相互转换

在从已知的逻辑函数波形图求对应的真值表时，首先需要从波形图上找出每个时间段里输入变量与函数输出的取值，然后将这些输入、输出取值对应列表，就得到了所求的真值表。

在将真值表转换为波形图时，只需将真值表中所有的输入变量与对应的输出变量取值依次排列画成以时间为横轴的波形，就得到了所求的波形图，如我们前面已经做过的那样。

### 2.5.3 逻辑函数的两种标准形式

在讲述逻辑函数的标准形式之前，先介绍一下最小项和最大项的概念，然后再介绍逻辑函数的“最小项之和”及“最大项之积”这两种标准形式。

#### 一、最小项和最大项

##### 1. 最小项

在 $n$ 变量逻辑函数中，若 $m$ 为包含 $n$ 个因子的乘积项，而且这 $n$ 个变量均以原变量或反变量的形式在 $m$ 中出现一次，则称 m 为该组变量的最小项。

例如，$A$、$B$、$C$ 三个变量的最小项有 $A'B'C'$、$A'B'C$、$A'BC'$、$A'BC$、$AB'C'$、$AB'C$、$ABC'$、$ABC$ 共 8 个（即 $2^3$ 个）。$n$ 变量的最小项应有 $2^n$ 个。

输入变量的每一组取值都使 $2^n$ 个最小项中对应的一个最小项的值等于 1。例如，在三变量 $A$、$B$、$C$ 的最小项中，当 $A=1$、$B=0$、$C=1$时，$AB'C=1$。如果把 $AB'C$ 的取值 101 看做一个二进制数，那么它所表示的十进制数就是 5。为了今后使用的方便，将 $AB'C$ 这个最小项记作 $m_5$。按照这一约定，就得到了三变量最小项的编号表，如表 2.5.5 所示。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\表2.5.5_三变量最小项的编号表.png"/><br>
</div>
根据同样的道理，我们将 $A$、$B$、$C$、$D$ 这 4 个变量的 16 个最小项记作 $m_0~m_{15}$。

从最小项的定义出发可以证明它具有如下的重要性质：

1. 在输入变量的任何取值下必有一个最小项，而且仅由一个最小项的值为 1。
2. 全体最小项之和为 1。
3. 任意两个最小项的乘积为 0。
4. 具有相邻性的两个最小项之和可以合并成一项并消去一对因子。

若两个最小项只有一个因子不同，则称这两个最小项具有相邻性。例如，$A'BC'$ 和 $ABC'$ 两个最小项仅第一个因子不同，所以它们具有相邻性。这两个最小项相加时定能合并成一项并将一对不同的因子消去
$$A'BC'+ABC'=(A'+A)BC'=BC'$$

##### \*2. 最大项

在 $n$ 变量逻辑函数中，若 $M$ 为 $n$ 个变量之和，而且这 $n$ 个变量均以原变量或反变量的形式在 $M$ 中出现一次，则称 $M$ 为该组变量的最大项。

例如，三变量 $A$、$B$、$C$ 的最大项有 $A'+B'+C'$、$A'+B'+C$、$A'+B+C'$、$A'+B+C$、$A+B'+C'$、$A+B'+C$、$A+B+C'$、$A+B+C$ 共 8 个（即 $2^3$ 个）。对于 $n$ 个变量则有 $2^n$ 个最大项。可见，$n$ 变量的最大项数目和最小项数目是相等的。

输入变量的每一组取值都使一个对应的最大项的值为 0。例如，在三变量 $A$、$B$、$C$ 的最大项中，当 $A=1$、$B=0$、$C=1$ 时，$A'+B+C'=0$。若将使最大项为 0 的 $ABC$ 取值视为一个二进制数，并以其对应的十进制数给最大项编号，则 $(A'+B+C')$ 可记作 $M_5$。由此得到的三变量最大项编号表，如表 2.5.6 所示。

<div align=center>
<img width=90% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\表2.5.6_三变量最大项的编号表.png"/><br>
</div>

根据最大项的定义同样也可以得到它的主要性质，这就是：

1. 在输入变量的任何取值下必有一个最大项，而且只有一个最大项的值为 0。
2. 全体最大项之积为 0。
3. 任意两个最大项之和为 1。
4. 只有一个变量不同的两个最大项的乘积等于各相同变量之和。

如果将表 2.5.5 和表 2.5.6 加以对比则可以发现，最大项和最小项之间存在如下关系
$$M_i=m_i '$$

例如， $m_0=A'B'C'$，则 $m_0'=(A'B'C')'=A+B+C=M_0$。

##### 二、逻辑函数的最小项之和的形式

首先将给定的逻辑函数式化为若干乘积项之和的形式，亦称“积之和”（sum of products，简称 SOP）形式。然后，再利用基本公式 $A+A'=1$ 将每个乘积项中缺少的因子补全，这样就可以将与或的形式化为最小项之和的标准形式。这种标准形式在逻辑函数的化简以及计算机辅助分析和设计中得到了广泛的应用。

例如，给定逻辑函数为
$$Y=ABC'+BC$$
则可化为
$$\begin{align} Y &=ABC'+(A+A')BC \\\ &= ABC'+ABC+A'BC \\\ &=m_3+m_6+m_7\end{align}$$
或写作
$$Y(A,B,C)=\sum m(3,6,7)$$

##### \*三、逻辑函数的最大项之积的形式

利用逻辑代数的基本公式和定理，首先我们一定能把任何一个逻辑函数式化成若干多项式相乘的**或与**形式(也称“和之积”形式)。然后再利用基本公式 $AA'=0$ 将每个多项式中缺少的变量补齐，就可以将函数式的**或与**形式化成最大项之积的形式了。

【例 2.5.7】将逻辑函数 $Y=A'B+AC$ 化为最大项之积的形式。

首先可以利用基本公式 `A+BC=(A+B)(A+C)` 将 `Y` 化成或与形式
$$\begin{align} Y &=A'B+AC \\\ &=(A'B+A)(A'B+C) \\\ &= (A+B)(A'+C)(B+C) \end{align}$$

然后在第一个括号内加入一项 $CC'$，在第二个括号内加入 $BB'$，在第三个括号内加入 $AA'$，于是得到
$$\begin{align} Y&=(A+B+CC')(A'+BB'+C)(AA'+B+C) \\\ &=(A+B+C)(A+B+C')(A'+B+C)(A'+B'+C) \end{align}$$
或写作
$$Y(A,B,C,D)=\prod M(0,1,4,6)$$

## 2.6 逻辑函数的化简方法

### 2.6.1 公式化简法

在进行逻辑运算时常常会看到，同一个逻辑函数可以写成不同的逻辑式，而这些逻辑式的繁简程度又相差甚远。逻辑式越是简单，它所表示的逻辑关系越明显，同时也有利于用最少的电子器件实现这个逻辑函数。因此，经常需要通过化简的手段找出逻辑函数的最简形式。

**在与或逻辑函数式中，若其中包含的乘积项已经最少，而且每个乘积项里的因子也不能再减少时，则称此逻辑函数式为最简形式**。对与或逻辑式最简形式的定义对其他形式的逻辑式同样也适用，即函数式中相加的乘积项不能再减少，而且每项中相乘的因子不能再减少时，则函数式为最简形式。

<mark>化简逻辑函数的目的就是要消去多余的乘积项和每个乘积项中多余的因子，以得到逻辑函数式的最简形式</mark>。常用的化简方法有**公式化简法**、**卡诺图化简法**以及**适用于编制计算机辅助分析程序的 Q-M 法**等。

公式化简法的原理就是反复使用逻辑代数的基本公式和常用公式消去函数式中多余的乘积项和多余的因子，以求得函数式的最简形式。

公式化简法没有固定的步骤。现将经常使用的方法归纳如下。

#### 一、并项法

利用表 2.3.3 中的公式 $AB+AB'=A$ 可以将两项合并成一项，并消去 $B$ 和 $B'$ 这一对因子。而且，根据代入定理可知，$A$ 和 $B$ 均可以是任何复杂的逻辑式。

【例 2.6.1】试用并项法化简下列逻辑函数

$$\begin{align} Y_1&=A(B'CD)'+AB'CD \\\ &=A((B'CD)'+B'CD) \\\ &=A \\\ Y_2&=AB'+ACD+A'B'+A'CD\\\ &=A(B'+CD)+A'(B'+CD)\\\ &=B'+CD \\\ Y_3&=A'BC'+AC'+B'C'\\\ &=A'BC'+(A+B')C'\\\ &=(A'B)C'+(A'B)'C'\\\ &=C' \\\ Y_4&=BC'D+BCD'+BC'D'+BCD\\\ &=B(C'D+CD')+B(C'D'+CD)\\\ &=B(C\oplus D)=B(C\oplus D)'\\\ &=B \end{align}$$

#### 二、吸收法

利用表 2.3.3 中的公式 $A+AB=A$ 可将 $AB$ 项消去。$A$ 和 $B$ 同样也可以是任何一个复杂的逻辑式。

【例 2.6.2】试用吸收法化简下列逻辑函数

$$\begin{align} Y_1&=((A'B)'+C)ABD+AD\\\ &=((A'B)'+C)B\cdot AD+AD\\\ &=AD \\\ Y_2&=AB+ABC'+ABD+AB(C'+D')\\\ &=AB+AB(C'+D+(C'+D'))\\\ &=AB \\\ Y_3&=A+(A'(BC)')'(A'+(B'C'+D)')+BC\\\ &=(A+BC)+(A+BC)(A'+(B'C'+D)')\\\ &=A+BC \end{align}$$

#### 三、消项法

利用表 2.3.3 中的公式 $AB+A'C+BC=AB+A'C$ 及 $AB+A'C+BCD=AB+A'C$ 将 $BC$ 或 $BCD$ 项消去。其中 $A$、$B$、$C$、$D$ 均可以是任何复杂的逻辑式。

【例 2.6.3】用消项法化简下列逻辑函数

$$\begin{align} Y_1&=AC+AB'+(B+C)'\\\ &=AC+AB'+B'C'\\\ &=AC+B'C'\\\ Y_2 &=AB'CD'+(AB')'E+A'CD'E\\\ &=(AB')CD'+(AB')'E+(CD')(E)A'\\\ &=AB'CD'+(AB')'E\\\ Y_3 &=A'B'C+ABC+A'BD'+AB'D'+A'BCD'+BCD'E'\\\ &=(A'B'+AB)C+(A'B+AB')D'+BCD'(A'+E')\\\ &=(A\oplus B)'C+(A\oplus B)D'+CD'(B(A'+E'))\\\ &=(A\oplus B)'C+(A\oplus B)D' \end{align}$$

#### 四、消因子法

利用表 2.3.3 中的公式 $A+A'B=A+B$ 可将 $A'B$ 中的 $A'$ 消去。$A$、$B$ 均可以是任何复杂的逻辑式。

【例 2.6.4】试利用消因子法化简下列逻辑函数

$$\begin{align} Y_1&=B'+ABC\\\ &=B'+ABC\\\ &=B'+AC\\\ Y_2&=AB'+B+A'B\\\ &=AB'+B+A'B\\\ &=A+B+A'B\\\ &=A+B\\\ Y_3&=AC+A'D+C'D\\\ &=AC+A'D+C'D\\\ &=AC+(A'+C')D\\\ &=AC+(AC)'D\\\ &=AC+D \end{align}$$

#### 五、配项法

1. 根据基本公式中的 $A+A=A$ 可以在逻辑函数式中重复写入某一项，有时能获得更加简单的化简结果。例如：
   $$\begin{align} Y&=A'BC'+A'BC+ABC\\\ &=(A'BC'+A'BC)+(A'BC+ABC)\\\ &=A'B(C+C')+BC(A+A')\\\ &=A'B+BC \end{align}$$
2. 根据基本公式中的 $A+A'=1$ 可以在函数式中的某一项上乘以 $(A+A')$，然后拆成两项分别与其他项合并，有时能得到更加简单的化简结果。例如：
   $$\begin{align} Y&=AB'+A'B+BC'+B'C\\\ &=AB'+A'B(C+C')+BC'+(A+A')B'C\\\ &=AB'+A'BC+A'BC'+BC'+AB'C+A'B'C\\\ &=(AB'+AB'C)+(BC'+A'BC')+(A'BC+A'B'C)\\\ &=AB'+BC'+A'C \end{align}$$

在化简复杂的逻辑函数时，往往需要灵活、交替地综合运用上述方法，才能得到最后的化简结果。例如：
$$\begin{align} Y&=AC+B'C+BD'+CD'+A(B+C')+A'BCD'+AB'DE\\\ &=AC+B'C+BD'+CD'+A(B'C)'+AB'DE\\\ &=AC+B'C+BD'+CD'+A+AB'DE\\\ &=A+B'C+BD'+CD'\\\ &=A+B'C+BD' \end{align}$$

### 2.6.2 卡诺图化简法

从前面公式化简法的例题中可以看出，用公式运算的方法化简不同的逻辑函数时，没有固定的方法和步骤，存在很大的灵活性。用这种方法化简复杂的逻辑函数时，必须具备熟练掌握和灵活运用逻辑代数的公式和定理的能力，方能得到满意的化简结果。因此，我们希望能找到一种对任何逻辑函数都适用的，而且具有固定操作步骤和方法的化简方法。

于是我们想到，既然任何逻辑函数都可以展开为最小项之和的形式，那么采用**合并最小项**的方法化简逻辑函数，就应当是适用于任何逻辑函数的、通用的化简方法。

下面介绍的卡诺图化简法就是一种基于合并最小项的化简方法。

#### 一、逻辑函数的卡诺图表示法

**将变量的全部最小项各用一个小方块表示，并使具有逻辑相邻性的最小项在几何位置上也相邻地排列起来，所得到的图形称为变量最小项的卡诺图**。因为这种表示方法是由美国工程师卡诺（M. Karnaugh）首先提出的，所以将这种图形称为**卡诺图**（Karnaugh Map）。

图 2.6.1 中画出了二到五变量最小项的卡诺图。**图形两侧标注的 0 和 1 表示使对应小方格内的最小项为 1 的变量取值**。同时，这些 0 和 1 组成的二进制数所对应的十进制数大小也就是对应的最小项的编号。

<div align=center>
<img width=80% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.6.1二到五变量最小项的卡诺图.png"/><br>
</div>

<mark>为了保证图中几何位置相邻的最小项在逻辑上也具有相邻性，这些数码不能按自然二进制数从小到大地顺序排列，而必须按图中的方式排列，以确保相邻的两个最小项仅有一个变量是不同的</mark>。

从图 2.6.1 所示的卡诺图上还可以看到，**处在任何一行或一列两端的最小项也仅有一个变量不同，所以它们也具有逻辑相邻性**。因此，**从几何位置上应当将卡诺图看成是上下、左右闭合的图形**。

<mark>在变量数大于、等于五以后，仅仅用几何图形在两维空间的相邻性来表示逻辑相邻性已经不够了</mark>。例如，在图 2.6.1(d) 所示的**五变量最小项的卡诺图**中，**除了几何位置相邻的最小项具有逻辑相邻性以外，以图中双竖线为轴左右对称位置上的两个最小项也具有逻辑相邻性**。

既然任何一个逻辑函数都能表示为若干最小项之和的形式，那么自然也就可以设法用卡诺图来表示任意一个逻辑函数。具体的方法是：首先将逻辑函数化为最小项之和的形式，然后在卡诺图上与这些最小项对应的位置上填入 1，在其余的位置上填入 0，就得到了表示该逻辑函数的卡诺图。也就是说，任何一个逻辑函数都等于它的卡诺图中填人 1 的那些最小项之和。

#### 二、用卡诺图化简逻辑函数

利用卡诺图化简逻辑函数的方法称为**卡诺图化简法**或**图形化简法**。化简时依据的基本原理就是具有相邻性的最小项可以合并，并消去不同的因子。由于**在卡诺图上几何位置相邻与逻辑上的相邻性是一致的**，因而从卡诺图上能直观地找出那些具有相邻性的最小项并将其合并化简。

##### 1. 合并最小项的原则

若两个最小项相邻，则可合并为一项并消去一对因子。合并后的结果中只剩下公共因子。

在图 2.6.4（a）和（b）中画出了两个最小项相邻的几种可能情况。例如，图（a）中 $A'BC$（$m_3$）和 $ABC$（$m_7$）相邻，故可合并为
$$A'BC+ABC=(A'+A)BC=BC$$
合并后将 $A$ 和 $A'$ 一对因子消掉了，只剩下公共因子 $B$ 和 $C$。

<div align=center>
<img width=80% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.6.4_最小项相邻的几种情况.png"/><br>
</div>

若四个最小项相邻并排列成一个矩形组，则可合并为一项并消去两对因子。合并后的结果中只包含公共因子。

例如，在图 2.6.4（d）中，$A'BC'D$（$m_5$）、$A'BCD$（$m_7$）、$ABC'D$（$m_13$）、$ABCD$（$m_15$）相邻，故可合并。合并后得到
$$\begin{align} &A'BC'D+A'BCD+ABC'D+ABCD\\\ =&A'BD(C+C')+ABD(C+C')\\\ =&BD(A+A')\\\ =&BD \begin{align}$$
可见，合并后消去了 $A$、$A'$ 和 $C$、$C'$ 两对因子，只剩下四个最小项公共因子 $B$ 和 $D$。

若八个最小项相邻并且排列成一个矩形组，则可合并为一项并消去三对因子。合并后的结果中只包含公共因子。

例如，在图 2.6.4（e）中，上边两行的八个最小项是相邻的，可将它们合并为一项 $A'$。其他的因子都被消去了。

至此，可以归纳出合并最小项的一般规则，这就是：如果有 $2^n$ 个最小项相邻（$n=1,2,...$）并排列成一个矩形组，则它们可以合并为一项，并消去 $n$ 对因子。合并后的结果中仅包含这些最小项的公共因子。

##### 2. 卡诺图化简法的步骤

用卡诺图化简逻辑函数时可按如下步骤进行：

1. 将函数化为**最小项之和**的形式。
2. 画出表示该逻辑函数的**卡诺图**。
3. 找出可以合并的最小项。
4. 选取化简后的乘积项。选取的原则是：
   1. 这些乘积项应包含函数式中所有的最小项（应覆盖卡诺图中所有的 1）。
   2. 所用的乘积项数目最少。也就是可合并的最小项组成的矩形组数目最少。
   3. 每个乘积项包含的因子最少。也就是每个可合并的最小项矩形组中应包含尽量多的最小项。

【例 2.6.10】用卡诺图化简法将下式化简为最简与或函数式：$Y=AC'+A'C+BC'+B'C$

<div align=center>
<img width=50% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.6.5_卡诺图.png"/><br>
</div>

以下两个化简结果都符合最简与或式的标准：
$$\begin{align} Y&=AB'+A'C+BC'\\\ Y&=AC'+B'C+A'B \end{align}$$
此例说明，有时一个逻辑函数的化简结果不是唯一的。

【例 2.6.11】用卡诺图化简法将下式化为最简与或逻辑式：$Y=ABC+ABD+AC'D+C'D'+AB'C+A'CD'$

<div align=center>
<img width=40% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.6.6_卡诺图.png"/><br>
</div>

化简结果：
$$Y=A+D'$$

从图 2.6.6 中可以看到，$A$ 和 $D'$ 中重复包含了 $m_8$、$m_10$、$m_12$ 和 $m_14$ 这 4 个最小项。但据 $A+A=A$ 可知，在合并最小项的过程中允许重复使用函数式中的最小项，以利于得到更简单的化简结果。

另外，还要补充说明一个问题。在以上的两个例子中，我们都是通过合并卡诺图中的 1 来求得化简结果的。但有时也可以通过合并卡诺图中的 0 先求出 $Y$ 的化简结果，然后再将 $Y'$ 求反而得到 $Y$。

这种方法所依据的原理我们已在 2.5.4 节中做过说明。因为全部最小项之和为 1，所以若将全部最小项之和分成两部分，一部分（卡诺图中填入 1 的那些最小项）之和记作 $Y$，则根据 $Y+Y'=1$ 可知，其余一部分（卡诺图中填人 0 的那些最小项）之和必为 $Y'$。

<mark>在多变量逻辑函数的卡诺图中，当 0 的数目远小于 1 的数目时，采用合并 0 的方法有时会比合并 1 来得简单</mark>。例如，在图 2.6.6 所示的卡诺图中，如果将 0 合并，则可立即写出
$$Y'=A'D,\ Y=((Y'))'=(A'D)'=A+D'$$
与合并 1 得到的化简结果一致。

此外，在需要将函数化为最简的与或非式时，采用合并 0 的方式最为适宜，因为得到的结果正是与或非形式。如果要求得到 `Y'` 的化简结果，则采用合并 0 的方式就更简便了。

### \*2.6.3 奎恩-麦克拉斯基化简法（Q-M 法）

从上一小节的内容中不难看出，虽然卡诺图化简法具有直观、简单的优点，但它同时又存在着很大的局限性。首先，在函数的输入逻辑变量较多时（例如大于 5 以后），便失掉了直观的优点。其次，在许多情况下要凭设计者的经验确定应如何合并最小项才能得到最简单的化简结果，因而不便于借助计算机完成化简工作。

公式化简法的使用虽然不受输人变量数目的影响，但由于化简的过程没有固定的、通用的步骤可循，所以同样不适用于计算机辅助化简。

由奎恩（W.V.Quine）和麦克拉斯基（E.J.McCluskey）提出的用列表方式进行化简的方法则有一定的规则和步骤可循，较好地克服了公式化简法和卡诺图化简法在这方面的局限性，因而适用于编制计算机辅助化简程序。通常将这种化简方法称为**奎恩-麦克拉斯基法**，简称 **Q-M 法**。

**Q-M 法的基本原理仍然是通过合并相邻最小项并消去多余因子而求得逻辑函数的最简与或式**。

## 2.7 具有无关项的逻辑函数及其化简

### 2.7.1 约束项、任意项和逻辑函数式中的无关项

在处理具体的逻辑问题时，有时会遇到两种特殊情况。其中一种情况是输入变量的取值不是任意的。**对输入变量取值的限制称为约束**。我们把具有这种特点的逻辑函数称为**具有约束的逻辑函数**，同时把这一组输入变量称为**具有约束的一组逻辑变量**。

下面让我们来讨论一下图 2.7.1 给出的一个实例。图中的水箱由大、小两台水泵 $M_{\rm{L}}$ 和 $M_{\rm{S}}$ 供水。水箱中设置了 3 个水位检测元件 $A$、$B$、$C$。水位低于检测元件时，检测元件给出低电平；水位高于检测元件时，检测元件给出高电平。

<div align=center>
<img width=50% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.7.1_约束项.png"/><br>
</div>

现以 $Y_{\rm{S}}$ 和 $Y_{\rm{L}}$、分别表示 $M_{\rm{S}}$ 和 $M_{\rm{L}}$ 的启动控制信号，取值为 1 时水泵启动，取值为 0 时水泵停止。根据要求，当水位超过 $C$ 点时（$ABC$ 的取值为 111）水泵停止工作，$Y_{\rm{S}}=0$、$Y_{\rm{L}}=0$；水位低于 $C$ 点而高于 $B$ 点时（$ABC$ 的取值为 110），小水泵 $M_{\rm{S}}$ 单独工作，$Y_{\rm{S}}=1$；水位低于 $B$ 点而高于 $A$ 点时（$ABC$ 的取值为 100），大水泵 $M_{\rm{L}}$ 单独工作，$Y_{\rm{L}}=1$；水位低于 $A$ 点时（$ABC$ 的取值为 000），$M_{\rm{S}}$ 和 $M_{\rm{L}}$ 同时工作，$Y_{\rm{S}}=1$、$Y_{\rm{L}}=1$。因此，$M_{\rm{S}}$ 和 $M_{\rm{L}}$ 的启动控制信号 $Y_{\rm{S}}$ 和 $Y_{\rm{L}}$，是 $A$、$B$、$C$ 这三个逻辑变量的逻辑函数，并可写成
$$\begin{align} Y_{\rm{L}}&=A'B'C'+AB'C'=B'C'\\\ Y_{\rm{S}}&=A'B'C'+ABC' \end{align}$$

由于不可能出现水位高于 $C$ 点而低于 $B$ 点和 $A$ 点的情况，也不可能出现水位高于 $B$ 点而低于 $A$ 点的情况，所以 $ABC$ 的取值不可能出现 001、010、011、101 这四种情况。由此可见，$A$、$B$、$C$ 是一组具有约束的逻辑变量，$Y_{\rm{S}}$ 和 $Y_{\rm{L}}$ 是两个具有约束的逻辑函数。

通常用**约束条件**来描述约束的具体内容。显然，用上面的这样一段文字叙述约束条件是很不方便的，最好能用简单、明了的逻辑语言表述约束条件。

由于每一组输入变量的取值都使一个、而且仅有一个最小项的值为 1，所以**当限制某些输入变量的取值不能出现时，可以用它们对应的最小项恒等于 0 来表示**。这样，上面例子中的约束条件可以表示为
$$\begin{align} &A'B'C=0\\\ &A'BC'=0\\\ &A'BC=0\\\ &AB'C=0\end{align}$$
或写成
$$A'B'C+A'BC'+A'BC+AB'C=0$$
同时，将这些恒等于 0 的最小项称为函数 $Y_{\rm{S}}$ 和 $Y_{\rm{L}}$ 的约束项。

<mark>在存在约束项的情况下，由于约束项的值始终等于 0，所以既可以将约束项写进逻辑函数式中，也可以将约束项从函数式中删掉，而不影响函数值</mark>。

有时还会遇到另外一种情况，就是在输入变量的某些取值下函数值是 1 还是 0 皆可，并不影响电路的功能。在这些变量取值下，其值等于 1 的那些最小项称为**任意项**。

为了进一步说明任意项的物理概念，让我们来看一个电动机控制的例子。现以三个逻辑变量 $A$、$B$、$C$ 分别表示一台电动机的正转、反转和停止的命令，$A=1$ 表示正转，$B=1$ 表示反转，$C=1$ 表示停止。表示正转、反转和停止工作状态的逻辑函数可写成
$$\begin{align} Y_1=A B' C' & \text { (正转) } \\\ Y_2=A' B C' & \text { (反转) } \\\ Y_3=A' B' C & \text { (停止) } \end{align}$$

因为任何时候电动机只能执行其中的一种命令，所以 $A$、$B$、$C$ 当中出现两个以上为 1 时，电动机将无法工作。为此，将实际的电路设计成当 $A$、$B$、$C$ 三个控制变量出现两个以上同时为 1 或者全部为 0 时电路能自动切断供电电源，那么这时 $Y_1$、$Y_2$ 和 $Y_3$ 等于 1 还是等于 0 已无关紧要，电动机肯定会受到保护而停止运行。例如，当出现 $A=B=C=1$ 时，对应的最小项 $ABC(m_7)=1$。如果把最小项 $ABC$ 写入 $Y_1$ 式中，则当 $A=B=C=1$ 时 $Y_1=1$；如果没有把 $ABC$ 这一项写入 $Y_1$ 式中，则当 $A=B=C=1$ 时 $Y_1=0$。因为这时 $Y_1=1$ 还是 $Y_1=0$ 都是允许的，所以既可以把 $ABC$ 这个最小项写人 $Y_1$ 式中，也可以不写人。因此，我们把 $ABC$ 称为逻辑函数 $Y_1$ 的任意项。同理，在这个例子中 $A'B'C'$、$A'BC$，$AB'C$、$ABC'$ 也是 $Y_1$、$Y_2$ 和 $Y_3$ 的任意项。这种存在任意项的逻辑函数也叫做**不完全定义的逻辑函数**。

因为使约束项的取值等于 1 的输入变量取值是不允许出现的，所以约束项的值始终为 0。而任意项则不同，在函数的运行过程中，有可能出现使任意项取值为 1 的输入变量取值。

我们**将约束项和任意项统称为逻辑函数式中的无关项**。这里所说的“无关”是指是否把这些最小项写人逻辑函数式无关紧要，可以写人也可以删除。

上一节中曾经讲到，在用卡诺图表示逻辑函数时，首先将函数化为最小项之和的形式，然后在卡诺图中这些最小项对应的位置上填入 1，其他位置上填入 0。既然可以认为无关项包含于函数式中，也可以认为不包含在函数式中，那么在卡诺图中对应的位置上就可以填人 1，也可以填入 0。为此，在卡诺图中用 $\times$（或 $\oslash$）表示无关项。在化简逻辑函数时既可以认为它是 1，也可以认为它是 0。

### 2.7.2 无关项在化简逻辑函数中的应用

化简具有无关项的逻辑函数时，如果能合理利用这些无关项，一般都可得到更加简单的化简结果。

为达到此目的，加入的无关项应与函数式中尽可能多的最小项（包括原有的最小项和已写入的无关项）具有逻辑相邻性。

合并最小项时，究竟把卡诺图中的 $\times$ 作为 1（即认为函数式中包含了这个最小项）还是作为 0（即认为函数式中不包含这个最小项）对待，应以得到的相邻最小项矩形组合最大、而且矩形组合数目最少为原则。

【例 2.7.1】化简具有约束的逻辑函数：$Y=A'B'C'D+A'BCD+AB'C'D'$，给定约束条件为
$$A'B'CD+A'BC'D+ABC'D'+AB'C'D+ABCD+ABCD'+AB'CD'=0$$
在用最小项之和的形式表示上述具有约束的逻辑函数时，也可写成如下形式
$$Y(A, B, C, D)=\sum m(1,7,8)+d(3,5,9,10,12,14,15)$$
式中以 $d$ 表示无关项，$d$ 后面括号内的数字是无关项的最小项编号。

如果不利用约束项，则 Y 已无可化简。但适当地加进一些约束项以后，可以得到
$$\begin{align} Y&=(A'B'C'D+A'B'CD)+(A'BCD+A'BC'D)+(AB'C'D'+ABC'D')+(ABCD'+AB'CD')\\\ &=(A'B'D+A'BD)+(AC'D'+ACD')\\\ &=A'D+AD' \end{align}$$
可见，利用了约束项以后，是逻辑函数得以进一步化简。但是，在确定该写入哪些约束项时尚不够直观。

如果改用卡诺图化简法，则只要将表示 Y 的卡诺图画出，就能从图上直观地判断对这些约束项应如何取舍。

图 2.7.2 是例 2.7.1 的逻辑函数的卡诺图。从图中不难看出，为了得到最大的相邻最小项的矩形组合，应取约束项 $m_3$、$m_5$ 为 1，与 $m_1$、$m_7$ 组成一个矩形组。同时取约束项 $m_10$、$m_12$、$m_14$ 为 1，与 $m_8$ 组成一个矩形组。将两组相邻的最小项合并后得到的化简结果与上面推演的结果相同。卡诺图中没有被圈进去的约束项（$m_9$ 和 $m_15$）是当作 0 对待的。

<div align=center>
<img width=40% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.7.2_约束项.png"/><br>
</div>

【例 2.7.2】试化简具有无关项的逻辑函数
$$Y(A, B, C, D)=\sum m(2,4,6,8)+d(10,11,12,13,14,15)$$

<div align=center>
<img width=40% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.7.3_约束项.png"/><br>
</div>

根据卡诺图得到化简结果为
$$Y=BD'+AD'+CD'$$

## 2.8 多输出逻辑函数的化简

在化简多输出逻辑函数的过程中，我们发现，如果不是孤立地分别对每一个输出函数进行化简，而是从整体上综合考虑进行化简，有时会获得更加简单的化简结果，使得所用门电路的数目和所有门电路总的输入端数目均为最少。例如有下面的一组多输出逻辑函数需要化简
$$\begin{aligned} &Y_1(A,B,C,D)=\sum(1,4,5,6,7,10,11,12,13,14,15) \\\ &Y_2(A,B,C,D)=\sum(1,3,4,5,6,7,12,14) \\\ &Y_3(A,B,C,D)=\sum(3,7,10,11) \end{aligned} $$

如果用卡诺图分别化简每一个函数，并按图 2.8.1 所示合并最小项，就可得到如下的化简结果
$$\begin{aligned} &Y_1(A,B,C,D)=B+AC+A'C'D \\\ &Y_2(A,B,C,D)=A'D+BD' \\\ &Y_3(A,B,C,D)=A'CD+AB'C \end{aligned} $$

<div align=center>
<img width=80% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.8.1_卡诺图.png"/><br>
</div>

如果我们改用图 2.8.3 所示的方式合并最小项，即找出 $Y_1$、$Y_2$、$Y_3$ 之间存在的共用项并加以利用，就可以得到如下式所示的另一种化简结果，即
$$\begin{aligned} &Y_1(A,B,C,D)=B+AB'C+A'C'D \\\ &Y_2(A,B,C,D)=A'C'D+A'CD+BD' \\\ &Y_3(A,B,C,D)=A'CD+AB'C \end{aligned} $$

<div align=center>
<img width=80% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.8.3_卡诺图.png"/><br>
</div>

由于 $Y_1$ 和 $Y_3$ 中都含有 $AB'C$ 这一项，所以我们将 $AB'C$ 称作 $Y_1$ 和 $Y_3$ 共有的**共用项**。同理，$A'C'D$ 是 $Y_1$ 和 $Y_2$ 共有的共用项，$A'CD$ 是 $Y_2$ 和 $Y_3$ 共有的**共用项**。虽然现在 $Y_1$、$Y_2$、$Y_3$ 每个函数本身不是最简与或形式了，但是在用逻辑图实现多输出逻辑函数时，由于每个共用项可以同时供两个输出函数使用，从而减少了所需门电路的数目，于是就得到了图 2.8.4 中的电路。和图 2.8.2 的电路相比，图 2.8.4 电路不仅少用了 2 个门，而且电路中总的连线数目也减少了。

<div align=center>
<img width=60% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.8.4_逻辑电路图.png"/><br>
</div>

以上的例子说明，在化简多输出逻辑函数时，通过寻找并合理地利用共用项，有时可以得到更简单的化简结果。然而在实际应用中我们发现，并不是任何情况下，利用共用项都能够得到更简单的化简结果。对于**两级与或**形式的多输出逻辑函数，可以利用 Q-M 化简法进行化简，找出可以利用的共用项，并利用这些共用项得到更简单的化简结果。

## 2.9 逻辑函数形式的变换

在前面所讲的逻辑函数化简方法中，都是以最简与或式作为化简目标的。然而在用电路实现这些逻辑函数时，这种最简与或式有时并不是理想的形式。这是因为**在电路实现的过程中，往往可供选择的电子器件种类有限**，所以必须把逻辑函数的形式变换为与所用器件相适应的形式。

在使用标准化的数字集成电路组成所需要的逻辑电路时，不仅受到所提供的门电路类型的限制，而且由于**很难找到具有 4 个以上输人端的与门和或门**，因而当与或逻辑函数式的输人变量数和乘积项数很大时，就无法用一个两级的与或电路实现这个逻辑函数。在 PLD 当中，虽然某些 PAL 型 PLD 可以满足生成多输入变量、多乘积项的与或逻辑函数的需要，但是在用来实现输入变量数和乘积项数较少的与或逻辑函数时，器件内部的资源将得不到充分利用。因此，在 FPGA 型 PLD 的结构中，所提供的门电路都是输入端不多、逻辑功能种类有限的几种。可见，在使用 PLD 实现逻辑函数的过程中，同样会遇到逻辑函数形式变换的问题。所幸**这种变换工作现在已经完全可以由 PLD 的编程软件来完成了**。

例如我们需要用门电路实现下式的逻辑函数
$$Y=AB'C'+A'BC' \tag{2.9.1}$$

如果有 **3 输入端的与门**和 **2 输入端的或门**可以选用，则可以很方便地与上式对应地接成图 2.9.1 的两级与或逻辑电路。

<div align=center>
<img width=40% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.9.1_逻辑电路.png"/><br>
</div>

但如果限定只能使用 **2 输入端的与非门**，这时就需要将式（2.9.1）变换为全部由两变量与非运算组成的形式。为此，可利用摩根定理将式（2.9.1）进行**两次求反运算**，变换成**与非-与非**形式，得到
$$\begin{align} Y&=AB'C'+A'BC'\\\ &=((AB'C'+A'BC')')'\\\ &=((AB'C)'(A'BC')')'\\\ &=((((AB')')'C')'(((A'B)')'C)')' \end{align}$$

按照上式就得到了全部由**2 输入端与非门**组成的逻辑电路，如图 2.9.2 所示。其中 $G_3$ 和 $G_4$ 两个**与非门**被接成了反相器使用。

如果有**异或门**和**与门**可以使用，则应当将式（2.9.1）变换成下面的形式
$$\begin{align} Y&=AB'C'+A'BC'\\\ &=(AB'+A'B)C'\\\ &=(A\oplus B)C' \end{align}$$
根据上式就得到了图 2.9.3 的逻辑电路。

<div align=center>
<img width=40% src="computer_science\digital_electronics\数字电子技术基础_阎石\image\图2.9.2_逻辑电路.png"/><br>
</div>

## 本章小结

这一章所讲的内容主要是逻辑代数的公式和定理、逻辑函数的描述方法、逻辑函数的化简和变换这三部分。为了进行逻辑运算，必须熟练掌握表 2.3.1 中的基本公式。至于表 2.3.3 中的常用公式，完全可以由基本公式导出。尽管如此，掌握尽可能多的常用公式仍然是十分有益的，因为直接引用这些公式可以大大提高运算效率。

在逻辑函数的描述方法中，共介绍了五种描述方法，即真值表、逻辑函数式、逻辑图、波形图和卡诺图。这几种方法之间可以任意地互相转换。根据具体的使用情况，可以选择最适当的一种方法描述所研究的逻辑函数。

在逻辑函数化简方法当中，一共介绍了三种方法一公式化简法、卡诺图化简法和 Q-M 法。公式化简法的优，点是它的使用不受任何条件的限制。但由于这种方法没有固定的步骤可循，所以在化简复杂的逻辑函数时，不仅需要熟练地运用各种公式和定理，而且需要有一定的运算技巧和经验。

卡诺图化简法是一种通过合并最小项进行化简的方法。它的优点是简单、直观，而且有一定的化简步骤可循。初学者容易掌握这种方法，而且化简过程中也易于避免出差错。然而在逻辑变量超过 5 个以上时，将失去简单、直观的优，点，因而也就没有多大的实用价值了。

Q-M 法的基本原理仍然是通过合并最小项的方法来化简逻辑函数。但由于 Q-M 法有一定的化简步骤，所以适合于机器运算。这种方法已经被用于编制分析和设计数字电路的计算机程序。

在具体设计数字电路的过程中，通常可供使用的器件类型是有限的，这就需要利用逻辑函数的公式和定理，将函数式化成与所用器件逻辑类型相适应的形式，而不一定是最简的与或形式。变换后的逻辑函数式可能既不是由单一的与非运算组成的，也不是由单一的或非运算组成的，而且可能是多级函数式。因此，究竟将函数式化成什么形式最有利，要根据选用哪些类型的电子器件而定。此外，在化简一组多输出逻辑函数时，不应仅以孤立地求出每个函数输出的最简形式为目标，而应通过找出并合理利用共用项，以求得总体最简的化简结果。

鉴于现代的数字电路规模日益庞大，产品更新的周期越来越短，因而使用已有的电路模块组成所需要的逻辑电路已经成为设计人员经常使用的方法。这种方法不仅可以提高设计速度，而且有利于降低设计成本。在后面的章节里还将看到，采用模块电路进行设计时，同样需要将逻辑函数式变换成与所用模块电路相适应的形式。

目前用于数字集成电路设计和 PLD 开发的 EDA 软件中，一般都具备逻辑函数化简和变换的功能。在使用这些 EDA 软件进行设计时，逻辑函数的化简和变换工作都是由计算机完成的。
